<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>水稻耐盐讲座</title>
    <url>/2020/04/14/%E6%B0%B4%E7%A8%BB%E8%80%90%E7%9B%90%E8%AE%B2%E5%BA%A7/</url>
    <content><![CDATA[<p>苗期耐盐<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200414200416.png" alt><br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200414200543.png" alt><br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200414200718.png" alt><br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200414200927.png" alt></p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Biomolecular Networks Methods and Applications in Systems Biology</title>
    <url>/2020/04/06/Biomolecular-Networks-Methods-and-Applications-in-Systems-Biology/</url>
    <content><![CDATA[<p> 1 介绍 1.1<br>1.2 1.3 1.4<br>1
分子生物学基础知识/ 1<br>1.1.1 基因组，基因和DNA复制过程/ 5<br>1.1.2 RNA合成的转录过程/ 6<br>1.1.3 蛋白质合成的翻译过程/ 7<br>细胞中的生物分子网络/ 8 网络系统生物学/ 13 关于本书/ 18<br>I 基因网络 23 2 转录法规:网络和模型 25<br>2.1 转录调控和基因表达/ 25<br>2.1.1 转录和基因调控/ 25<br>2.1.2 微阵列实验和数据库/ 28<br>2.1.3 芯片技术和转录因子数据库/ 30<br>2.2 转录监管网络/ 32<br>2.3 基于生化反应的非线性模型/ 36<br>2.4 监管网络的集成模型/ 43<br>2.5 摘要/ 44<br>vii</p>
<p> ii 内容<br>3 基因调控网络的重建 47<br>3.1 基因调控网络的数学模型/ 47<br>3.1.1 布尔网络/ 48<br>3.1.2 贝叶斯网络/ 49<br>3.1.3 马尔可夫网络/ 52<br>3.1.4 微分方程/ 53<br>3.2 重建基因调控网络/ 55<br>3.2.1 奇异值分解/ 56<br>3.2.2 基于模型的优化/ 58<br>3.3 从多个数据集推断基因网络/ 61<br>3.3.1 多种数据集网络结构的一般解决方案和特殊解决方 案/ 63<br>3.3.2 分解算法/ 65<br>3.3.3 数值验证/ 67<br>3.4 基于基因网络的药物靶标识别/ 72<br>3.4.1 网络识别方法/ 73<br>3.4.2 线性编程框架/ 77<br>3.5 摘要/ 87<br>4 转录调控网络的推论 89<br>4.1 预测TF结合位点和启动子/ 89<br>4.2 转录相互作用的推论/ 92<br>4.2.1 微分方程方法/ 93<br>4.2.2 贝叶斯方法/ 96<br>4.2.3 数据挖掘和其他方法/ 98<br>4.3 确定TF的组合规定/ 99<br>4.4 推断合作监管网络/ 105<br>4.4.1 数学模型/ 105<br>4.4.2 估计TF活动/ 106<br>4.4.3 线性规划模型/ 108<br>4.4.4 数值验证/ 109<br>4.5 转录因子活性预测/ 114<br>4.5.1 矩阵分解/ 114<br>4.5.2 非线性模型/ 117<br>4.6 摘要/ 118</p>
<p> II 蛋白质相互作用网络<br>5 蛋白质与蛋白质相互作用的预测<br>5.1 实验性蛋白质–蛋白质相互作用/ 121<br>5.2 蛋白质与蛋白质相互作用的预测/ 126<br>5.2.1 关联方法/ 127<br>5.2.2 最大可能性估算/ 134<br>5.2.3 确定性优化方法/ 139<br>5.3 基于多域对/ 150的蛋白质相互作用预测<br>5.3.1 合作域，强合作域，超域/ 152<br>5.3.2 多域交互的推论/ 154<br>5.3.3 数值验证/ 157<br>5.3.4 通过多域交互重构复杂对象/ 160<br>内容 iii 119 121<br>5.4 域交互预测方法/ 163<br>5.4.1 统计方法/ 163<br>5.4.2 域对排除分析/<br>5.4.3 简约解释方法/<br>5.4.4 整合方法/ 165<br>163 164<br>5.5 摘要/<br>6 生物分子网络的拓扑结构<br>167<br>6.1 生物分子网络的统计特性/ 169<br>6.2 蛋白质相互作用网络的进化/ 173<br>6.3 生物分子网络中的集线器，基序和模块化/<br>174<br>6.3.1 网络中心和集线器/ 174<br>6.3.2 网络模块化和图案/ 177<br>6.4 集线器和网络主题的探索性作用/ 179<br>6.4.1 集线器和网络主题组织的动态模块化 / 180<br>6.4.2 网络主题充当路径之间的连接器/ 186<br>6.5 生物分子网络的模块性评估/ 194<br>6.5.1 模块化密度D / 195<br>6.5.2 通过D / 196提高模块分辨率极限<br>169</p>
<p> iv 内容<br>6.5.3 D和内核之间的等价k Means / 198<br>6.5.4 D扩展到一般标准:Dl 和Dw/<br>6.5.5 数值验证/ 200<br>6.6 摘要/ 204<br>7 生物分子网络的比对<br>7.1 多种生物分子网络/ 205<br>7.2 生物分子网络的成对比对/ 207<br>7.2.1 基于得分的算法/ 208<br>7.2.2 进化指导方法/ 211<br>7.2.3 图匹配算法/ 212<br>7.3 通过数学编程进行网络对齐/ 213<br>7.3.1 整数编程公式/ 214<br>199<br>7.3.2 整数二次编程方法/ 216的组成部分<br>7.3.3 数值验证/ 217<br>7.4 生物分子网络的多重比对/ 223<br>7.5 子网和路径查询/ 225<br>7.6 摘要/ 228<br>8 基于网络的蛋白质功能预测 231<br>8.1 蛋白质功能和注释/ 231<br>8.2 蛋白质功能模块检测/ 234<br>8.2.1 基于距离的聚类方法/ 235<br>8.2.2 图聚类方法/ 236<br>8.2.3 验证模块检测/ 238<br>8.3 蛋白质功能注释的功能链接/ 239<br>8.3.1 贝叶斯方法/ 239<br>8.3.2 Hopfield网络方法/ 241<br>8.3.3 p值法/ 242<br>8.3.4 统计框架/ 243<br>8.4 高通量数据对蛋白质功能的预测/ 249<br>8.4.1 邻里方法/ 250<br>8.4.2 优化方法/ 251<br>8.4.3 概率方法/ 254<br>8.4.4 机器学习技术/ 256<br>205</p>
<p> 8.5 域的功能注释方法/ 265<br>8.5.1 域名来源/ 267<br>8.5.2 异构数据集成/ 268<br>8.5.3 域功能预测/ 270<br>8.5.4 数值验证/ 271<br>8.6 摘要/</p>
<h2 id="III-代谢网络和信号传导网路-279"><a href="#III-代谢网络和信号传导网路-279" class="headerlink" title="III 代谢网络和信号传导网路 279"></a>III 代谢网络和信号传导网路 279</h2><h3 id="9-代谢网络-分析，重构，与应用-281"><a href="#9-代谢网络-分析，重构，与应用-281" class="headerlink" title="9 代谢网络:分析，重构，与应用 281"></a>9 代谢网络:分析，重构，与应用 281</h3><p>9.1细胞新陈代谢和代谢途径<br>细胞功能是通过其化学成分的相互作用来完成的。细胞代谢是细胞中发生的所有生化反应的总集合，例如涉及降解食物分子，合成大分子以及产生小前体分子的反应。它还包括所有涉及电子转移的反应。代谢过程通常分为两大类，即中间代谢阶段。一种是分解代谢，将各种底物分解成常见的代谢产物，包括从营养中去除电子，并在细胞呼吸中收集能量。换句话说，分解代谢包括降解和增能反应，其中复杂的物质和大分子分解为低分子量化合物。通常，分解代谢中的反应是氧化的，并产生还原电位。另一个是合成代谢，它合成氨基酸，脂肪酸和核酸等复杂分子，利用能量使分子富集电子，并需要细胞消耗从营养分解代谢中获得的能量。换句话说，合成代谢包括生物合成和需要能量的反应，其中复杂物质和大分子是由低分子量前体合成的。通常，合成代谢的反应是还原性的，并且消耗还原潜力。在分解代谢和合成代谢过程中，通过一组载体分子（例如ATP，GTP，NADH和NADPH）进行复杂的化学基团交换和还原-氧化（氧化还原）电势。这些载体分子及其转移的物质组成了细胞中的全部新陈代谢。图9.1说明了细胞代谢的主要部分，其中中间代谢将原材料转化为能量以及细胞的组成部分，例如蛋白质和膜。<br>细胞中的所有生化反应均由一种称为酶的特殊蛋白质催化，该蛋白质通常需要饮食中的矿物质，维生素和其他辅助因子才能正常运行。这些生化反应使生物能够生长，繁殖，维持其结构并对环境作出反应。在充满不同类型化学反应的生物系统中，能量（定义为工作能力）必不可少。生物系统中能量的两种基本类型是势能和动能。势能是物质由于其结构或位置而具有的状态或位置的能量。它是等待工作的存储能量。例如，化学键由于其结构而具有势能。动能是运动的能量。这是可以起作用的能量类型。动能和势能都可以以多种形式找到，例如电，光，化学，热和机械形式。在某些条件下，可以遵循热力学定律将能量从一种形式转换或转换为另一种形式。可用能量称为自由能（G）。不可利用的能量是熵，它衡量了系统的无序性。用能化学反应释放出自由能，并且自由能发生负向变化（DG，0）。内能化学反应消耗自由能，并且自由能发生正向变化（DG。0）。三磷酸腺苷（ATP）在生物系统中是一种能源。一种重要的能动反应是<br>ATP键的断裂，其中ATP在水解后释放出相对大量的自​​由能。 ATP循环耦合了能动和性能反应。它捕获在能级化学反应中释放的自由能，并将捕获的能量转移到负电子反应的反应物中。<br>酶是生物系统的催化剂，可通过降低能垒，提供引发反应所需的活化能来影响生化反应的速率[Sad07]。几乎所有已知的酶都是蛋白质。酶最显着的特征是它们的催化能力和特异性。酶不仅决定化学转化的方式，而且还介导一种能量形式向另一种能量形式的转化。在没有酶的情况下，生物系统中的大多数反应不会以可察觉的速率发生。通常，酶根据其催化的反应类型进行分类。国际生物化学联合会建立了一个酶委员会（EC）来开发酶的命名法，其中反应分为六个主要组，编号为1-6（表9.1）。这些组被细分并进一步细分，因此以四位数字开头的字母EC（用于酶委员会）可以精确识别所有酶。<br>代谢途径是细胞内发生的一系列化学反应，其中一种化学物质通过一系列酶的催化化学反应转化为另一种化学反应。代谢途径可以是几个反应的简单线性序列，也可以是广泛分支的反应，这些反应汇聚或偏离中心主要途径。生物系统中有许多代谢途径。其中一些是许多活生物体所共有的。例如，糖酵解代谢参与葡萄糖氧化以获得ATP，它是许多生物体中的能量转换途径。柠檬酸循环涉及乙酰基-CoA氧化，以获得GTP和有价值的中间体。它通常受底物可用性，产物抑制作用和某些循环中间体的调控。氧化磷酸化途径处理由糖酵解和柠檬酸循环释放的电子。戊糖磷酸途径参与戊糖的合成和合成代谢反应所需的还原能力的释放。其他主要的代谢途径包括脂肪酸代谢，糖原代谢和氨基酸代谢。许多化学物质可能参与细胞内存在的多种途径。这些途径的集合非常复杂，并形成了复杂的代谢网络，是代谢和身体的完整集合。确定细胞生理和生化特性的过程（见图9.2）。 这些网络包括代谢的化学反应以及指导这些反应的调节相互作用，并成为阐明细胞机制和建模代谢的强大工具。 随着基因组技术的发展，许多生物中的代谢网络可以通过生化反应来重建[Ree03]。<br>表9.2列出了一些主要的代谢网络数据库。 京都基因与基因组百科全书（KEGG）途径是一个数据库，其中包含有关确定细胞生理和生化特性的过程（见图9.2）。这些网络包括代谢的化学反应以及指导这些反应的调节相互作用，并成为阐明细胞机制和建模代谢的强大工具。随着基因组技术的发展，许多生物中的代谢网络可以通过生化反应来重建[Ree03]。<br>表9.2列出了一些主要的代谢网络数据库。京都基因与基因组百科全书（KEGG）途径是一个数据库，其中包含有关基因与蛋白质的分子相互作用和反应网络的信息。它包括来自各种生物体的所有已知代谢途径的图形途径图。 BioCyc是371个途径数据库的集合，其中包含特定于某些生物的完整数据库。 BioCyc集合中的每个途径数据库都描述了单个生物的基因组和代谢途径。例如，属于BioCyc的EcoCyc是关于大肠杆菌整个基因组的高度详细的生物信息学数据库。 EcoCyc包含有关转录调控，蛋白质复合物，酶，转运蛋白和代谢途径的文献资料。此外，MetaCyc是代谢途径的百科全书，是一种代谢途径和酶数据库，其中包含从1500种生物中阐明的1100条代谢途径。 MetaCyc中的大多数代谢途径均来自科学实验文献。 MetaCyc包含参与一级和二级代谢的途径，以及相关的化合物，酶和基因。 BRENDA是一个酶数据库，其中包含有关酶和酶反应的全面信息。它是欧洲生物信息研究所（EBI）的SRS5序列检索系统的代谢途径数据库集中嵌套的几个数据库之一。<br>代谢网络具有与其他生物网络共享的一些共同特性，并且还具有独特的特征。为了阐明生物代谢的组织原理和生物学原理，最近的研究采用图论方法分析大型代谢网络。与其他蜂窝网络的隔离功能模块组织不同，Ravasz等人。对许多生物的代谢网络进行了研究，发现它们被组织成许多高度连接的拓扑模块，这些模块以分层的方式结合了较大的，内聚力较小的单元[Rav02]。这种单元的数量和程度通常遵循幂律分布。 Jeong等。系统地比较了43种生物的代谢网络的数学分析[Jeo00]，发现这些<br>代谢网络具有相同的拓扑缩放特性，并且与复杂的非生物系统的固有组织具有惊人的相似性。相反，有田指出，代谢网络具有通量分布，其平均路径长度比网络结构中观察到的平均路径长度长，并且它们的功能状态可能不具有无标度特性[Ari04]。 Mahadevan和Palsson研究了代谢网络的结构和功能之间的关系[Mah05]。他们发现，与其他影响类型的生物网络（如蛋白质-蛋白质相互作用网络或调控网络）不同，在流动型代谢网络中，节点反应的实质与节点中心性无关。这些结果表明，由于网络表示和功能限制，不同生物网络之间存在根本差异。他们的研究表明，即使是代谢网络中连接最少的节点，对于那些连接程度高的节点，对于整个网络功能而言也很关键。<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200406160731.png" alt></p>
<p>9.1 细胞代谢和代谢途径/ 281<br>9.2 代谢网络分析与建模/ 286<br>9.2代谢网络分析与建模<br>代谢网络的动态仿真和分析使我们能够阐明代谢过程的潜在机制。信号网络和代谢网络均由许多生化反应组成。因此，自然代谢网络也可以通过常微分方程（ODE）或Petri网建模。但是，尽管与信令网络相似，但是它们具有一些不同的属性，在数学建模中应该考虑这些属性。在信号传导途径中，我们不仅关注物质流，还关注信号流，信号流是通过磷酸化和去磷酸化的蛋白质形式来实现的[Sac06]。相反，在代谢网络中，化学计量的反应方程式控制着新陈代谢的动力学，新陈代谢的动力学强调物质的流动。尤其是酶的活性动力学具有特殊的动力学。这些因素导致新陈代谢网络模拟的特殊功能，这些功能不同于其他生物分子网络。</p>
<p>9.2.1 助焊剂平衡分析/ 286</p>
<p>9.2.1通量平衡分析<br>磁通量平衡分析（FBA）是根据化学定律对代谢进行的数学分析，已被证明是分析细胞系统代谢能力的非常有用的技术。例如，使用FBA，只要已知某些营养素，我们就可以知道哪些代谢通量使生物体的生长速率最大化。亚马逊物流的基础知识已在文献[LeM06，Kau03]中进行了评论。在这里，我们仅作简要介绍。<br>图9.3说明了一个反应网络和FBA。化学计量是化学反应中反应物和产物的定量关系的计算。代谢网络可以由化学计量矩阵S表示，其行对应于代谢物，列对应于反应。 S中的元素是相关反应的化学计量系数。代谢通量，通常用v表示，是分子通过反应或酶的周转率。流量调节对于所有代谢途径的调节至关重要</p>
<p>9.2.2 基本模式和极端路径分析/ 288<br>9.2.3 代谢网络建模/ 292</p>
<p>9.2.3代谢网络建模<br>生化反应网络的建模在代谢途径领域获得了很大的成功。除了FBA和极端途径分析以外，还开发了许多其他技术来研究代谢系统。与信号通路建模一样，代谢网络建模也包含一系列生化反应，包括结合，解离，复合物形成，分子基团的转移，磷酸化和去磷酸化。尽管有这些相似之处，但信号传导和代谢之间仍存在重大差异，这导致了代谢网络建模中的某些特殊功能。例如，在代谢中，酶和底物的量通常相差几个数量级，这使得Michaelis – Menten动力学适合于对代谢网络进行建模[Kli06]。相反，在信号通路建模中，由于催化剂和底物分子的数量处于同一数量级，因此通常采用质量作用动力学。<br>尽管FBA和极端途径分析已广泛用于研究代谢网络，但它们实际上是基于代谢网络的拓扑分析。有几个可用的公共领域生化反应数据库，例如BRENDA，可提供酶促反应动力学，但与大量反应数据相比却不够。由于动力学参数数量不足，动力学建模仍然具有挑战性。已经提出了一种无需事先了解潜在速率方程式和参数就可以定量解释代谢系统可能动力学的方法[Ste06]。该方法通过使用局部线性模型建立在代谢通量和代谢中间体浓度上。每个稳定的代谢状态都与动态特性的唯一光谱相关，动态光谱由与相应状态一致的所有可能动力学模型的集合定义。该策略代表了从通量平衡分析到代谢系统明确动力学模型的中间步骤[Ste06]。</p>
<p>9.3 代谢网络的重建/ 294<br>9.3.1 基于反应和化合物的寻路/ 294<br>9.3.2 基于通量曲线的化学计量方法/ 297<br>9.3.3 从时间过程数据/ 298推断生化网络<br>9.4 代谢网络中的药物靶标检测/ 300<br>9.4.1 药物目标检测问题/ 301<br>9.4.2 整数线性规划模型/ 302<br>9.4.3 数值验证/ 305<br>9.5 摘要/ 311</p>
<h3 id="10-信令网络-建模和推理-313"><a href="#10-信令网络-建模和推理-313" class="headerlink" title="10 信令网络:建模和推理 313"></a>10 信令网络:建模和推理 313</h3><p>10.1 蜂窝系统中的信号转导/ 313<br>10.2 信号传导途径的建模/ 316<br>10.2.1 微分方程模型/ 317<br>10.2.2 Petri网模型/ 319<br>10.3 从高通量数据/ 321推断信令网 络<br>277<br>10.3.1 网页搜索方法/ 322<br>10.3.2 订购信号组件/ 323<br>10.3.3 颜色编码方法/ 324<br>10.4 通过线性编程/ 326推断信令网络<br>10.4.1 整数线性规划模型/ 327<br>10.4.2 重要措施/ 329<br>10.4.3 数值验证/ 329<br>10.4.4 通过网络流模型/ 338推断信令网络<br>10.5 从实验证据/ 341推断信号网络<br>10.6 摘要/ 343</p>
<p>11 其他主题和新趋势 345<br>11.1 基于网络的蛋白质结构分析/ 345<br>11.2 生物分子网络整合/ 347<br>11.3 非编码RNA的转录后调控/ 349<br>11.4 生物分子相互作用与人类疾病/ 350<br>11.5 摘要/ 352<br>参考资料 353 指数 381</p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Elements of Computational Systems Biology (Wiley Series in Bioinformatics)</title>
    <url>/2020/04/05/Elements-of-Computational-Systems-Biology-Wiley-Series-in-Bioinformatics/</url>
    <content><![CDATA[<p>1计算系统生物学的进展<br>胡玛·罗迪（Huma M. Lodhi）<br>1.1简介/ 3<br>1.2多尺度计算建模/ 4<br>1.3蛋白质组学/ 7<br>1.4计算系统生物学与老化/ 8<br>1.5药物设计中的计算系统生物学<br>1.6系统生物学软件工具/ 11<br>1.7结论/ 13<br>参考文献/ 13</p>
<p>第二部分生物网络建模<br>系统生物学中的2种模型：参数问题和鲁棒性的含义<br>杰里米·古纳瓦德纳（Jeremy Gunawardena）<br>21<br>v
2.1简介/ 2​​1<br>2.2作为动力系统的模型/ 23<br>2.2.1连续模型/ 24<br>2.2.2离散模型/ 25<br>2.3参数问题/ 26<br>2.3.1参数恐惧症/ 27<br>2.3.2测量与计算/<br>27</p>
<p>3 联合治疗策略的计算机模拟分析对于心力衰竭<br>4 基于规则的建模和模型优化<br>5 细胞过程的（自然）计算观点<br>6 在细胞系统中模拟细丝动力学</p>
<h1 id="第三部分生物网络推论"><a href="#第三部分生物网络推论" class="headerlink" title="第三部分生物网络推论"></a>第三部分生物网络推论</h1><h1 id="7-监督机器学习方法对生物网络的重构"><a href="#7-监督机器学习方法对生物网络的重构" class="headerlink" title="7 监督机器学习方法对生物网络的重构"></a>7 监督机器学习方法对生物网络的重构</h1><ul>
<li>简介/ 165</li>
</ul>
<p>7.2图形重构作为模式识别问题</p>
<p>在本综述章节中，我们将重点放在重构大型生物网络结构的问题上。所谓生物网络，是指图的顶点是给定目标生物中编码的全部或部分基因和蛋白质的顶点，其有向或无向边代表各种生物学特性。作为运行示例，我们考虑以下三个图形，尽管以下介绍的方法也可以应用于其他生物网络。<br>•蛋白质间相互作用（PPI）网络。这是一个没有自环的无向图，其中包含有机体编码的所有蛋白质作为顶点。如果两个蛋白质可以物理相互作用，则它们通过边缘连接。<br>•基因调控网络。这是一个有向图，其中包含生物的所有基因作为顶点。在这些基因中，一些称为转录因子（TFs）通过与DNA结合来调节其他基因的表达。图的边缘将TF连接到它们调控的基因。如果TF进行自我调节，则可能发生自循环。此外，原则上可以标记每个边缘以指示调节是阳性（激活）还是阴性（抑制）调节。<br>•代谢网络。该图仅包含作为顶点的基因的子集，即那些编码酶的基因。酶是蛋白质，其主要功能是催化化学反应，将底物分子转化为产物分子。如果两种酶可以催化代谢途径中的两个连续反应（即两个反应），则该图中的两个酶是相关的，从而第一个酶的主要产物是第二个酶的底物</p>
<p>/ 168<br>7.2.1问题形式化/ 168<br>7.2.2模式识别/ 169<br>7.2.3图形推理作为模式识别问题<br>7.2.4使用局部模型进行图推理/ 171<br>7.2.5使用全局模型进行图推理/ 173<br>7.2.6备注/ 178<br>7.3范例/ 181<br>7.3.1代谢网络的重建/ 181<br>7.3.2重建PPI网络/ 182<br>/ 171<br>7.3.3基因调控网络的重建/ 183    </p>
<p>我们回顾了几种将图推理问题转换为经典监督分类问题的策略，实际上可以通过任何模式识别算法来解决。与从头方法相反，这些策略假定一组边已已知，并使用有关顶点和已知边的可用数据来推断缺失边。在一些涉及从各种基因组数据推断代谢，PPI和调控网络的实验中，与最新的从头方法相比，这些方法显示出良好的效果，并且该策略的特定实现（本地模型）在所有数据集上始终给出非常好的结果。<br>从某种意义上说，在实验中观察到的监督方法相对于从头方法的优越性不足为奇，因为监督方法使用了更多的信息。由于这些附加信息可在许多实际应用中使用，因此建议在许多情况下，受监督的方法可能比从头的方法更好。但是，应该指出的是，通过将约束或先验分布放在要推断的图上，可以将我们分类为从头的某些方法（例如贝叶斯网络）轻松地适应有监督的推理方案。另一方面，监督方法的强度主要取决于良好训练集的可用性，在某些情况下（例如推断较小图的结构），这可能是不可用的。<br>我们观察到没有唯一的方法将该问题转换为二进制分类问题，这表明需要进一步的研究来设计最佳适应的方法。特别是，在三个基准实验中效果最好的局部方法具有明显的局限性，例如无法推断出没有已知边的顶点的新边。新策略的开发使具有已知边缘的顶点的局部方法保持有效，但借鉴了例如第7.2.5节的全局模型中的一些思想，以便能够推断具有很少或未知的顶点的边缘因此，边缘化是一个有前途的研究方向。</p>
<p>8 从基因组数据和化学信息的集成来监督代谢网络<br>9 利用CF归纳法将生物学推断中的归纳法和归纳法相结合</p>
<p>10 确定性和鲁棒性布尔网络的分析与控制</p>
<p>11 概率方法和速率异质性<br>第四部分基因组学与计算系统生物学<br>12 从DNA主题到基因网络：回顾<br>13 相互作用模型<br>14 全基因组在系统生物学中筛选核受体结合位点的计算机模拟的影响。<br>微生物基因组序列对环境和生理的认识</p>
<p>第五部分用于系统生物学的软件工具</p>
<p>15 ALI BABA：系统生物学的文本挖掘工具</p>
<p>16 监管模块发现中的验证问题</p>
<p>17 系统生物学的计算成像与建模</p>
<p>17.1生物信息学/ 383<br>17.1.1基因芯片/ 383<br>17.1.2质谱/ 383<br>17.1.3分子网络与途径/ 384<br>17.2高内涵筛选的生物图像信息学/ 385<br>17.2.1图像预处理/ 386<br>17.2.2细胞检测，分割和中心线<br>提取/ 386<br>17.2.3小区跟踪和注册/ 388<br>17.2.4特征提取/ 388<br>17.3连接生物信息学和生物医学成像<br>17.3.1使用HCS进行蜂窝网络分析<br>17.3.2使用HCS进行基因功能注释<br>17.3.3与临床影像学的关联研究<br>特质/ 390<br>17.3.4体内基因组学分析<br>17.3.5体内蛋白质组学分析<br>17.3.6体内遗传分析/<br>17.3.7体内RNAi实验/<br>17.4摘要/ 394致谢/ 394参考/ 394</p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7-Trojan</title>
    <url>/2020/03/31/centos7-Troan/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载软件 并安装</span><br><span class="line">1. wget https://raw.githubusercontent.com/TheWanderingCoel/Trojan-Scripts/master/trojan.sh &amp;&amp; chmod +x trojan.sh &amp;&amp; ./trojan.sh</span><br><span class="line"># 关闭防火墙</span><br><span class="line">2. systemctl stop firewalld</span><br><span class="line">3. systemctl disable firewalld</span><br><span class="line"></span><br><span class="line"># 查看nginx状态</span><br><span class="line">systemctl status nginx</span><br><span class="line"># 安装ssh插件</span><br><span class="line">yum install certbot</span><br><span class="line"></span><br><span class="line">certbot certonly --email 920126806@qq.com -d jnymhpp.website -d *.jnymhpp.website --preferred-challenges dns --manual</span><br><span class="line">## 对应的域名解析添加TXT，输入terminal里面的key。等待一会按下enter</span><br><span class="line">成功以后需要把证书文件下载下来，移动到指定文件夹。输入下面两个bash</span><br><span class="line"></span><br><span class="line">mv /etc/letsencrypt/archive/jnymhpp.website/privkey1.pem /usr/local/etc/certfiles/private_key.pem</span><br></pre></td></tr></table></figure>

<p>———- V2Ray vmess URL / V2RayNG v0.4.1+ / V2RayN v2.1+ / 仅适合部分客户端 ————-</p>
<p>vmess://ewoidiI6ICIyIiwKInBzIjogIjIzM3YyLmNvbV85Mi4zOC4xMzAuMTQ4IiwKImFkZCI6ICI5Mi4zOC4xMzAuMTQ4IiwKInBvcnQiOiAiNTg0MDciLAoiaWQiOiAiODFhNmYzOTAtMzBiMC00MTIxLTg2YjAtYTU3MjM4ODIwZTU3IiwKImFpZCI6ICIyMzMiLAoibmV0IjogInRjcCIsCiJ0eXBlIjogIm5vbmUiLAoiaG9zdCI6ICIiLAoicGF0aCI6ICIiLAoidGxzIjogIiIKfQo=</p>
]]></content>
  </entry>
  <entry>
    <title>Padavan老毛子安装trojan</title>
    <url>/2020/03/28/%E8%80%81%E6%AF%9B%E5%AD%90%E5%AE%89%E8%A3%85trojan/</url>
    <content><![CDATA[<p>使用Trojan作为代理，主要三个步骤</p>
<ul>
<li>配置Trojan for padavan</li>
<li>配置config.josn</li>
<li>路由器客户端配置</li>
</ul>
<p>下面是详细的操作。</p>
<h1 id="1-下载trojan-for-Padavan"><a href="#1-下载trojan-for-Padavan" class="headerlink" title="1. 下载trojan for Padavan"></a>1. 下载trojan for Padavan</h1><p><a href="https://github.com/maskedeken/trojan-gfw/releases/download/1.15.1/trojan-1.15.1-linux-mipsel.tar.gz" target="_blank" rel="noopener">https://github.com/maskedeken/trojan-gfw/releases/download/1.15.1/trojan-1.15.1-linux-mipsel.tar.gz</a></p>
<h1 id="2-解压trojan-1-15-1-linux-mipsel-tar-gz"><a href="#2-解压trojan-1-15-1-linux-mipsel-tar-gz" class="headerlink" title="2. 解压trojan-1.15.1-linux-mipsel.tar.gz"></a>2. 解压trojan-1.15.1-linux-mipsel.tar.gz</h1><h1 id="3-创建config-json配置文件"><a href="#3-创建config-json配置文件" class="headerlink" title="3. 创建config.json配置文件"></a>3. 创建config.json配置文件</h1><p>客户中心 - 产品详情中的单个节点的Trojan配置内容保存为 config.json<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200328114608.png" alt></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"run_type"</span>: <span class="string">"client"</span>,</span><br><span class="line">	<span class="attr">"local_addr"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">	<span class="attr">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line">	<span class="attr">"remote_addr"</span>: <span class="string">"example.com"</span>,</span><br><span class="line">	<span class="attr">"remote_port"</span>: <span class="number">443</span>,</span><br><span class="line">	<span class="attr">"password"</span>: [<span class="string">"password"</span>],</span><br><span class="line">	<span class="attr">"log_level"</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">"ssl"</span>: &#123;</span><br><span class="line">		<span class="attr">"verify"</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">"verify_hostname"</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">"cert"</span>: <span class="string">""</span>,</span><br><span class="line">		<span class="attr">"cipher"</span>: <span class="string">"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:AES128-SHA:AES256-SHA:DES-CBC3-SHA"</span>,</span><br><span class="line">		<span class="attr">"cipher_tls13"</span>: <span class="string">"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384"</span>,</span><br><span class="line">		<span class="attr">"sni"</span>: <span class="string">""</span>,</span><br><span class="line">		<span class="attr">"alpn"</span>: [<span class="string">"h2"</span>, <span class="string">"http/1.1"</span>],</span><br><span class="line">		<span class="attr">"reuse_session"</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">"session_ticket"</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="attr">"curves"</span>: <span class="string">""</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"tcp"</span>: &#123;</span><br><span class="line">		<span class="attr">"no_delay"</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">"keep_alive"</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">"reuse_port"</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="attr">"fast_open"</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="attr">"fast_open_qlen"</span>: <span class="number">20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-打开路由器ssh连接"><a href="#4-打开路由器ssh连接" class="headerlink" title="4. 打开路由器ssh连接"></a>4. 打开路由器ssh连接</h1><p>高级设置-系统管理-服务-终端服务<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200328113539.png" alt></p>
<h1 id="5-上传程序和配置文件到路由器"><a href="#5-上传程序和配置文件到路由器" class="headerlink" title="5. 上传程序和配置文件到路由器"></a>5. 上传程序和配置文件到路由器</h1><p>Mac下打开terminal，执行下面两行命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp ./trojan-1.15/config.json admin@192.168.123.1:/etc/storage</span><br><span class="line">scp ./trojan-1.15/trojan admin@192.168.123.1:/etc/storage</span><br></pre></td></tr></table></figure>

<p>默认密码是admin</p>
<h1 id="6-启动程序"><a href="#6-启动程序" class="headerlink" title="6. 启动程序"></a>6. 启动程序</h1><p>进入路由器/etc/storage目录，执行三行下面指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 config.json</span><br><span class="line">chmod 777 trojan</span><br><span class="line">./trojan -c /etc/storage/config.json</span><br></pre></td></tr></table></figure>

<p>启动成功后关闭terminal</p>
<h1 id="7-路由器客户端配置"><a href="#7-路由器客户端配置" class="headerlink" title="7. 路由器客户端配置"></a>7. 路由器客户端配置</h1><p>扩展功能-广告屏蔽功能-transocks<br>参数设置如下图<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200328114913.png" alt></p>
<p>fm1-4.sstr-api.xyz</p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>pathway数据资源</title>
    <url>/2020/03/27/pathway%E6%95%B0%E6%8D%AE%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>Google 索引的在线资源中心</p>
<ul>
<li><a href="http://www.pathguide.org/" target="_blank" rel="noopener">http://www.pathguide.org/</a></li>
</ul>
<p>关于植物的网站有29个</p>
<ul>
<li><p><a href="http://www.plantcyc.org" target="_blank" rel="noopener">www.plantcyc.org</a></p>
<p>PlantCyc Organism: Triticum aestivum</p>
</li>
<li><p><a href="https://plantreactome.gramene.org/index.php?lang=en" target="_blank" rel="noopener">https://plantreactome.gramene.org/index.php?lang=en</a></p>
</li>
</ul>
<p> 18602316985—-cjvip5926</p>
<p> 复制这段内容后打开百度网盘手机App，操作更方便哦 链接：<a href="https://pan.baidu.com/s/1ZuDmS1X465r3fC9IEOR7ZA" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZuDmS1X465r3fC9IEOR7ZA</a> 提取码：26zm </p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>信号转导网络的生物信息学分析</title>
    <url>/2020/03/26/%E4%BF%A1%E5%8F%B7%E8%BD%AC%E5%AF%BC%E7%BD%91%E7%BB%9C%E7%9A%84%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>植物电信号-表型</title>
    <url>/2020/03/26/%E6%A4%8D%E7%89%A9%E7%94%B5%E4%BF%A1%E5%8F%B7-%E8%A1%A8%E5%9E%8B/</url>
    <content><![CDATA[<p>可以把植物电信号当成植物的表型数据进行处理和分析</p>
<p>表型和基因的关系如下图<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200326095941.png" alt></p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>国内pathway预测</title>
    <url>/2020/03/25/%E5%9B%BD%E5%86%85pathway%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<ul>
<li>2005年北京大学，魏丽萍</li>
<li>2006年清华大学，张毅</li>
<li>2009年中国科学院数学研究所，任献文</li>
</ul>
<p>在pathway方面有一篇文章，但是没有找到硕士文章，参考性较低。<br>国内找到的文章都是10年之前的，参考性很低。<br>重点放到国外</p>
<h1 id="北京大学-生物信息学老师研究方方向和网络分析有关的文章"><a href="#北京大学-生物信息学老师研究方方向和网络分析有关的文章" class="headerlink" title="北京大学-生物信息学老师研究方方向和网络分析有关的文章"></a>北京大学-生物信息学老师研究方方向和网络分析有关的文章</h1><ul>
<li><p>张泽民<br>F. Hwang, G. Atluri, R. Kuang, V. Humar, T. Starr, K.AT.Siverstein, P.M. Haverty, Z. Zhang, and J. Liu. (2013), Large-scale integrative network-based analysis identifies common pathways disrupted by copy number alterations across cancers”. BMC Genomics, 14:440</p>
</li>
<li><p>2009-2011年，吉林大学，周春光<a href="http://fund.sciencenet.cn/project/324417?mobile=1" target="_blank" rel="noopener">国家自然科学基金项目-pathway预测方法研究</a></p>
<ul>
<li>生物信息学中的pathway预测研究对于理解生命系统中的生物过程以及疾病早期诊断方面具有十分重要的意义。本项目通过pathway元素识别和pathway结构图的构建两个阶段来研究pathway预测方法，并将图方法、聚类分析和统计学习理论等机器学习方法引入到pathway预测研究中，通过提出新的模型和算法来实现pathway的自动识别。在pathway预测中使用紧聚类方法预测pathway，能够达到很好的容噪效果；基于HMM的信号转导pathway重构；基于PSO的信号pathway动力学模型预测。通过以上方法研究，促进了系统生物学的应用基础研究，从而加快pathway预测的实用化和商业化的研究进展。</li>
</ul>
</li>
<li><p>基于量子计算的基因网络功能模块挖掘及涌现机制研究 曹涌 西南林业大学</p>
</li>
<li><p>基于微生物相互作用的网络效应调控物种生长研究    肖延东 中国人民解放军国防科技大学</p>
</li>
<li><p><a href="http://fund.sciencenet.cn/project/324476" target="_blank" rel="noopener">从生物分子网络中挖掘功能模块和生物通路的模型与算法研究 章祥荪 中国科学院数学与系统科学研究院</a></p>
<ul>
<li>复杂网络特别是生物分子网络，是当前科学界的研究热点。从生物分子网络中挖掘重要信息（如功能模块和生物通路）是生物信息学和系统生物学中备受关注的核心问题。现有的理论和方法仍然存在重大不足，例如有向网络的处理、大规模网络的计算效率、对已知信息的利用等。本项目针对这些缺陷以及尚未探索的空白领域，运用运筹学中的最优化和图论方法，定义和识别生物分子网络中的局部结构特征，进而提取出有价值的生物信息。具体问题包括无向和有向网络模块划分定量评价，针对生物分子网络特别是有向代谢网络的有效划分算法，适合大规模网络比对（保守模块识别）的模型和算法，生物通路识别数学模型和算法，不完全信息下网络的信息挖掘等。本项目的研究将推动国内运筹学、生物信息学及计算机科学理论及算法的交叉研究，并形成一系列有广泛影响的具有自主知识产权的应用软件。</li>
</ul>
</li>
</ul>
<ul>
<li><a href="http://fund.sciencenet.cn/project/325273" target="_blank" rel="noopener">基于特征挖掘的生物网络构建算法研究 熊赟 复旦大学</a><ul>
<li>生物网络的构建与分析是系统生物学的重要内容，有助于从整体上理解生物学进程。第二代测序技术使得单个测序仪输出数据量可达40Gb每天，大数据对生物网络分析提出新挑战。生物网络研究的技术问题是生物学家对数据挖掘中新型技术的跟踪和掌握不够及时；而数据挖掘专家没有很好理解生物网络特点。这导致数据挖掘研究领域中的最新研究成果难以直接用于生物网络构建和分析中。因此，如何结合生物领域知识和需求，利用数据挖掘领域中的新技术更有效的研究生物网络是生物信息学中的重要研究内容之一。生物序列的特征对于构建生物网络具有重要影响，是构建生物网络的关键，然而，由于目前生物序列中已知功能元件数量较少以及基因表达数据质量难以保证，导致序列间关联关系的识别和预测准确性不高，因此，影响生物网络构建的准确性。本项目围绕这一重要问题开展了研究，深入分析了生物序列数据的特点，结合现有的数据挖掘技术，研究并设计了生物序列特征挖掘算法，包括基于序列模式的保守功能元件挖掘算法、基于多数据域描述的非保守功能元件挖掘算法、功能元件组合挖掘算法、基因表达数据的特征挖掘算法。在此基础上，研究基于不同语义路径的异质生物网络模型和构建方法，所构建的生物网络具有语义相关性。这些研究成果为生物网络分析研究提供了基础。本项目工作进展顺利，完成了项目要求的各项指标。下一步的研究将在生物网络深层次挖掘方面，包括异质生物网络的关键模块挖掘、基于生物网络的药物和疾病挖掘研究等。</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="https://doi.org/10.1016/j.ebiom.2019.05.010" target="_blank" rel="noopener">基于串扰分析的基于路径的生物标志物鉴定可在肝细胞癌中进行可靠的预后预测</a></p>
<ul>
<li>用到TCGA的数据库，找到差异表达基因，然后富集分析。</li>
</ul>
</li>
<li><p><a href="http://www.ebiotrade.com/emagazine/content/1/2014_4_36_4/8F34CD30-7074-48F7-8754-E1260621FBAE/pdf/387.pdf" target="_blank" rel="noopener">基于蛋白质互作知识的生物学通路扩充新方法</a></p>
<ul>
<li>基因富集分析 KEGG</li>
</ul>
</li>
</ul>
<h1 id="国外研究"><a href="#国外研究" class="headerlink" title="国外研究"></a>国外研究</h1><p>主要看计算机专业的</p>
<p><a href="https://www.biorxiv.org/content/10.1101/176230v1.full" target="_blank" rel="noopener">网络推断揭示了调节酵母盐反应中生长和防御的途径中的新颖联系</a><br>这篇文章有生物学实验，参考性比较低。</p>
<p><a href="http://structuralbiology.cau.edu.cn/PlantGSEA/index.php" target="_blank" rel="noopener">中国农业大学研制的植物生物的基因组富集分析在线websever</a></p>
<ul>
<li><p>找到一个实验室，长期做生物网络分析相关研究</p>
</li>
<li><p>在bioinformatics杂志官网寻找关键词：Graph, pathway</p>
<ul>
<li><p><a href="https://academic.oup.com/bioinformatics/article/35/5/815/5068595?searchresult=1" target="_blank" rel="noopener">基因相互作用网络中的信息熵</a><br>动机<br>现代生物学实验通常会产生可能与研究表型有关的基因候选列表。有人会问，在现有知识的背景下，整个基因清单是否有意义：清单中的基因彼此之间是否合理相关，或者它们看起来像是随机装配？在某些情况下，人们想知道两个或多个基因集是否密切相关。如果我们假设只有两个基因实际上是相同的，它们才是相关的，那么基于计数两组共有基因的基因富集测试就足够了。如果说“相关”是指在交互网络空间中连接良好，则需要一种新的基因集相关性度量。<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200325154400.png" alt></p>
</li>
<li><p><a href="https://academic.oup.com/bioinformatics/article/29/24/3181/194696?searchresult=1" target="_blank" rel="noopener">QSSPN：分子相互作用网络的动态模拟，描述人类细胞中的基因调控，信号传导和全细胞代谢</a></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>物理学-卷三</title>
    <url>/2020/03/21/%E7%89%A9%E7%90%86%E5%AD%A6-%E5%8D%B7%E4%B8%89/</url>
    <content><![CDATA[<p><a href="http://img.sslibrary.com/n/slib/book/slib/10233474/231bd39e52554369b2e9aa76a2f4625c/2b7fdea111fe6c34eb747a2f64883b5e.shtml?dxbaoku=false&amp;deptid=178&amp;fav=http%3A%2F%2Fwww.sslibrary.com%2Freader%2Fpdg%2Fpdgreader%3Fd%3D4396c7ed06b023a3ba4242f5416bdb0a%26ssid%3D10233474&amp;fenlei=1303&amp;spage=1&amp;t=5&amp;username=114.251.216.45&amp;view=-1" target="_blank" rel="noopener">http://img.sslibrary.com/n/slib/book/slib/10233474/231bd39e52554369b2e9aa76a2f4625c/2b7fdea111fe6c34eb747a2f64883b5e.shtml?dxbaoku=false&amp;deptid=178&amp;fav=http%3A%2F%2Fwww.sslibrary.com%2Freader%2Fpdg%2Fpdgreader%3Fd%3D4396c7ed06b023a3ba4242f5416bdb0a%26ssid%3D10233474&amp;fenlei=1303&amp;spage=1&amp;t=5&amp;username=114.251.216.45&amp;view=-1</a></p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>再次理解HH-H</title>
    <url>/2020/03/19/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3HH-H/</url>
    <content><![CDATA[<p><a href="https://www.st-andrews.ac.uk/~wjh/hh_model_intro/#k" target="_blank" rel="noopener">h-h外国人笔记</a></p>
<p><a href="https://www.st-andrews.ac.uk/~wjh/neurosim/index.html" title="HH" target="_blank" rel="noopener">H-H 仿真软件</a><br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200319092721.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%===simulation time===</span><br><span class="line">simulationTime = 100; %in milliseconds</span><br><span class="line">deltaT=.01;</span><br><span class="line">t=0:deltaT:simulationTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%===specify the external current I===</span><br><span class="line">changeTimes = [0]; %in milliseconds</span><br><span class="line">currentLevels = [50]; %Change this to see effect of different currents on voltage (Suggested values: 3, 20, 50, 1000)</span><br><span class="line"></span><br><span class="line">%Set externally applied current across time</span><br><span class="line">%Here, first 500 timesteps are at current of 50, next 1500 timesteps at</span><br><span class="line">%current of zero (resets resting potential of neuron), and the rest of</span><br><span class="line">%timesteps are at constant current</span><br><span class="line">I(1:500) = currentLevels; I(501:2000) = 0; I(2001:numel(t)) = currentLevels;</span><br><span class="line">%Comment out the above line and uncomment the line below for constant current, and observe effects on voltage timecourse</span><br><span class="line">%I(1:numel(t)) = currentLevels;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%===constant parameters===%</span><br><span class="line">%All of these can be found in Table 3</span><br><span class="line">gbar_K=36; gbar_Na=120; g_L=.3;</span><br><span class="line">E_K = -12; E_Na=115; E_L=10.6;</span><br><span class="line">C=1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%===set the initial states===%</span><br><span class="line">V=0; %Baseline voltage</span><br><span class="line">alpha_n = .01 * ( (10-V) / (exp((10-V)/10)-1) ); %Equation 12</span><br><span class="line">beta_n = .125*exp(-V/80); %Equation 13</span><br><span class="line">alpha_m = .1*( (25-V) / (exp((25-V)/10)-1) ); %Equation 20</span><br><span class="line">beta_m = 4*exp(-V/18); %Equation 21</span><br><span class="line">alpha_h = .07*exp(-V/20); %Equation 23</span><br><span class="line">beta_h = 1/(exp((30-V)/10)+1); %Equation 24</span><br><span class="line"></span><br><span class="line">n(1) = alpha_n/(alpha_n+beta_n); %Equation 9</span><br><span class="line">m(1) = alpha_m/(alpha_m+beta_m); %Equation 18</span><br><span class="line">h(1) = alpha_h/(alpha_h+beta_h); %Equation 18</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i=1:numel(t)-1 %Compute coefficients, currents, and derivates at each time step</span><br><span class="line">   </span><br><span class="line">    %---calculate the coefficients---%</span><br><span class="line">    %Equations here are same as above, just calculating at each time step</span><br><span class="line">    alpha_n(i) = .01 * ( (10-V(i)) / (exp((10-V(i))/10)-1) );</span><br><span class="line">    beta_n(i) = .125*exp(-V(i)/80);</span><br><span class="line">    alpha_m(i) = .1*( (25-V(i)) / (exp((25-V(i))/10)-1) );</span><br><span class="line">    beta_m(i) = 4*exp(-V(i)/18);</span><br><span class="line">    alpha_h(i) = .07*exp(-V(i)/20);</span><br><span class="line">    beta_h(i) = 1/(exp((30-V(i))/10)+1);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    %---calculate the currents---%</span><br><span class="line">    I_Na = (m(i)^3) * gbar_Na * h(i) * (V(i)-E_Na); %Equations 3 and 14</span><br><span class="line">    I_K = (n(i)^4) * gbar_K * (V(i)-E_K); %Equations 4 and 6</span><br><span class="line">    I_L = g_L *(V(i)-E_L); %Equation 5</span><br><span class="line">    I_ion = I(i) - I_K - I_Na - I_L;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    %---calculate the derivatives using Euler first order approximation---%</span><br><span class="line">    V(i+1) = V(i) + deltaT*I_ion/C;</span><br><span class="line">    n(i+1) = n(i) + deltaT*(alpha_n(i) *(1-n(i)) - beta_n(i) * n(i)); %Equation 7</span><br><span class="line">    m(i+1) = m(i) + deltaT*(alpha_m(i) *(1-m(i)) - beta_m(i) * m(i)); %Equation 15</span><br><span class="line">    h(i+1) = h(i) + deltaT*(alpha_h(i) *(1-h(i)) - beta_h(i) * h(i)); %Equation 16</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">V = V-70; %Set resting potential to -70mv</span><br><span class="line"></span><br><span class="line">%===plot Voltage===%</span><br><span class="line">plot(t,V,&apos;LineWidth&apos;,3)</span><br><span class="line">hold on</span><br><span class="line">legend(&#123;&apos;voltage&apos;&#125;)</span><br><span class="line">ylabel(&apos;Voltage (mv)&apos;)</span><br><span class="line">xlabel(&apos;time (ms)&apos;)</span><br><span class="line">title(&apos;Voltage over Time in Simulated Neuron&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%===plot Conductance===%</span><br><span class="line">figure</span><br><span class="line">p1 = plot(t,gbar_K*n.^4,&apos;LineWidth&apos;,2);</span><br><span class="line">hold on</span><br><span class="line">p2 = plot(t,gbar_Na*(m.^3).*h,&apos;r&apos;,&apos;LineWidth&apos;,2);</span><br><span class="line">legend([p1, p2], &apos;Conductance for Potassium&apos;, &apos;Conductance for Sodium&apos;)</span><br><span class="line">ylabel(&apos;Conductance&apos;)</span><br><span class="line">xlabel(&apos;time (ms)&apos;)</span><br><span class="line">title(&apos;Conductance for Potassium and Sodium Ions in Simulated Neuron&apos;)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>离子流和通道电流</title>
    <url>/2020/03/18/%E7%A6%BB%E5%AD%90%E6%B5%81%E5%92%8C%E9%80%9A%E9%81%93%E7%94%B5%E6%B5%81/</url>
    <content><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<p>/* # youtube Ask<br>Thanks！May I ask you a question? How Converting ion flux into ion current？My mail address is <a href="mailto:squarefaceyao@gmail.com" target="_blank" rel="noopener">squarefaceyao@gmail.com</a></p>
<p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200318223246.png" alt></p>
<h1 id="ion-flux-和-ion-flow-不是同一个意思，量纲单位不一致。"><a href="#ion-flux-和-ion-flow-不是同一个意思，量纲单位不一致。" class="headerlink" title="ion flux 和 ion flow  不是同一个意思，量纲单位不一致。"></a>ion flux 和 ion flow  不是同一个意思，量纲单位不一致。</h1><p>离子流ion flux  与通道电流还是有关系的</p>
<p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200320104055.png" alt></p>
<h1 id="Fick-First-law"><a href="#Fick-First-law" class="headerlink" title="Fick First law"></a>Fick First law</h1><p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200320105000.png" alt></p>
<h1 id="离子通量和通过膜的电流之间的关系"><a href="#离子通量和通过膜的电流之间的关系" class="headerlink" title="离子通量和通过膜的电流之间的关系"></a>离子通量和通过膜的电流之间的关系</h1><h2 id="1-Cellular-Physiology-and-Neurophysiology-by-Mordecai-P-Blaustein-Joseph-P-Y-Kao-Donald-R-Matteson"><a href="#1-Cellular-Physiology-and-Neurophysiology-by-Mordecai-P-Blaustein-Joseph-P-Y-Kao-Donald-R-Matteson" class="headerlink" title="1. Cellular Physiology and Neurophysiology by Mordecai P. Blaustein, Joseph P. Y. Kao, Donald R. Matteson"></a>1. Cellular Physiology and Neurophysiology by Mordecai P. Blaustein, Joseph P. Y. Kao, Donald R. Matteson</h2><p>这本神经科学的书中有涉及到<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200323150140.png" alt></p>
<p>综上所示，用通量J讨论了离子通过膜的运动，通量J是每单位时间通过膜单位面积移动的离子的摩尔数。为了方便在细胞电的讨论，使用流过膜的电流（表示为I）而不是离子通量的概念。这两个概念是等效的，并且以简单的方式关联。电流是单位时间内电荷的运动。将通量转换为电流需要弄清楚离子的摩尔数与它们携带的电荷量之间的关系。如果每个离子具有z个电荷，则每摩尔离子有z摩尔电荷。此外，要将摩尔单位转换为电子单位，我们需要使用法拉第常数F=96485 C/mol。  </p>
<p>离子通量和通过膜的电流之间的关系为：</p>
<p>I=ZF\times J\times A_{mem}</p>
<p>其中A_{mem}是发生通量/电流的膜面积。通量和电流这两个数量可以通过转换因子直接关联，可以认为是不同单位中的相同数量。<br>不同的符号约定用于描述细胞生理学中的通量和电流。 在通量理论中，将任何种类的“粒子”（即正离子，负离子或中性分子）流入电池的流量定义为正流量，而将正电荷从电池中流出的流量定义为正流量 电气理论中的最新知识。 表B-1总结了物理上可能出现的四种情况</p>
<h2 id="物理学-电磁部分（邝-译）"><a href="#物理学-电磁部分（邝-译）" class="headerlink" title="物理学-电磁部分（邝 译）"></a>物理学-电磁部分（邝 译）</h2><ul>
<li>311页提到电流和扩散通量的关系，如下图<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200323151029.png" alt></li>
</ul>
<p>这里提到的是扩散通量，和MIFE计算的离子流速到的是一样的吗？</p>
<p>那么扩散通量是如何计算的呢？用到Fick First Law,在253页<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200323152617.png" alt></p>
<p>薛琳师姐论文40有页介绍离子流速计算公式，也用到Fick定律<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200323152015.png" alt></p>
<ul>
<li>从计算公式上看出来，离子流速=扩散通量。那么电流</li>
<li>需要注意净通量，在254页提到净通量，是扩散通量和外力作用通量之和。这里也要区分净通量和离子流速的区别<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200323151405.png" alt></li>
</ul>
]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>AP通用动力学模型</title>
    <url>/2020/03/17/AP%E9%80%9A%E7%94%A8%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Communication-and-Information-Theory-of-Single-Action-Potential-Signals-in-Plants"><a href="#Communication-and-Information-Theory-of-Single-Action-Potential-Signals-in-Plants" class="headerlink" title="Communication and Information Theory of Single Action Potential Signals in Plants"></a>Communication and Information Theory of Single Action Potential Signals in Plants</h1><p>这篇文章提出分子通信的概念，可以把分子看作是一种信息或一种信息的载体，采用扩散和主动传输的方法进行通信。</p>
<p><strong>作者在文中声明，以下研究假设AP信号是单个细胞发出的。并且只考虑细胞间通信，</strong></p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>通过与没有AP信号的情况进行比较，研究AP信号对发射区域的互作用和传播速度的影响，并探索AP的传播范围</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>model for the generation of single action potential signals in a plant cell.</li>
<li>基于扩散分子通信概念，研究AP信号和输出分子数量的关系</li>
<li>计算传播速度</li>
</ol>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>甲壳虫网络分析</title>
    <url>/2020/03/15/%E7%94%B2%E5%A3%B3%E8%99%AB%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200315150413.png" alt></p>
<p>查找文献绘制甲壳动物免疫系统网络，在转换成图的时候没有使用算法</p>
]]></content>
  </entry>
  <entry>
    <title>老毛子配置</title>
    <url>/2020/03/14/%E8%80%81%E6%AF%9B%E5%AD%90%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>华硕路由器官方固件</p>
<p>把网线插到wan口。主要是对ipv6进行配置。<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200314211958.png" alt><br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200314212020.png" alt></p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>盐胁迫pathway</title>
    <url>/2020/03/13/%E7%9B%90%E8%83%81%E8%BF%ABpathway/</url>
    <content><![CDATA[<h1 id="KEGG里面和盐胁迫相关Pathway信息"><a href="#KEGG里面和盐胁迫相关Pathway信息" class="headerlink" title="KEGG里面和盐胁迫相关Pathway信息"></a>KEGG里面和盐胁迫相关Pathway信息</h1><p><a href="https://www.genome.jp/kegg-bin/show_pathway?map=ath04016&amp;show_description=show" target="_blank" rel="noopener">https://www.genome.jp/kegg-bin/show_pathway?map=ath04016&amp;show_description=show</a></p>
<h1 id="关于盐胁迫的信号转导通路"><a href="#关于盐胁迫的信号转导通路" class="headerlink" title="关于盐胁迫的信号转导通路"></a>关于盐胁迫的信号转导通路</h1><p><a href="http://expath.itps.ncku.edu.tw/microarray/pathway/rice/pathway_result.php" target="_blank" rel="noopener">MAPK信号转导</a></p>
<h1 id="小麦耐盐机制的总结与展望—《The-Crop-Journal》special-issue"><a href="#小麦耐盐机制的总结与展望—《The-Crop-Journal》special-issue" class="headerlink" title="小麦耐盐机制的总结与展望—《The Crop Journal》special issue"></a>小麦耐盐机制的总结与展望—《The Crop Journal》special issue</h1><p><a href="https://mp.weixin.qq.com/s/IWYBwnBuvcOY58qcOaXo1A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IWYBwnBuvcOY58qcOaXo1A</a><br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200315160736.png" alt></p>
<p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200317100205.png" alt><br>Fig. 7. The suggested model depicting ionic mechanisms contributing to K+ retention in leaf mesophyll in barley. Upon NaCl exposure, the plasma membrane is depolarized by the massive entry of external Na+ via non-selective cation channel (NSCC) and results in K+ loss mediated by depolarization-activated K+ outward rectifying channel (KOR) channels. Cytosolic K+ homeostasis is disrupted. The accompanied production of ROS has detrimental effects of leaf photochemistry in chloroplasts and, in severe cases, could trigger PCD or lead to necrosis. ROS also activate NSCC exacerbating K+ loss from cytosol. Compared with salt sensitive genotypes, higher vacuolar K+ pool in the leaf mesophyll in salt tolerant barley genotypes allows plants to maintain cytosolic K+ homeostasis by releasing vacuolar K+ into cytosol; this process is mediated by tonoplast K+- permeable channels (TPK in the model). It is also suggested that tolerant varieties may have higher Na+/H+ NHX exchanger activity and, thus, can replace vacuolar K+ by Na+ to maintain its osmotic pressure in vacuole. As K+ uptake by AKT1 into leaf mesophyll is inhibited by the membrane depolarization, plants should rely on high affinity K+ uptake to restore cytosolic K+ homeostasis (a HAK/KUP family K+/H+ co-transporter in the model). A concurrent K+ and H+ uptake through HAK/KUP exchanger results in a +2 net charge transfer and may further depolarise the plasma+ membrane, resulting in a futile cycle of K . This process is partially compensated by higher ATPase- driven H+-pumping activity in sensitive varieties.</p>
<p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200317100513.png" alt></p>
<h1 id="信号转导分析在植物"><a href="#信号转导分析在植物" class="headerlink" title="信号转导分析在植物"></a>信号转导分析在植物</h1><ul>
<li><a href="10.1109/PMA.2012.6524828">Identifying rice arsenic stress response pathways based on molecular interaction network(基于分子相互作用网络识别水稻砷胁迫响应途径)</a></li>
</ul>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习最新历史</title>
    <url>/2020/03/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%80%E6%96%B0%E5%8E%86%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200312224907.png" alt></p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>致谢</title>
    <url>/2020/03/12/%E8%87%B4%E8%B0%A2/</url>
    <content><![CDATA[<p>时光荏苒，岁月如梭，一转眼间就到了毕业时刻，即将为研究生三年的学习生涯 画上句号。细细回想，本科四年，研究生三年，我在西电留下了七年的回忆。离校日 期已日趋渐进，纵观研究生的学业时光，所有的成长一直都离不开老师、同学、父母 给予的热情帮助，在这里请接受我诚挚的谢意!  </p>
<p>首先，感谢我的导师高琳教授。从研究生刚一入学，您就帮助我树立了实事求是 的学习态度和严谨的科研作风。从您的言传身教中，我领会到了阅读文献的关键，从 事科学研究的方法，更重要的是为人处世的道理。另外，您对学术敏锐的洞察力和渊 博的专业知识，常能立足于高处给予我宏观上的指导，时常令我耳目一新，柳暗花明。 在这里，向高琳教授致以由衷的感谢!  </p>
<p>其次，感谢实验室所有的师兄师弟师姐师妹们，尤其是感谢同一届的王宏达、李 玉峰、兰小明、夏明飞、张晨星、龚倩华、周丹丹。在科研学习中，通过与你们对各 自研究领域的探究和讨论，使我对自己研究的问题也有了更清晰的认知，另外也开阔 了我的视野甚至在自己研究卡壳的时候，给我􏰀供了一定的思路和方向。其次，在科 研之外的生活中，无论是出去聚餐还是平时的嬉闹，更添加了几分欢乐色彩，使我的 研究生生涯更加丰富多彩。感谢你们的陪伴。<br>然后，感谢我的父母家人，在漫长的人生旅途中，使我心灵有了虔敬的归依，让 我没有任何后顾之忧地更专注于学习。你们的支持和鼓励，尤其是来自女朋友徐小丹 (现妻子)的理解和关怀，是我不断学习，继续成长的原动力。在未来的日子里，我 会更加努力的学习和工作，不辜负你们对我的殷殷期望!  </p>
<p>最后，向百忙之中参与审阅、评议本论文并􏰀出指导性意见的各位专家和老师表 示由衷的感谢!</p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>综述思路</title>
    <url>/2020/03/11/%E7%BB%BC%E8%BF%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h1><p>按照主题进行分类，需要和植物进行一些关联。</p>
<p>黄老师发了很多关于因果关系的文章，但都是和真实的数据有关系，（类似基因共表达网络，）现在的pathway分析是没办法使用的。在写综述的时候可以不考虑这些，先把内容写进去，</p>
<h2 id="阅读5篇相关博士论文，确定网络分析应用的领域"><a href="#阅读5篇相关博士论文，确定网络分析应用的领域" class="headerlink" title="阅读5篇相关博士论文，确定网络分析应用的领域"></a>阅读5篇相关博士论文，确定网络分析应用的领域</h2><ul>
<li><p>基因调控网络<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200312154828.png" alt></p>
<ul>
<li>共表达的方法（WGCNA）</li>
<li>基于监督学习的方法</li>
<li>基于图论的方法</li>
<li>基于信息论的方法</li>
</ul>
</li>
<li><p>Pathway网络（化学反应网络）</p>
<ul>
<li><p>Pathway下分为好几种，这里需要进行分类描述<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200311221005.png" alt></p>
<ul>
<li>代谢网络  <ul>
<li>代谢网络拓扑结构预测及功能预测</li>
<li>多物种亲缘关系分析（代谢网络与系统发生分析）</li>
<li>代谢网络的功能与进化性</li>
</ul>
</li>
<li>信号转导</li>
</ul>
</li>
<li><p>结合图论</p>
</li>
<li><p>pathway的重构<br>— 这里面涉及到的算法，选择性的提及。这里面好像没有和图论相关的知识点，</p>
</li>
<li><p>吉林大学关于Pathway预测的文章</p>
</li>
</ul>
</li>
<li><p>蛋白质相互作用</p>
<ul>
<li>预测</li>
<li>模体识别</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh-插件</title>
    <url>/2020/03/11/zsh-%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="目的：在Terminal-可以显示git的分支"><a href="#目的：在Terminal-可以显示git的分支" class="headerlink" title="目的：在Terminal 可以显示git的分支"></a>目的：在Terminal 可以显示git的分支</h1><p>需要对zsh进行主题配置。参考下面的连接</p>
<p><a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh</a></p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>植物细胞网络思考</title>
    <url>/2020/03/10/%E6%A4%8D%E7%89%A9%E7%BB%86%E8%83%9E%E7%BD%91%E7%BB%9C%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="对比BP"><a href="#对比BP" class="headerlink" title="对比BP"></a>对比BP</h1><p>y = wx + b</p>
<p>w 代表轴突，神经元连接的线。</p>
<p>这里的b 好像是没有的。</p>
<h1 id="植物网络用的是细胞类型表示每一个神经元，这里面的数值可以考虑成输入的数据会好理解一点，没必要计算出来每个细胞的数值，主要是连接的线用什么来表示，原文提出的是表示的胞间连丝。胞间连丝的电导（g）可以理解为w"><a href="#植物网络用的是细胞类型表示每一个神经元，这里面的数值可以考虑成输入的数据会好理解一点，没必要计算出来每个细胞的数值，主要是连接的线用什么来表示，原文提出的是表示的胞间连丝。胞间连丝的电导（g）可以理解为w" class="headerlink" title="植物网络用的是细胞类型表示每一个神经元，这里面的数值可以考虑成输入的数据会好理解一点，没必要计算出来每个细胞的数值，主要是连接的线用什么来表示，原文提出的是表示的胞间连丝。胞间连丝的电导（g）可以理解为w"></a>植物网络用的是细胞类型表示每一个神经元，这里面的数值可以考虑成输入的数据会好理解一点，没必要计算出来每个细胞的数值，主要是连接的线用什么来表示，原文提出的是表示的胞间连丝。胞间连丝的电导（g）可以理解为w</h1>]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现BP</title>
    <url>/2020/03/09/python%E5%AE%9E%E7%8E%B0BP/</url>
    <content><![CDATA[<h1 id="单个神经元的组成"><a href="#单个神经元的组成" class="headerlink" title="单个神经元的组成"></a>单个神经元的组成</h1><p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200309104629.png" alt></p>
<p>如上图所示为一个典型的神经元结构，输入端为n个输入Xn，对应n个权重Wn,以及一个阈值b，将这些值进行线性组合WX+b就可以得到神经元的输入值，我们姑且称作α，然后再将这个输入值α传入神经元后半部分进行非线性处理（激活处理），神经网络之所以可以非线性的拟合原因就在其每个神经元都会经过一个非线性的步骤，这里使用的<strong>激活函数</strong>有很多种</p>
<h2 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h2><h2 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h2><h2 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h2><p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200309105034.png" alt></p>
<h2 id="Sigmoid函数-1"><a href="#Sigmoid函数-1" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h2>]]></content>
      <tags>
        <tag>MC</tag>
      </tags>
  </entry>
  <entry>
    <title>多分类模型评价准则整理</title>
    <url>/2020/03/08/%E5%A4%9A%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7%E5%87%86%E5%88%99%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="Kappa系数"><a href="#Kappa系数" class="headerlink" title="Kappa系数"></a>Kappa系数</h2><p>Kappa系数是基于混淆矩阵的计算得到的模型评价参数。计算公式如下：<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200308205715.png" alt></p>
<p>系数的值在-1到1之间，系数小于0的话实际上就相当于随机了。<br>python实现为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> cohen_kappa_score</span><br><span class="line">kappa = cohen_kappa_score(y_true,y_pred，label=<span class="literal">None</span>) <span class="comment">#(label除非是你想计算其中的分类子集的kappa系数，否则不需要设置)</span></span><br></pre></td></tr></table></figure>

<h2 id="海明距离"><a href="#海明距离" class="headerlink" title="海明距离"></a>海明距离</h2><p>海明距离也适用于多分类的问题，简单来说就是衡量预测标签与真实标签之间的距离，取值在0~1之间。距离为0说明预测结果与真实结果完全相同，距离为1就说明模型与我们想要的结果完全就是背道而驰。公式就不贴了（0*0 原谅我太懒），直接来python实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> hamming_loss</span><br><span class="line">ham_distance = hamming_loss(y_true,y_pred)</span><br></pre></td></tr></table></figure>

<h2 id="杰卡德相似系数"><a href="#杰卡德相似系数" class="headerlink" title="杰卡德相似系数"></a>杰卡德相似系数</h2><p>它与海明距离的不同之处在于分母。当预测结果与实际情况完全相符时，系数为1；当预测结果与实际情况完全不符时，系数为0；当预测结果是实际情况的真子集或真超集时，距离介于0到1之间。<br>我们可以通过对所有样本的预测情况求平均得到算法在测试集上的总体表现情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> jaccard_similarity_score</span><br><span class="line">jaccrd_score = jaccrd_similarity_score(y_true,y_pred,normalize = default)</span><br><span class="line"><span class="comment">#normalize默认为true，这是计算的是多个类别的相似系数的平均值，normalize = false时分别计算各个类别的相似系数</span></span><br></pre></td></tr></table></figure>

<h2 id="铰链损失"><a href="#铰链损失" class="headerlink" title="铰链损失"></a>铰链损失</h2><p>铰链损失（Hinge loss）一般用来使“边缘最大化”（maximal margin）。损失取值在0~1之间，当取值为0，表示多分类模型分类完全准确，取值为1表明完全不起作用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> hinge_loss</span><br><span class="line">hinger = hinger_loss(y_true,y_pred)</span><br></pre></td></tr></table></figure>

<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">'Consumer_Complaints.csv'</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df[pd.notnull(df[<span class="string">'Consumer complaint narrative'</span>])]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure>

<pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;
Int64Index: 4569 entries, 1 to 21662
Data columns (total 18 columns):
Date received                   4569 non-null object
Product                         4569 non-null object
Sub-product                     3106 non-null object
Issue                           4569 non-null object
Sub-issue                       2294 non-null object
Consumer complaint narrative    4569 non-null object
Company public response         2220 non-null object
Company                         4569 non-null object
State                           4556 non-null object
ZIP code                        4556 non-null object
Tags                            770 non-null object
Consumer consent provided?      4569 non-null object
Submitted via                   4569 non-null object
Date sent to company            4569 non-null object
Company response to consumer    4569 non-null object
Timely response?                4569 non-null object
Consumer disputed?              4568 non-null object
Complaint ID                    4569 non-null float64
dtypes: float64(1), object(17)
memory usage: 678.2+ KB</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col = [<span class="string">'Product'</span>, <span class="string">'Consumer complaint narrative'</span>]</span><br><span class="line">df = df[col]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.columns</span><br></pre></td></tr></table></figure>

<pre><code>Index([&apos;Product&apos;, &apos;Consumer complaint narrative&apos;], dtype=&apos;object&apos;)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.columns = [<span class="string">'Product'</span>, <span class="string">'Consumer_complaint_narrative'</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">'category_id'</span>] = df[<span class="string">'Product'</span>].factorize()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">category_id_df = df[[<span class="string">'Product'</span>, <span class="string">'category_id'</span>]].drop_duplicates().sort_values(<span class="string">'category_id'</span>)</span><br><span class="line">category_to_id = dict(category_id_df.values)</span><br><span class="line">id_to_category = dict(category_id_df[[<span class="string">'category_id'</span>, <span class="string">'Product'</span>]].values)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

<pre><code>.dataframe thead th {
    text-align: left;
}

.dataframe tbody tr th {
    vertical-align: top;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Product</th>
      <th>Consumer_complaint_narrative</th>
      <th>category_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>Credit reporting</td>
      <td>I have outdated information on my credit repor...</td>
      <td>0</td>
    </tr>

  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">df.groupby(<span class="string">'Product'</span>).Consumer_complaint_narrative.count().plot.bar(ylim=<span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="output_8_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line">tfidf = TfidfVectorizer(sublinear_tf=<span class="literal">True</span>, min_df=<span class="number">5</span>, norm=<span class="string">'l2'</span>, encoding=<span class="string">'latin-1'</span>, ngram_range=(<span class="number">1</span>, <span class="number">2</span>), stop_words=<span class="string">'english'</span>)</span><br><span class="line"></span><br><span class="line">features = tfidf.fit_transform(df.Consumer_complaint_narrative).toarray()</span><br><span class="line">labels = df.category_id</span><br><span class="line">features.shape</span><br></pre></td></tr></table></figure>

<pre><code>(4569, 12633)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">N = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> Product, category_id <span class="keyword">in</span> sorted(category_to_id.items()):</span><br><span class="line">  features_chi2 = chi2(features, labels == category_id)</span><br><span class="line">  indices = np.argsort(features_chi2[<span class="number">0</span>])</span><br><span class="line">  feature_names = np.array(tfidf.get_feature_names())[indices]</span><br><span class="line">  unigrams = [v <span class="keyword">for</span> v <span class="keyword">in</span> feature_names <span class="keyword">if</span> len(v.split(<span class="string">' '</span>)) == <span class="number">1</span>]</span><br><span class="line">  bigrams = [v <span class="keyword">for</span> v <span class="keyword">in</span> feature_names <span class="keyword">if</span> len(v.split(<span class="string">' '</span>)) == <span class="number">2</span>]</span><br><span class="line">  print(<span class="string">"# '&#123;&#125;':"</span>.format(Product))</span><br><span class="line">  print(<span class="string">"  . Most correlated unigrams:\n       . &#123;&#125;"</span>.format(<span class="string">'\n       . '</span>.join(unigrams[-N:])))</span><br><span class="line">  print(<span class="string">"  . Most correlated bigrams:\n       . &#123;&#125;"</span>.format(<span class="string">'\n       . '</span>.join(bigrams[-N:])))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(df[<span class="string">'Consumer_complaint_narrative'</span>], df[<span class="string">'Product'</span>], random_state = <span class="number">0</span>)</span><br><span class="line">count_vect = CountVectorizer()</span><br><span class="line">X_train_counts = count_vect.fit_transform(X_train)</span><br><span class="line">tfidf_transformer = TfidfTransformer()</span><br><span class="line">X_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)</span><br><span class="line"></span><br><span class="line">clf = MultinomialNB().fit(X_train_tfidf, y_train)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(clf.predict(count_vect.transform([<span class="string">"This company refuses to provide me verification and validation of debt per my right under the FDCPA. I do not believe this debt is mine."</span>])))</span><br></pre></td></tr></table></figure>

<pre><code>[&apos;Debt collection&apos;]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(clf.predict(count_vect.transform([<span class="string">"I am disputing the inaccurate information the Chex-Systems has on my credit report. I initially submitted a police report on XXXX/XXXX/16 and Chex Systems only deleted the items that I mentioned in the letter and not all the items that were actually listed on the police report. In other words they wanted me to say word for word to them what items were fraudulent. The total disregard of the police report and what accounts that it states that are fraudulent. If they just had paid a little closer attention to the police report I would not been in this position now and they would n't have to research once again. I would like the reported information to be removed : XXXX XXXX XXXX"</span>])))</span><br></pre></td></tr></table></figure>

<pre><code>[&apos;Credit reporting&apos;]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">'Consumer_complaint_narrative'</span>] == <span class="string">"This company refuses to provide me verification and validation of debt per my right under the FDCPA. I do not believe this debt is mine."</span>]</span><br></pre></td></tr></table></figure>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

<pre><code>.dataframe thead th {
    text-align: left;
}

.dataframe tbody tr th {
    vertical-align: top;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Product</th>
      <th>Consumer_complaint_narrative</th>
      <th>category_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>12</th>
      <td>Debt collection</td>
      <td>This company refuses to provide me verificatio...</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">'Consumer_complaint_narrative'</span>] == <span class="string">"I am disputing the inaccurate information the Chex-Systems has on my credit report. I initially submitted a police report on XXXX/XXXX/16 and Chex Systems only deleted the items that I mentioned in the letter and not all the items that were actually listed on the police report. In other words they wanted me to say word for word to them what items were fraudulent. The total disregard of the police report and what accounts that it states that are fraudulent. If they just had paid a little closer attention to the police report I would not been in this position now and they would n't have to research once again. I would like the reported information to be removed : XXXX XXXX XXXX"</span>]</span><br></pre></td></tr></table></figure>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

<pre><code>.dataframe thead th {
    text-align: left;
}

.dataframe tbody tr th {
    vertical-align: top;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Product</th>
      <th>Consumer_complaint_narrative</th>
      <th>category_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>61</th>
      <td>Credit reporting</td>
      <td>I am disputing the inaccurate information the ...</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">models = [</span><br><span class="line">    RandomForestClassifier(n_estimators=<span class="number">200</span>, max_depth=<span class="number">3</span>, random_state=<span class="number">0</span>),</span><br><span class="line">    LinearSVC(),</span><br><span class="line">    MultinomialNB(),</span><br><span class="line">    LogisticRegression(random_state=<span class="number">0</span>),</span><br><span class="line">]</span><br><span class="line">CV = <span class="number">5</span></span><br><span class="line">cv_df = pd.DataFrame(index=range(CV * len(models)))</span><br><span class="line">entries = []</span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> models:</span><br><span class="line">  model_name = model.__class__.__name__</span><br><span class="line">  accuracies = cross_val_score(model, features, labels, scoring=<span class="string">'accuracy'</span>, cv=CV)</span><br><span class="line">  <span class="keyword">for</span> fold_idx, accuracy <span class="keyword">in</span> enumerate(accuracies):</span><br><span class="line">    entries.append((model_name, fold_idx, accuracy))</span><br><span class="line">cv_df = pd.DataFrame(entries, columns=[<span class="string">'model_name'</span>, <span class="string">'fold_idx'</span>, <span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.boxplot(x=<span class="string">'model_name'</span>, y=<span class="string">'accuracy'</span>, data=cv_df)</span><br><span class="line">sns.stripplot(x=<span class="string">'model_name'</span>, y=<span class="string">'accuracy'</span>, data=cv_df, </span><br><span class="line">              size=<span class="number">8</span>, jitter=<span class="literal">True</span>, edgecolor=<span class="string">"gray"</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="output_17_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv_df.groupby(<span class="string">'model_name'</span>).accuracy.mean()</span><br></pre></td></tr></table></figure>

<pre><code>model_name
LinearSVC                 0.822890
LogisticRegression        0.792927
MultinomialNB             0.688519
RandomForestClassifier    0.443826
Name: accuracy, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">model = LinearSVC()</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test, indices_train, indices_test = train_test_split(features, labels, df.index, test_size=<span class="number">0.33</span>, random_state=<span class="number">0</span>)</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line">y_pred = model.predict(X_test)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"></span><br><span class="line">conf_mat = confusion_matrix(y_test, y_pred)</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">sns.heatmap(conf_mat, annot=<span class="literal">True</span>, fmt=<span class="string">'d'</span>,</span><br><span class="line">            xticklabels=category_id_df.Product.values, yticklabels=category_id_df.Product.values)</span><br><span class="line">plt.ylabel(<span class="string">'Actual'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Predicted'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="output_20_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> predicted <span class="keyword">in</span> category_id_df.category_id:</span><br><span class="line">  <span class="keyword">for</span> actual <span class="keyword">in</span> category_id_df.category_id:</span><br><span class="line">    <span class="keyword">if</span> predicted != actual <span class="keyword">and</span> conf_mat[actual, predicted] &gt;= <span class="number">6</span>:</span><br><span class="line">      print(<span class="string">"'&#123;&#125;' predicted as '&#123;&#125;' : &#123;&#125; examples."</span>.format(id_to_category[actual], id_to_category[predicted], conf_mat[actual, predicted]))</span><br><span class="line">      display(df.loc[indices_test[(y_test == actual) &amp; (y_pred == predicted)]][[<span class="string">'Product'</span>, <span class="string">'Consumer_complaint_narrative'</span>]])</span><br><span class="line">      print(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<pre><code>&apos;Consumer Loan&apos; predicted as &apos;Credit reporting&apos; : 10 examples.</code></pre><div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

<pre><code>.dataframe thead th {
    text-align: left;
}

.dataframe tbody tr th {
    vertical-align: top;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Product</th>
      <th>Consumer_complaint_narrative</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2720</th>
      <td>Consumer Loan</td>
      <td>Quoting them, your first loan application, the...</td>
    </tr>
    <tr>
      <th>7091</th>
      <td>Consumer Loan</td>
      <td>While reviewing my XXXX credit report, I notic...</td>
    </tr>
    <tr>
      <th>5439</th>
      <td>Consumer Loan</td>
      <td>I have been recently checking my credit report...</td>
    </tr>
    <tr>
      <th>12763</th>
      <td>Consumer Loan</td>
      <td>We went to buy XXXX cars, and the dealership s...</td>
    </tr>
    <tr>
      <th>13158</th>
      <td>Consumer Loan</td>
      <td>I got a 30 day late XX/XX/2017 and it 's repor...</td>
    </tr>
    <tr>
      <th>4134</th>
      <td>Consumer Loan</td>
      <td>I took out an instalment loan in the amount XX...</td>
    </tr>
    <tr>
      <th>13848</th>
      <td>Consumer Loan</td>
      <td>I was turned down for a loan by Honda Finacial...</td>
    </tr>
    <tr>
      <th>19227</th>
      <td>Consumer Loan</td>
      <td>ONEMAIN # XXXX XXXX , IN XXXX ( XXXX ) XXXX Da...</td>
    </tr>
    <tr>
      <th>11258</th>
      <td>Consumer Loan</td>
      <td>I have not been given credit for the payments ...</td>
    </tr>
    <tr>
      <th>11242</th>
      <td>Consumer Loan</td>
      <td>Reliable Credit falsely submitted an applicati...</td>
    </tr>
  </tbody>
</table>
</div>



<pre><code>&apos;Debt collection&apos; predicted as &apos;Credit reporting&apos; : 18 examples.</code></pre><div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

<pre><code>.dataframe thead th {
    text-align: left;
}

.dataframe tbody tr th {
    vertical-align: top;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Product</th>
      <th>Consumer_complaint_narrative</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>18410</th>
      <td>Debt collection</td>
      <td>Dear CFPB, I am asking you for assistance to i...</td>
    </tr>
    <tr>
      <th>5262</th>
      <td>Debt collection</td>
      <td>XXXX XXXX, XXXX ( This letter describes in det...</td>
    </tr>
    <tr>
      <th>11834</th>
      <td>Debt collection</td>
      <td>XXXX XXXX XXXX is reporting negatively on my c...</td>
    </tr>
    <tr>
      <th>19652</th>
      <td>Debt collection</td>
      <td>I recently paid of both debts on my credit acc...</td>
    </tr>
    <tr>
      <th>15557</th>
      <td>Debt collection</td>
      <td>Never have been a XXXX XXXX customer. I was at...</td>
    </tr>
    <tr>
      <th>4431</th>
      <td>Debt collection</td>
      <td>someone tried getting credit information and i...</td>
    </tr>
    <tr>
      <th>15949</th>
      <td>Debt collection</td>
      <td>This debt is from account from $ XX/XX/2008 an...</td>
    </tr>
    <tr>
      <th>12475</th>
      <td>Debt collection</td>
      <td>In XXXX XXXX, there was an account opened thro...</td>
    </tr>
    <tr>
      <th>13548</th>
      <td>Debt collection</td>
      <td>DIVERSIFIELD CONSULTANTS INC HAVE VIOLATED FCR...</td>
    </tr>
    <tr>
      <th>6988</th>
      <td>Debt collection</td>
      <td>Also collections refuses to stop reporting to ...</td>
    </tr>
    <tr>
      <th>16498</th>
      <td>Debt collection</td>
      <td>They called my son and told him that they are ...</td>
    </tr>
    <tr>
      <th>12028</th>
      <td>Debt collection</td>
      <td>Rubin &amp; Rothman LLC ( R &amp; R ) received default...</td>
    </tr>
    <tr>
      <th>7131</th>
      <td>Debt collection</td>
      <td>THIS IS FRAUD. I HAVE REQUESTED VERIFICATION A...</td>
    </tr>
    <tr>
      <th>15630</th>
      <td>Debt collection</td>
      <td>Barclays Bank Delaware obtained a judgment aga...</td>
    </tr>
    <tr>
      <th>11112</th>
      <td>Debt collection</td>
      <td>This account was a joint account with XXXX and...</td>
    </tr>
    <tr>
      <th>16</th>
      <td>Debt collection</td>
      <td>This complaint is in regards to Square Two Fin...</td>
    </tr>
    <tr>
      <th>311</th>
      <td>Debt collection</td>
      <td>Hunter Warfield has be unable to provide prope...</td>
    </tr>
    <tr>
      <th>15988</th>
      <td>Debt collection</td>
      <td>Unknown account, never have been notified and ...</td>
    </tr>
  </tbody>
</table>
</div>



<pre><code>&apos;Mortgage&apos; predicted as &apos;Credit reporting&apos; : 6 examples.</code></pre><div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

<pre><code>.dataframe thead th {
    text-align: left;
}

.dataframe tbody tr th {
    vertical-align: top;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Product</th>
      <th>Consumer_complaint_narrative</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4637</th>
      <td>Mortgage</td>
      <td>This complaint is in follow-up to Complaint # ...</td>
    </tr>
    <tr>
      <th>5269</th>
      <td>Mortgage</td>
      <td>The attached complaint was initially written t...</td>
    </tr>
    <tr>
      <th>7343</th>
      <td>Mortgage</td>
      <td>In 2014, I went to XXXX in order to buy a mobi...</td>
    </tr>
    <tr>
      <th>15048</th>
      <td>Mortgage</td>
      <td>Company repeatedly corrects my credit report a...</td>
    </tr>
    <tr>
      <th>861</th>
      <td>Mortgage</td>
      <td>Mortgage broker did Credit inquiry on my credi...</td>
    </tr>
    <tr>
      <th>19781</th>
      <td>Mortgage</td>
      <td>I am a card carrying XXXX and wanted to see if...</td>
    </tr>
  </tbody>
</table>
</div>



<pre><code>&apos;Credit card&apos; predicted as &apos;Credit reporting&apos; : 9 examples.</code></pre><div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

<pre><code>.dataframe thead th {
    text-align: left;
}

.dataframe tbody tr th {
    vertical-align: top;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Product</th>
      <th>Consumer_complaint_narrative</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>18643</th>
      <td>Credit card</td>
      <td>I was told this account wiuld be deleted from ...</td>
    </tr>
    <tr>
      <th>18574</th>
      <td>Credit card</td>
      <td>This inquiry was n't me</td>
    </tr>
    <tr>
      <th>19868</th>
      <td>Credit card</td>
      <td>Capital One/Kohls has been reporting a past du...</td>
    </tr>
    <tr>
      <th>19963</th>
      <td>Credit card</td>
      <td>on XX/XX/XXXX my wallet was stolen with all my...</td>
    </tr>
    <tr>
      <th>4706</th>
      <td>Credit card</td>
      <td>American Express is reporting an account on my...</td>
    </tr>
    <tr>
      <th>21566</th>
      <td>Credit card</td>
      <td>Have disputed the reporting of the status of a...</td>
    </tr>
    <tr>
      <th>13906</th>
      <td>Credit card</td>
      <td>I have been the victim of identity theft fraud...</td>
    </tr>
    <tr>
      <th>16853</th>
      <td>Credit card</td>
      <td>I have requested XXXX XXXX to run a credit rep...</td>
    </tr>
    <tr>
      <th>10505</th>
      <td>Credit card</td>
      <td>I have been working since XXXX 2016 to get a i...</td>
    </tr>
  </tbody>
</table>
</div>






<pre><code>---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-22-9932ab8bdc5b&gt; in &lt;module&gt;()
      3 for predicted in category_id_df.category_id:
      4   for actual in category_id_df.category_id:
----&gt; 5     if predicted != actual and conf_mat[actual, predicted] &gt;= 6:
      6       print(&quot;&apos;{}&apos; predicted as &apos;{}&apos; : {} examples.&quot;.format(id_to_category[actual], id_to_category[predicted], conf_mat[actual, predicted]))
      7       display(df.loc[indices_test[(y_test == actual) &amp; (y_pred == predicted)]][[&apos;Product&apos;, &apos;Consumer_complaint_narrative&apos;]])


IndexError: index 11 is out of bounds for axis 0 with size 11</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.fit(features, labels)</span><br></pre></td></tr></table></figure>

<pre><code>LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,
     intercept_scaling=1, loss=&apos;squared_hinge&apos;, max_iter=1000,
     multi_class=&apos;ovr&apos;, penalty=&apos;l2&apos;, random_state=None, tol=0.0001,
     verbose=0)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"></span><br><span class="line">N = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> Product, category_id <span class="keyword">in</span> sorted(category_to_id.items()):</span><br><span class="line">  indices = np.argsort(model.coef_[category_id])</span><br><span class="line">  feature_names = np.array(tfidf.get_feature_names())[indices]</span><br><span class="line">  unigrams = [v <span class="keyword">for</span> v <span class="keyword">in</span> reversed(feature_names) <span class="keyword">if</span> len(v.split(<span class="string">' '</span>)) == <span class="number">1</span>][:N]</span><br><span class="line">  bigrams = [v <span class="keyword">for</span> v <span class="keyword">in</span> reversed(feature_names) <span class="keyword">if</span> len(v.split(<span class="string">' '</span>)) == <span class="number">2</span>][:N]</span><br><span class="line">  print(<span class="string">"# '&#123;&#125;':"</span>.format(Product))</span><br><span class="line">  print(<span class="string">"  . Top unigrams:\n       . &#123;&#125;"</span>.format(<span class="string">'\n       . '</span>.join(unigrams)))</span><br><span class="line">  print(<span class="string">"  . Top bigrams:\n       . &#123;&#125;"</span>.format(<span class="string">'\n       . '</span>.join(bigrams)))</span><br></pre></td></tr></table></figure>

<pre><code># &apos;Bank account or service&apos;:
  . Top unigrams:
       . bank
       . account
  . Top bigrams:
       . debit card
       . overdraft fees
# &apos;Consumer Loan&apos;:
  . Top unigrams:
       . vehicle
       . car
  . Top bigrams:
       . personal loan
       . history xxxx
# &apos;Credit card&apos;:
  . Top unigrams:
       . card
       . discover
  . Top bigrams:
       . credit card
       . discover card
# &apos;Credit reporting&apos;:
  . Top unigrams:
       . equifax
       . transunion
  . Top bigrams:
       . xxxx account
       . trans union
# &apos;Debt collection&apos;:
  . Top unigrams:
       . debt
       . collection
  . Top bigrams:
       . account credit
       . time provided
# &apos;Money transfers&apos;:
  . Top unigrams:
       . paypal
       . transfer
  . Top bigrams:
       . money transfer
       . send money
# &apos;Mortgage&apos;:
  . Top unigrams:
       . mortgage
       . escrow
  . Top bigrams:
       . loan modification
       . mortgage company
# &apos;Other financial service&apos;:
  . Top unigrams:
       . passport
       . dental
  . Top bigrams:
       . stated pay
       . help pay
# &apos;Payday loan&apos;:
  . Top unigrams:
       . payday
       . loan
  . Top bigrams:
       . payday loan
       . pay day
# &apos;Prepaid card&apos;:
  . Top unigrams:
       . prepaid
       . serve
  . Top bigrams:
       . prepaid card
       . use card
# &apos;Student loan&apos;:
  . Top unigrams:
       . navient
       . loans
  . Top bigrams:
       . student loan
       . sallie mae
# &apos;Virtual currency&apos;:
  . Top unigrams:
       . https
       . tx
  . Top bigrams:
       . money want
       . xxxx provider</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">texts = [<span class="string">"I requested a home loan modification through Bank of America. Bank of America never got back to me."</span>,</span><br><span class="line">         <span class="string">"It has been difficult for me to find my past due balance. I missed a regular monthly payment"</span>,</span><br><span class="line">         <span class="string">"I can't get the money out of the country."</span>,</span><br><span class="line">         <span class="string">"I have no money to pay my tuition"</span>,</span><br><span class="line">         <span class="string">"Coinbase closed my account for no reason and furthermore refused to give me a reason despite dozens of request"</span>]</span><br><span class="line">text_features = tfidf.transform(texts)</span><br><span class="line">predictions = model.predict(text_features)</span><br><span class="line"><span class="keyword">for</span> text, predicted <span class="keyword">in</span> zip(texts, predictions):</span><br><span class="line">  print(<span class="string">'"&#123;&#125;"'</span>.format(text))</span><br><span class="line">  print(<span class="string">"  - Predicted as: '&#123;&#125;'"</span>.format(id_to_category[predicted]))</span><br><span class="line">  print(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>

<pre><code>&quot;I requested a home loan modification through Bank of America. Bank of America never got back to me.&quot;
  - Predicted as: &apos;Mortgage&apos;

&quot;It has been difficult for me to find my past due balance. I missed a regular monthly payment&quot;
  - Predicted as: &apos;Credit reporting&apos;

&quot;I can&apos;t get the money out of the country.&quot;
  - Predicted as: &apos;Bank account or service&apos;

&quot;I have no money to pay my tuition&quot;
  - Predicted as: &apos;Debt collection&apos;

&quot;Coinbase closed my account for no reason and furthermore refused to give me a reason despite dozens of request&quot;
  - Predicted as: &apos;Bank account or service&apos;</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">print(metrics.classification_report(y_test, y_pred, </span><br><span class="line">                                    target_names=df[<span class="string">'Product'</span>].unique()))</span><br></pre></td></tr></table></figure>

<pre><code>                         precision    recall  f1-score   support

       Credit reporting       0.82      0.82      0.82       288
          Consumer Loan       0.83      0.60      0.70       100
        Debt collection       0.80      0.91      0.85       359
               Mortgage       0.90      0.93      0.92       317
            Credit card       0.73      0.77      0.75       165
Other financial service       0.00      0.00      0.00         1
Bank account or service       0.74      0.74      0.74       121
           Student loan       0.92      0.83      0.87       111
        Money transfers       0.50      0.23      0.32        13
            Payday loan       0.75      0.38      0.50        16
           Prepaid card       0.67      0.12      0.20        17

            avg / total       0.82      0.82      0.81      1508



/home/ec2-user/anaconda3/envs/python3/lib/python3.6/site-packages/sklearn/metrics/classification.py:1428: UserWarning: labels size, 11, does not match size of target_names, 12
  .format(len(labels), len(target_names))
/home/ec2-user/anaconda3/envs/python3/lib/python3.6/site-packages/sklearn/metrics/classification.py:1135: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples.
  &apos;precision&apos;, &apos;predicted&apos;, average, warn_for)</code></pre>]]></content>
      <tags>
        <tag>MC</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas的factorize()理解</title>
    <url>/2020/03/07/pandas%E7%9A%84factorize-%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>pandas的factorize()理解<br>官网说明<br>pandas.factorize(values, sort=False, order=None, na_sentinel=-1, size_hint=None)<br>Encode input values as an enumerated type or categorical variable</p>
<p>个人理解<br>factorize函数可以将Series中的标称型数据映射称为一组数字，相同的标称型映射为相同的数字。factorize函数的返回值是一个tuple（元组），元组中包含两个元素。第一个元素是一个array，其中的元素是标称型元素映射为的数字；第二个元素是Index类型，其中的元素是所有标称型元素，没有重复。</p>
<p>实例</p>
<pre><code class="python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">import</span> pandas <span class="keyword">as</span> pd
In [<span class="number">43</span>]: df = pd.DataFrame({<span class="string">"id"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>], <span class="string">"raw_grade"</span>:[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>,
    ...:  <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'e'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>]})

In [<span class="number">44</span>]: df
Out[<span class="number">44</span>]:
   id raw_grade
<span class="number">0</span>   <span class="number">1</span>         a
<span class="number">1</span>   <span class="number">2</span>         b
<span class="number">2</span>   <span class="number">3</span>         b
<span class="number">3</span>   <span class="number">4</span>         a
<span class="number">4</span>   <span class="number">5</span>         a
<span class="number">5</span>   <span class="number">6</span>         e
<span class="number">6</span>   <span class="number">3</span>         c
<span class="number">7</span>   <span class="number">2</span>         a

In [<span class="number">45</span>]: x = pd.factorize(df.raw_grade)

In [<span class="number">46</span>]: x
Out[<span class="number">46</span>]:
(array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>], dtype=int64),
 Index([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'c'</span>], dtype=<span class="string">'object'</span>))
<span class="comment">#array中的元素其实是df.raw_grade的对应位置元素在Index中的下标。例如array第一个元素是0，表示df.raw_grade的第一个元素为Index的第0个元素。</span>

In [<span class="number">47</span>]: x[<span class="number">1</span>]
Out[<span class="number">47</span>]: Index([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'c'</span>], dtype=<span class="string">'object'</span>)

In [<span class="number">48</span>]: x[<span class="number">0</span>]
Out[<span class="number">48</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>], dtype=int64)

In [<span class="number">49</span>]: type(x)
Out[<span class="number">49</span>]: tuple</code></pre>
]]></content>
      <tags>
        <tag>MC</tag>
      </tags>
  </entry>
  <entry>
    <title>磁共振启发</title>
    <url>/2020/03/06/%E7%A3%81%E5%85%B1%E6%8C%AF%E5%90%AF%E5%8F%91/</url>
    <content><![CDATA[<p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200306154656.png" alt></p>
<h2 id="如何可以获得每个节点的数据？"><a href="#如何可以获得每个节点的数据？" class="headerlink" title="如何可以获得每个节点的数据？"></a>如何可以获得每个节点的数据？</h2><ul>
<li>如果把植物的一个器官（大一点的组织）堪称一个结点，</li>
</ul>
<p>存在的问题：</p>
<ul>
<li>区域划分的含义是什么？划分的结点有什么含义？这样也许可以证明信号的传递方向</li>
<li>每一个结点的信号值如何计算呢？如果是建模的话，如何验证呢？</li>
<li>把结点放大到植物的组织器官</li>
</ul>
]]></content>
      <tags>
        <tag>不成熟的想法</tag>
      </tags>
  </entry>
  <entry>
    <title>抑郁症-磁共振</title>
    <url>/2020/03/05/%E6%8A%91%E9%83%81%E7%97%87-%E7%A3%81%E5%85%B1%E6%8C%AF/</url>
    <content><![CDATA[<h1 id="基于功能连接和有效连接的抑郁症诊断方法研究"><a href="#基于功能连接和有效连接的抑郁症诊断方法研究" class="headerlink" title="基于功能连接和有效连接的抑郁症诊断方法研究"></a>基于功能连接和有效连接的抑郁症诊断方法研究</h1><h2 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h2><p>然抑郁症和健康被试有 如此多的结构和功能上的改变，我们只要能够找到其中某种稳定的改变足以区分 出抑郁症患者和健康被试，就可以把这种改变作为诊断抑郁症的标志</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><ul>
<li><p>重度抑郁症患者与健康被试相比，存在特定脑部区域结构上的改变。<br>这些有结构方面改变的脑区包括:额叶区域，前扣带皮层，眶额叶皮质，海马体和尾状核的一部分。<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200305223003.png" alt></p>
</li>
<li><p>脑区之间固有的功能连接的改变也在许多研究中被发现</p>
</li>
</ul>
<h2 id="脑功能网络也在抑郁症的病理原因方面扮演了重要的角色"><a href="#脑功能网络也在抑郁症的病理原因方面扮演了重要的角色" class="headerlink" title="脑功能网络也在抑郁症的病理原因方面扮演了重要的角色"></a>脑功能网络也在抑郁症的病理原因方面扮演了重要的角色</h2><h3 id="默认网络，额顶网络，注意网络，凸显网络"><a href="#默认网络，额顶网络，注意网络，凸显网络" class="headerlink" title="默认网络，额顶网络，注意网络，凸显网络"></a><strong>默认网络，额顶网络，注意网络，凸显网络</strong></h3><ul>
<li><p>Bin Zhang 等人发现抑郁症患者在特定的任务 条件下，默认网络会有一个显著的反激活现象。默认网络是一种在休息状态激活 而在任务状态不激活的一种特殊的网络，它被认为和人类的注意力，情绪等密切 相关。</p>
</li>
<li><p>默认网络主要由四个主要的脑区组成，内侧前额叶皮层(MPFC),后扣 带回皮质(PCC), 左外侧顶叶(LP_L)和右外侧顶叶(LP_R)。</p>
</li>
<li><p>背侧注意网络主要包 括左额叶区域(FEF_L)，右额叶区域(FEF_R)，左内沟区域(IPS_L)和右内沟区域 (IPS_R)。Fabio Sambataro 等人在与健康被试的对比分析中，发现了抑郁症患者 在背侧注意网络的异常改变[10]。</p>
</li>
<li><p>凸显网络主要由前扣带皮层(ACC), 左额前额皮 质(RPFC_L)和右额前额皮质(RPFC_R)组成，在抑郁症相关的任务态核磁成像研 究中，该网络显示出了明显的低频振荡(LFO)增强现象[11]。额顶网络主要由左侧 前额叶皮层(LPFC_L), 右侧前额叶皮层(LPFC_R), 左后壁皮层(PPC_L)和右后壁 皮层(PPC_R)组成。Aneta Brzezicka 发现，前额叶和顶叶区之间无效信息传播可能是重度抑郁症形成的主要原因[12]。</p>
</li>
</ul>
<h2 id="功能连接"><a href="#功能连接" class="headerlink" title="功能连接"></a><strong>功能连接</strong></h2><p>功能连接是空间上不相邻的脑区在静息状态下或者在外界的刺激下反应的 时间相关性。如果两个脑区对某个刺激反应的时间相关性比较大，这两个脑区的 功能连接就比较强。度量相关性可以多种方法，最常用的是皮尔逊相关系数。</p>
<ul>
<li>脑区划分，因为功能连接度量的是脑区之间的相关性，如何划分脑区会对最终的相关性结果产生影响。AAL 模版(Automated Anatomical Labeling)、(Brainnetome)模版对脑区进行划分。</li>
</ul>
<h2 id="有效连接"><a href="#有效连接" class="headerlink" title="有效连接"></a><strong>有效连接</strong></h2><p>有效连接是一种在神经元水平上为脑区间信号响应进行因果建模的方法， 能够比较详细的分析出连接的改变。利用有效连接衡量这几个静息态脑网络的改 变可能比单纯使用功能连接更有效。DonaldR等人利用有效连接探索了重度抑郁症患者杏仁核和前扣带皮层的连接，发现与健康被试相比，有明显的异常。<br><strong>功能连接和有效连接的异常性改变可能能够作为一种稳定的诊断标志</strong></p>
<h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><h3 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a><strong>时间序列</strong></h3><p>一般，仪器2s就可以对大脑进行一遍核磁共振扫描，得到一张3维图，即3维数据。如果每2s扫一次，扫多次，就可以得到随时间变化的一系列3维脑图，即再加一维时间维，为4维数据。对于大脑的某一个结点（固定前3维），可以得到一个时间序列（时间维变化）</p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Python表示图</title>
    <url>/2020/03/05/Python%E8%A1%A8%E7%A4%BA%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="Adjacency-Matrix"><a href="#Adjacency-Matrix" class="headerlink" title="Adjacency Matrix"></a>Adjacency Matrix</h1><h1 id="Adjacency-List"><a href="#Adjacency-List" class="headerlink" title="Adjacency List"></a>Adjacency List</h1><p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200305105945.png" alt></p>
]]></content>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>图论算法在生物网络数据上的应用</title>
    <url>/2020/03/03/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E5%9C%A8%E7%94%9F%E7%89%A9%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>文章分为两个部分：</p>
<ol>
<li>在必需蛋白预测研究中，考虑了蛋白所在的生物网络环境，以蛋白之间的连接关系重要程度来间接预测必需蛋白。除了主流的边聚类系数等图论特征，还利用了几何模型整合多种连接关系度量，有效减小了单一特征依赖问题。</li>
<li>在活跃信号通路识别问题中，引入 KEGG 知识库参与 背景网络构建过程，之后应用图论中的路径模型识别生物体在受到刺激后产生的 应激反应信号通路，该方法保留了分子所属通路信息，使结果更具解释性，方便 生物医学研究人员提出机理性假设。</li>
</ol>
<p>IEW算法：<a href="http://digbio.missouri.edu/IEW/index.html" target="_blank" rel="noopener">http://digbio.missouri.edu/IEW/index.html</a></p>
<h2 id="信号通路识别（多分子析协同作用机理方面）"><a href="#信号通路识别（多分子析协同作用机理方面）" class="headerlink" title="信号通路识别（多分子析协同作用机理方面）"></a>信号通路识别（多分子析协同作用机理方面）</h2><p><a href="http://digbio.missouri.edu/impres" target="_blank" rel="noopener">http://digbio.missouri.edu/impres</a><br>活跃信号通路识别算法</p>
<p>算法利用动态规划的思想，针对代谢通路。</p>
<ol>
<li>首先,利用 KEGG 数据库中对<strong>代谢通路</strong>的知识来构建背景网络。设计“类-实例”关系来扩展KEGG数据库中分子代谢通路，以获得基因参与的具体通路信息，</li>
<li>其次,基于组学数据为生物网络中的分子、分子连接和代谢 通路分配罚分，来逐步探索最优信号通路。</li>
<li>最后，从一个或多个起始基因开始，应用图论中的最短路径模型 识别下游信号通路，使其能最好地解释组学数据中分子的表达值。</li>
</ol>
<h3 id="活跃通路识别的目标"><a href="#活跃通路识别的目标" class="headerlink" title="活跃通路识别的目标"></a>活跃通路识别的目标</h3><p>在生物体受到外界刺激或自身基因组位点突变后，找到生物网络中哪些部位活跃起来并做出了相应反应。  </p>
<ul>
<li>合理地解释分子之间的级联反应顺序，即识别活跃信号通路</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>第一张提到哪些算法？在活跃信号通路识别领域</li>
<li>图论中路径模型，都有那些算法，思想要了解，实现最简单的一个算法。文中提到最短路径，基于“节约生物系统”假设：生物会选择高效的路径完胜生物功能。</li>
<li>网络节点的最小参与代价，这个是如何计算的？</li>
</ul>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>GO数据库</title>
    <url>/2020/03/03/GO%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="GO数据库"><a href="#GO数据库" class="headerlink" title="GO数据库"></a>GO数据库</h2><p>这里面的概念和KEGG分析概念完全一致，只不过数据库是不一样，</p>
<p>简单来说，不统一的基因描述</p>
<p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200303100930.png" alt><br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200303101049.png" alt><br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200303101157.png" alt><br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200303101326.png" alt></p>
<h2 id="Go富集原理"><a href="#Go富集原理" class="headerlink" title="Go富集原理"></a>Go富集原理</h2><p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200303102124.png" alt></p>
<p>富集因子<br>显著性</p>
<h2 id="AgriGo-分析平台"><a href="#AgriGo-分析平台" class="headerlink" title="AgriGo 分析平台"></a>AgriGo 分析平台</h2><p>目前使用不上，需要用的时候再来看。</p>
<p> <img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200303103116.png" alt></p>
]]></content>
  </entry>
  <entry>
    <title>超几何分布检验</title>
    <url>/2020/03/03/%E8%B6%85%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="为什么需要超级几何分布检验"><a href="#为什么需要超级几何分布检验" class="headerlink" title="为什么需要超级几何分布检验"></a>为什么需要超级几何分布检验</h1><p>检验一组基因（差异表达基因）在某个功能类的显著性（p Value或q Value）</p>
<p>p值越小，说明富集效果越好</p>
]]></content>
  </entry>
  <entry>
    <title>youtube-dl使用</title>
    <url>/2020/03/02/youtube-dl%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h1><ul>
<li>youtube-dl –proxy “127.0.0.1:1087” “<a href="https://www.youtube.com/watch?v=hZ1OgQL9_Cw&quot;" target="_blank" rel="noopener">https://www.youtube.com/watch?v=hZ1OgQL9_Cw&quot;</a></li>
</ul>
<h1 id="下载全部格式"><a href="#下载全部格式" class="headerlink" title="下载全部格式"></a>下载全部格式</h1><p> youtube-dl  –all-formats <a href="https://www.youtube.com/watch?v=hLQl3WQQoQ0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=hLQl3WQQoQ0</a><br> –all-formats ： 添加这个参数之后，所有存在的格式一扫而尽，统统下载；</p>
<h1 id="查看该视频所有格式类型，只看不下载-F或者–list-formats"><a href="#查看该视频所有格式类型，只看不下载-F或者–list-formats" class="headerlink" title="查看该视频所有格式类型，只看不下载 -F或者–list-formats"></a>查看该视频所有格式类型，只看不下载 -F或者–list-formats</h1><p> –list-formats ： 这是一个列清单参数，执行后并不会下载视频，但能知道这个目标视频都有哪些格式存在，这样就可以有选择的下载啦！</p>
<p> youtube-dl –list-formats <a href="https://www.youtube.com/watch?v=hLQl3WQQoQ0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=hLQl3WQQoQ0</a></p>
<h1 id="下载指定格式视频"><a href="#下载指定格式视频" class="headerlink" title="下载指定格式视频"></a>下载指定格式视频</h1><p> -f + 编号：通过上一步获取到了所有视频格式的清单，最左边一列就是编号对应着不同的格式，例如我想下载22号那个mp4格式分辨率为1280*720的视频，则按下面的命令就可以轻松指定下载视频哦；</p>
<p> youtube-dl -f 22 <a href="http://www.youtube.com/watch?v=BlXaGWbFVKY" target="_blank" rel="noopener">http://www.youtube.com/watch?v=BlXaGWbFVKY</a></p>
<h1 id="下载youtube字幕及视频"><a href="#下载youtube字幕及视频" class="headerlink" title="下载youtube字幕及视频"></a>下载youtube字幕及视频</h1><p> 有的youtube视频是有字幕的可供下载的，但不是全部；如果过你想要下载字幕用这个脚本来操作也是很容易的；先来说说两个参数–write-sub：加入字幕文件 –all-subs：如果有字幕存在则全部下载</p>
<p> youtube-dl –write-sub –all-subs <a href="https://www.youtube.com/watch?v=0TjgZbVdOLA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=0TjgZbVdOLA</a></p>
<h1 id="读取下载链接列表文件"><a href="#读取下载链接列表文件" class="headerlink" title="读取下载链接列表文件"></a>读取下载链接列表文件</h1><p> youtube-dl -a video_url.txt<br> 这里的 -a 参数表示读取外部链接文件,video_url.txt为包含视频地址的txt文件，一个地址 。</p>
<h1 id="直接下载最高清版本"><a href="#直接下载最高清版本" class="headerlink" title="直接下载最高清版本"></a>直接下载最高清版本</h1><p>  如果你不想查看版本，直接下载最高清的版本，也可以直接用下面的命令</p>
<p> youtube-dl -f bestvideo+bestaudio <a href="https://www.youtube.com/watch?v=0TjgZbVdOLA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=0TjgZbVdOLA</a></p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>KEGG富集分析原理</title>
    <url>/2020/03/02/KEGG%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="富集分析概念"><a href="#富集分析概念" class="headerlink" title="富集分析概念"></a>富集分析概念</h2><ul>
<li>基因功能注释： 通过基因的CDS或氨基酸序列与数据库（Nr）做系列比对，找出在数据库中与其最相似的，提取其功能注释信息作为该基因的功能注释</li>
<li>常 </li>
</ul>
<p>用户登录名称 <a href="mailto:yjp@1858447101409070.onaliyun.com" target="_blank" rel="noopener">yjp@1858447101409070.onaliyun.com</a><br>AccessKey ID LTAI4Fra4zyQQSnn4geVNG4v<br>AccessKeySecret 1aJXo4atnDXPEYfNX1p6lrZJLK1a4y</p>
<p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image%E6%88%AA%E5%B1%8F2020-02-27%E4%B8%8B%E5%8D%889.19.10.png" alt></p>
<p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200302160819.png" alt></p>
<ol>
<li>933个差异基因可以在KEGG里面注释到，ko_ID是map的id</li>
<li>gene 这一栏说明的是拟南芥3W个基因里面注释到pathway里面的基因数目。</li>
<li>7085是背景基因集。<font color="#FF7F50">背景基因集</font>就是拟南芥全部的3w个基因，可以在KEGG数据库注释到的基因。</li>
</ol>
<h3 id="我主要想只要：差异基因里面最主要参与哪个功能。"><a href="#我主要想只要：差异基因里面最主要参与哪个功能。" class="headerlink" title="我主要想只要：差异基因里面最主要参与哪个功能。"></a>我主要想只要：差异基因里面最主要参与哪个功能。</h3><ul>
<li>看参与pathway的DEG，缺点是不准确，差异基因最多的通路不是我关心的通路。</li>
<li>因此需要富集<br><font color="#FF7F50">通路富集的富集因子，表示差异基因中注释到的某通路的基因比例与所有基因中注释到该通路的基因比例的比值。</font>


</li>
</ul>
<h2 id="什么是显著性"><a href="#什么是显著性" class="headerlink" title="什么是显著性"></a>什么是显著性</h2><p>理解为评价指标，用超几何分布检验计算出来。<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200302171645.png" alt></p>
<h3 id="文章主要用显著性指标表示。通路富集的富集因子，用的不广泛。"><a href="#文章主要用显著性指标表示。通路富集的富集因子，用的不广泛。" class="headerlink" title="文章主要用显著性指标表示。通路富集的富集因子，用的不广泛。"></a><font color="#FF7F50">文章主要用显著性指标表示。通路富集的富集因子，用的不广泛。</font></h3><p><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200302224207.png" alt></p>
<h2 id="在线富集平台"><a href="#在线富集平台" class="headerlink" title="在线富集平台"></a>在线富集平台</h2><ul>
<li>KOBAS<br><img src="https://squareface.oss-cn-beijing.aliyuncs.com/image20200303095119.png" alt></li>
</ul>
]]></content>
      <tags>
        <tag>KEGG</tag>
      </tags>
  </entry>
  <entry>
    <title>DJango接受前端数据</title>
    <url>/2019/12/29/DJango%E6%8E%A5%E5%8F%97%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<ol>
<li>vue 会给后端发送一个API链接（应该是保存在list里面），Django根据获取的url进行get请求。会获取到两种格式的数据，csv和image</li>
<li>根据获取到的数据，在使用我提供的函数进行分析，</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>小麦膜片钳</title>
    <url>/2019/11/26/%E5%B0%8F%E9%BA%A6%E8%86%9C%E7%89%87%E9%92%B3/</url>
    <content><![CDATA[<h1 id="小麦里面是没有发现动作电位"><a href="#小麦里面是没有发现动作电位" class="headerlink" title="小麦里面是没有发现动作电位"></a>小麦里面是没有发现动作电位</h1><p>(小麦胚芽)[<a href="https://www.biorxiv.org/content/10.1101/781799v1.full]" target="_blank" rel="noopener">https://www.biorxiv.org/content/10.1101/781799v1.full]</a></p>
]]></content>
  </entry>
  <entry>
    <title>Django 401</title>
    <url>/2019/11/23/Django-401/</url>
    <content><![CDATA[<p>vue发送的是json格式的数据</p>
<p>所以Django接受Json格式的数据</p>
]]></content>
  </entry>
  <entry>
    <title>拟南芥离子通道</title>
    <url>/2019/11/18/%E6%8B%9F%E5%8D%97%E8%8A%A5%E7%A6%BB%E5%AD%90%E9%80%9A%E9%81%93/</url>
    <content><![CDATA[<p>beilby用的应该是浓度建立的模型</p>
<p>我用膜片钳建立的模型，应该更精确。</p>
<p>我可以看看拟南芥，因为基因组数据比较多，也可能做膜片钳的比较多。。</p>
<p>小麦的膜片钳数据我估计是没有了。</p>
<h1 id="Arabidopsis-thaliana"><a href="#Arabidopsis-thaliana" class="headerlink" title="Arabidopsis thaliana"></a>Arabidopsis thaliana</h1><h2 id="保卫细胞"><a href="#保卫细胞" class="headerlink" title="保卫细胞"></a>保卫细胞</h2><p><a href="https://plantmethods.biomedcentral.com/articles/10.1186/1746-4811-8-15" target="_blank" rel="noopener">https://plantmethods.biomedcentral.com/articles/10.1186/1746-4811-8-15</a>  保卫细胞内外钾通道和阴离子通道</p>
<h2 id="表皮细胞"><a href="#表皮细胞" class="headerlink" title="表皮细胞"></a>表皮细胞</h2><h1 id="老师还是建议先做小麦膜片钳的数据。"><a href="#老师还是建议先做小麦膜片钳的数据。" class="headerlink" title="老师还是建议先做小麦膜片钳的数据。"></a>老师还是建议先做小麦膜片钳的数据。</h1>]]></content>
  </entry>
  <entry>
    <title>Myplant_MySQl</title>
    <url>/2019/11/10/Myplant-MySQl/</url>
    <content><![CDATA[<h1 id="create-MySQL-语句"><a href="#create-MySQL-语句" class="headerlink" title="create MySQL 语句"></a>create MySQL 语句</h1><p>CREATE TABLE <code>dataset</code> (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,<br>  <code>author</code> varchar(255) NOT NULL,<br>  <code>created_at</code> datetime NOT NULL,<br>  <code>dataset_meta_id</code> bigint(20) DEFAULT NULL,<br>  <code>description</code> varchar(500) DEFAULT NULL,<br>  <code>equipment_id</code> bigint(20) DEFAULT NULL,<br>  <code>name</code> varchar(255) NOT NULL,<br>  <code>state</code> varchar(255) NOT NULL,<br>  <code>type</code> varchar(255) NOT NULL,<br>  <code>updated_at</code> datetime NOT NULL,<br>  <code>user_id</code> bigint(20) NOT NULL,<br>  PRIMARY KEY (<code>id</code>)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=latin1;</p>
<p>CREATE TABLE <code>dataset_meta</code> (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,<br>  <code>created_at</code> datetime DEFAULT NULL,<br>  <code>detail</code> varchar(255) DEFAULT NULL,<br>  <code>goal</code> varchar(255) DEFAULT NULL,<br>  <code>name</code> varchar(255) NOT NULL,<br>  <code>operators</code> varchar(255) DEFAULT NULL,<br>  <code>paper</code> varchar(255) DEFAULT NULL,<br>  <code>position</code> varchar(255) DEFAULT NULL,<br>  <code>sample</code> varchar(255) DEFAULT NULL,<br>  <code>signal_type</code> varchar(255) DEFAULT NULL,<br>  <code>stimulus</code> varchar(255) DEFAULT NULL,<br>  <code>updated_at</code> datetime DEFAULT NULL,<br>  <code>user_id</code> bigint(20) NOT NULL,<br>  PRIMARY KEY (<code>id</code>)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=latin1;</p>
<p>CREATE TABLE <code>environment</code> (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,<br>  <code>created_at</code> datetime DEFAULT NULL,<br>  <code>humidity</code> double DEFAULT NULL,<br>  <code>light</code> double DEFAULT NULL,<br>  <code>name</code> varchar(255) NOT NULL,<br>  <code>pressure</code> double DEFAULT NULL,<br>  <code>temperature</code> double DEFAULT NULL,<br>  <code>updated_at</code> datetime DEFAULT NULL,<br>  <code>user_id</code> bigint(20) NOT NULL,<br>  PRIMARY KEY (<code>id</code>)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=latin1;</p>
<p>CREATE TABLE <code>equipment</code> (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,<br>  <code>created_at</code> datetime DEFAULT NULL,<br>  <code>description</code> varchar(255) DEFAULT NULL,<br>  <code>name</code> varchar(255) NOT NULL,<br>  <code>provider</code> varchar(255) DEFAULT NULL,<br>  <code>updated_at</code> datetime DEFAULT NULL,<br>  <code>user_id</code> bigint(20) NOT NULL,<br>  PRIMARY KEY (<code>id</code>)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=latin1;</p>
<p>CREATE TABLE <code>iec_meta</code> (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,<br>  <code>channel_num</code> smallint(6) DEFAULT NULL,<br>  <code>created_at</code> datetime DEFAULT NULL,<br>  <code>duration</code> double DEFAULT NULL,<br>  <code>name</code> varchar(255) NOT NULL,<br>  <code>rate</code> int(11) DEFAULT NULL,<br>  <code>record_position</code> varchar(255) DEFAULT NULL,<br>  <code>sampling_rate</code> bigint(20) DEFAULT NULL,<br>  <code>signal_type</code> varchar(255) DEFAULT NULL,<br>  <code>start_at</code> datetime DEFAULT NULL,<br>  <code>stimulate_detail</code> varchar(255) DEFAULT NULL,<br>  <code>stimulate_material</code> varchar(255) DEFAULT NULL,<br>  <code>stimulate_type</code> varchar(255) DEFAULT NULL,<br>  <code>updated_at</code> datetime DEFAULT NULL,<br>  <code>user_id</code> bigint(20) NOT NULL,<br>  PRIMARY KEY (<code>id</code>)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=latin1;</p>
<p>CREATE TABLE <code>image_meta</code> (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,<br>  <code>created_at</code> datetime DEFAULT NULL,<br>  <code>duration</code> double DEFAULT NULL,<br>  <code>format</code> varchar(255) DEFAULT NULL,<br>  <code>frame_rate</code> int(11) DEFAULT NULL,<br>  <code>name</code> varchar(255) NOT NULL,<br>  <code>record_area</code> varchar(255) DEFAULT NULL,<br>  <code>record_position</code> varchar(255) DEFAULT NULL,<br>  <code>signal_type</code> varchar(255) DEFAULT NULL,<br>  <code>start_at</code> datetime DEFAULT NULL,<br>  <code>stimulate_detail</code> varchar(255) DEFAULT NULL,<br>  <code>stimulate_material</code> varchar(255) DEFAULT NULL,<br>  <code>stimulate_type</code> varchar(255) DEFAULT NULL,<br>  <code>updated_at</code> datetime DEFAULT NULL,<br>  <code>user_id</code> bigint(20) NOT NULL,<br>  PRIMARY KEY (<code>id</code>)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;</p>
<p>CREATE TABLE <code>sample</code> (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,<br>  <code>created_at</code> datetime DEFAULT NULL,<br>  <code>growth</code> varchar(255) DEFAULT NULL,<br>  <code>name</code> varchar(255) NOT NULL,<br>  <code>period</code> varchar(255) DEFAULT NULL,<br>  <code>updated_at</code> datetime DEFAULT NULL,<br>  <code>user_id</code> bigint(20) NOT NULL,<br>  PRIMARY KEY (<code>id</code>)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=latin1;</p>
<p>CREATE TABLE <code>software</code> (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,<br>  <code>created_at</code> datetime DEFAULT NULL,<br>  <code>name</code> varchar(255) NOT NULL,<br>  <code>updated_at</code> datetime DEFAULT NULL,<br>  <code>user_id</code> bigint(20) NOT NULL,<br>  <code>version</code> varchar(255) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=latin1;</p>
<p>CREATE TABLE <code>user</code> (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,<br>  <code>address</code> varchar(255) NOT NULL,<br>  <code>created_at</code> datetime NOT NULL,<br>  <code>email</code> varchar(255) NOT NULL,<br>  <code>password</code> varchar(255) NOT NULL,<br>  <code>sex</code> varchar(255) NOT NULL,<br>  <code>updated_at</code> datetime NOT NULL,<br>  <code>username</code> varchar(255) NOT NULL,<br>  PRIMARY KEY (<code>id</code>),<br>  UNIQUE KEY <code>UK_ob8kqyqqgmefl0aco34akdtpe</code> (<code>email</code>),<br>  UNIQUE KEY <code>UK_sb8bbouer5wak8vyiiy4pf2bx</code> (<code>username</code>)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=latin1;</p>
]]></content>
  </entry>
  <entry>
    <title>预测出来 的电信号有啥用？</title>
    <url>/2019/11/07/%E9%A2%84%E6%B5%8B%E5%87%BA%E6%9D%A5-%E7%9A%84%E7%94%B5%E4%BF%A1%E5%8F%B7%E6%9C%89%E5%95%A5%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>我的技术难点在多对多的预测？</p>
<p>这里面也是我为什么很长时间做不出来的原因，单条数据588个点。我觉得应该重点写这个！这样写的话难点在哪里？</p>
<p>我要解决的问题也是可以写！</p>
<ol>
<li>胁迫的信号肯定携带盐浓度： 这个观点太空，不适合神经网络模型，适合机理模型。</li>
</ol>
<ol start="2">
<li><p>具体的盐胁迫数值我可以知道，也就是在使用模型的时候，输入光诱导前的数据，我就可以知道这个植物适合在什么环境中生长，不同盐分下它的涨势评价指标。（这里也是老师重点描述的含义）</p>
</li>
<li><p>我对盐胁迫下的数据进行聚类分析，可以得出什么结论？？？</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>文献查找-真核细胞</title>
    <url>/2019/11/01/%E6%96%87%E7%8C%AE%E6%9F%A5%E6%89%BE-%E7%9C%9F%E6%A0%B8%E7%BB%86%E8%83%9E/</url>
    <content><![CDATA[<p>在生物学的范畴内，高等植物属于真核细胞。</p>
<p>每个离子通道是有好多种家族的，每个家族他们的功能是一定的。</p>
<p>只要找到相关的真核细胞的数据，就能放到植物上来用吧？</p>
]]></content>
  </entry>
  <entry>
    <title>实验室模型发展</title>
    <url>/2019/10/24/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%A8%A1%E5%9E%8B%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<h1 id="2006年，多道植物电信号监测系统，"><a href="#2006年，多道植物电信号监测系统，" class="headerlink" title="2006年，多道植物电信号监测系统，"></a>2006年，多道植物电信号监测系统，</h1><h1 id="2008年。建立单个细胞电位的模型，保卫细胞和叶肉细胞"><a href="#2008年。建立单个细胞电位的模型，保卫细胞和叶肉细胞" class="headerlink" title="2008年。建立单个细胞电位的模型，保卫细胞和叶肉细胞"></a>2008年。建立单个细胞电位的模型，保卫细胞和叶肉细胞</h1><h2 id="建立的是单个细胞的模型。采集到的电信号不是单个细胞的，而是几个细胞的。但是效果很好，可以继续使用。"><a href="#建立的是单个细胞的模型。采集到的电信号不是单个细胞的，而是几个细胞的。但是效果很好，可以继续使用。" class="headerlink" title="建立的是单个细胞的模型。采集到的电信号不是单个细胞的，而是几个细胞的。但是效果很好，可以继续使用。"></a>建立的是单个细胞的模型。采集到的电信号不是单个细胞的，而是几个细胞的。但是效果很好，可以继续使用。</h2><ul>
<li>换句话说，我可以测到保卫细胞的电位，测到以后我怎么研究？有啥用？</li>
<li>用HH模型建模，可以反推出来保卫细胞的电位。</li>
</ul>
<h2 id="那是如何验证模型的？也就是说是如何采集到保卫细胞和叶肉细胞的电信号"><a href="#那是如何验证模型的？也就是说是如何采集到保卫细胞和叶肉细胞的电信号" class="headerlink" title="那是如何验证模型的？也就是说是如何采集到保卫细胞和叶肉细胞的电信号"></a>那是如何验证模型的？也就是说是如何采集到保卫细胞和叶肉细胞的电信号</h2><hr>
<ul>
<li><p>文中说的是用2006年的文章中的方法：微电极插入细胞内，</p>
</li>
<li><p>微电极（玻璃管、金属丝）可在细胞水平上对生物电现象进行观测与研究，其尖端直径小于 1微米，它可插入细胞附近及细胞体内，</p>
</li>
<li><p>引出的是少数几个甚至单个细胞的电活动。</p>
</li>
</ul>
<h3 id="是如何找到保卫细胞和叶肉细胞？"><a href="#是如何找到保卫细胞和叶肉细胞？" class="headerlink" title="是如何找到保卫细胞和叶肉细胞？"></a>是如何找到保卫细胞和叶肉细胞？</h3><ul>
<li>赵东杰 2010年硕士论文有详细提到。</li>
</ul>
<h1 id="2011年。-基于光标测技术的植物细胞电信号监测方法"><a href="#2011年。-基于光标测技术的植物细胞电信号监测方法" class="headerlink" title="2011年。 基于光标测技术的植物细胞电信号监测方法"></a>2011年。 基于光标测技术的植物细胞电信号监测方法</h1><h1 id="2013年。-基于光标测技术和MEA技术的植物电研究概述"><a href="#2013年。-基于光标测技术和MEA技术的植物电研究概述" class="headerlink" title="2013年。 基于光标测技术和MEA技术的植物电研究概述"></a>2013年。 基于光标测技术和MEA技术的植物电研究概述</h1><ul>
<li>同时测量两个细胞以上的电位</li>
</ul>
<h1 id="2013年。-在植物中记录细胞外信号：建模和实验研究"><a href="#2013年。-在植物中记录细胞外信号：建模和实验研究" class="headerlink" title="2013年。 在植物中记录细胞外信号：建模和实验研究"></a>2013年。 在植物中记录细胞外信号：建模和实验研究</h1><ul>
<li></li>
<li>建立胞内和胞外的数量关系</li>
</ul>
<h1 id="2015年。-使用光学记录对植物的电活动进行高分辨率的非接触式测量"><a href="#2015年。-使用光学记录对植物的电活动进行高分辨率的非接触式测量" class="headerlink" title="2015年。 使用光学记录对植物的电活动进行高分辨率的非接触式测量"></a>2015年。 使用光学记录对植物的电活动进行高分辨率的非接触式测量</h1><ul>
<li>光标测 传递熵 信号传递方向 向日葵 </li>
</ul>
<h1 id="2018年。无损表面电位测量，光诱导"><a href="#2018年。无损表面电位测量，光诱导" class="headerlink" title="2018年。无损表面电位测量，光诱导"></a>2018年。无损表面电位测量，光诱导</h1>]]></content>
  </entry>
  <entry>
    <title>wheat whole-cell recording</title>
    <url>/2019/10/23/wheat-whole-cell-recoding/</url>
    <content><![CDATA[<h1 id="Google-搜索结果"><a href="#Google-搜索结果" class="headerlink" title="Google 搜索结果"></a>Google 搜索结果</h1><p>没有匹配的</p>
<h1 id="web-of-science-结果"><a href="#web-of-science-结果" class="headerlink" title="web of science 结果"></a>web of science 结果</h1><p>没有匹配的</p>
<h1 id="google-scholar-结果"><a href="#google-scholar-结果" class="headerlink" title="google scholar 结果"></a>google scholar 结果</h1><p>没有匹配的</p>
<h1 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h1><h2 id="动物神经运动系统的大多数化学物质已在植物中发现"><a href="#动物神经运动系统的大多数化学物质已在植物中发现" class="headerlink" title="动物神经运动系统的大多数化学物质已在植物中发现"></a>动物神经运动系统的大多数化学物质已在植物中发现</h2><p>例如，<br>神经递质（例如乙酰胆碱）和细胞信使以及细胞运动（例如钙调蛋白和肌动蛋白）（Baluska 等人 2006；Murch 2006））。尽管这种类似于神经的细胞设备从未像动物神经那样发展出复杂的程度，但是形成了一个简单的神经网络，尤其是在韧皮部细胞内部，负责长距离的通信。植物之所以开发出电信号传输途径的原因，很可能是对外界刺激（例如环境胁迫因素）迅速做出反应的必要条件。</p>
<p>最近显示，不同的环境刺激会在活细胞中引起特定的反应，从而能够将电信号传输到响应区域（Lautner 等人，2005年））。与激素等化学信号相反，电信号能够在远距离快速传输信息。由于在过去的二十年中已经发现了电信号的多种生理效应（Fromm 2006；Fromm＆Lautner 2006；Trebacz，Dziubinska＆Krol 2006），因此活细胞之间的这种快速传播也可能对植物至关重要。</p>
]]></content>
      <tags>
        <tag>文献搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>平台架构</title>
    <url>/2019/10/21/%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Flask-Vue-Happyhbase-Mysql-用到的框架"><a href="#Flask-Vue-Happyhbase-Mysql-用到的框架" class="headerlink" title="Flask + Vue + Happyhbase + Mysql(用到的框架)"></a>Flask + Vue + Happyhbase + Mysql(用到的框架)</h1><h1 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h1><ul>
<li>Flask 留出对应的接口</li>
<li>我希望用户的数据放到Mysql里面</li>
</ul>
<h2 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h2><p>上传的数据放到Hbase里面</p>
<h2 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h2><h1 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h1><h2 id="把上传的csv文件展示出来，可以参考这个链接："><a href="#把上传的csv文件展示出来，可以参考这个链接：" class="headerlink" title="把上传的csv文件展示出来，可以参考这个链接："></a>把上传的csv文件展示出来，可以参考这个链接：</h2><p><a href="https://www.jianshu.com/p/ad1a49375da4" target="_blank" rel="noopener">https://www.jianshu.com/p/ad1a49375da4</a></p>
]]></content>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>python操作hbase</title>
    <url>/2019/10/17/python%E6%93%8D%E4%BD%9Chbase/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>小麦_膜片钳文献</title>
    <url>/2019/10/15/%E5%B0%8F%E9%BA%A6-%E8%86%9C%E7%89%87%E9%92%B3%E6%96%87%E7%8C%AE/</url>
    <content><![CDATA[<h1 id="搜索组合：“-wheat-“patch-clamp”-”"><a href="#搜索组合：“-wheat-“patch-clamp”-”" class="headerlink" title="搜索组合：“ wheat “patch    clamp” ”"></a>搜索组合：“ wheat “patch    clamp” ”</h1><h2 id="大概满意的："><a href="#大概满意的：" class="headerlink" title="大概满意的："></a>大概满意的：</h2><p><a href="https://link.springer.com/chapter/10.1007/978-3-662-10933-5_35" target="_blank" rel="noopener">https://link.springer.com/chapter/10.1007/978-3-662-10933-5_35</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC159473/" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC159473/</a></p>
<p><a href="http://www.plantphysiol.org/content/97/2/598.long?utm_source=TrendMD&amp;utm_medium=cpc&amp;utm_campaign=Plant_Physiol_TrendMD_0" target="_blank" rel="noopener">http://www.plantphysiol.org/content/97/2/598.long?utm_source=TrendMD&amp;utm_medium=cpc&amp;utm_campaign=Plant_Physiol_TrendMD_0</a> </p>
<h3 id="耐盐和耐盐小麦品种根细胞质膜上阳离子通道的K-Na-选择性不同"><a href="#耐盐和耐盐小麦品种根细胞质膜上阳离子通道的K-Na-选择性不同" class="headerlink" title="耐盐和耐盐小麦品种根细胞质膜上阳离子通道的K + / Na +选择性不同"></a>耐盐和耐盐小麦品种根细胞质膜上阳离子通道的K + / Na +选择性不同</h3><h4 id="阳离子外向整流通道"><a href="#阳离子外向整流通道" class="headerlink" title="阳离子外向整流通道"></a>阳离子外向整流通道</h4><p>研究小麦跟根细胞原生质体中阳离子外向通道的特性。<br>好像有细胞的膜片钳数据</p>
<h1 id="通过综述找对应的文献"><a href="#通过综述找对应的文献" class="headerlink" title="通过综述找对应的文献"></a>通过综述找对应的文献</h1><p><a href="https://link.springer.com/article/10.1007/s00232-017-9969-7" target="_blank" rel="noopener">https://link.springer.com/article/10.1007/s00232-017-9969-7</a></p>
<p><a href="https://link.springer.com/article/10.1134%2FS1990747817010068" target="_blank" rel="noopener">https://link.springer.com/article/10.1134%2FS1990747817010068</a> 考虑液泡</p>
<p>包括动作电位（AP）在内的电信号在植物适应不断变化的环境条件方面发挥着重要作用。需要进行AP生成机理的实验和理论研究，以了解环境因素与植物电活动之间的关系。在这项工作中，我们详细阐述了AP生成的数学模型，该模型考虑了液泡参与电响应的生成。该模型描述了质膜的转运蛋白（Ca 2 +，Cl –和K +通道，H +和Ca 2+ -ATPase，H + / K +反向转运蛋白和2H + / Cl–同向转运蛋白和液泡膜（Ca 2 +，Cl –和K +通道； H + -和Ca 2+ -ATPases； H + / K +，2H + / Cl –和3H + / Ca 2+反转运蛋白） ，并适当考虑第二信使（Ca 2+和IP3）的调节。还描述了质外性，细胞质和液泡缓冲液。模拟AP的特性与实验数据非常吻合。AP模型描述了液泡面积和体积增加时电信号的衰减。这种作用与钙的减少有关2+尖峰幅度。该电信号被弱由K个的影响+和Cl -中的液泡的内容。还显示，在模型的给定参数下，液泡IP 3依赖性Ca 2+通道对AP期间钙峰值产生的贡献微不足道。结果为液泡面积和体积在植物细胞兴奋性中的意义提供了理论证据。</p>
<h1 id="关键词-“guard-cells-wheat-channel"><a href="#关键词-“guard-cells-wheat-channel" class="headerlink" title="关键词 “guard cells wheat channel"></a>关键词 “guard cells wheat channel</h1><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><p>效果：<br>    1 搜索“<strong>***</strong>”
    2 返回包含“&amp;&amp;&amp;&amp;&amp;”关键词的页面</p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>部署Myplant</title>
    <url>/2019/10/13/%E9%83%A8%E7%BD%B2Myplant/</url>
    <content><![CDATA[<p>– 安装hbase<br>– 安装mysql<br>– 安装vnc viewer<br>– 配置nginx </p>
<h2 id="后台运行jar包"><a href="#后台运行jar包" class="headerlink" title="后台运行jar包"></a>后台运行jar包</h2><p>nohup java -jar demo-1.0.0-SNAPSHOT.jar &gt; ./log1017.log 2&gt;&amp;1 &amp;</p>
]]></content>
  </entry>
  <entry>
    <title>保存图片画质</title>
    <url>/2019/10/11/%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E7%94%BB%E8%B4%A8/</url>
    <content><![CDATA[<h3 id="问题保存的图片不清晰，quality设置图片质量"><a href="#问题保存的图片不清晰，quality设置图片质量" class="headerlink" title="问题保存的图片不清晰，quality设置图片质量"></a>问题保存的图片不清晰，quality设置图片质量</h3><p>plt.savefig(‘V=’+list(data.columns)[i]+’mV’, dpi=300,bbox_inches=’tight’, pad_inches=0.0,puality=95)</p>
]]></content>
  </entry>
  <entry>
    <title>CAE</title>
    <url>/2019/10/10/CAE/</url>
    <content><![CDATA[<p>encoder_op.shape(?, 20),<br>decoder.shape:(10, 28, 28, 1),<br>y_pred.shape:(10, 28, 28, 1),<br>y_true.shape:(?, 28, 28, 1),<br> x_image.shape:(?, 28, 28, 1)</p>
<p>对电信号padding</p>
]]></content>
  </entry>
  <entry>
    <title>训练记录</title>
    <url>/2019/10/09/%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>数据相似度比较高：<br>    层次越小效果也好，loss值越低<br>    序列的长度会影响预测的效果。</p>
<p>数据增强：<br>    数据集添加噪声，<br>    GAN ？？？</p>
<p>lstm编码器<br>BP编码器<br>卷积编码器<br>卷积lstm编码器</p>
]]></content>
      <tags>
        <tag>MC</tag>
      </tags>
  </entry>
  <entry>
    <title>论文逻辑</title>
    <url>/2019/10/08/%E8%AE%BA%E6%96%87%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>建立信号和环境因子的关系。（这样不是意义，不能这样说。感觉差点意思，模型是数据驱动的，没有挖掘出来信号可以携带的信息）</p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>我现在可以用seq2seq去预测刺激后的信号，模型的可解释是没必要的（物理含义），因为本身就是数据驱动的。</p>
<p>重点：数据驱动的模型直接从历史电信号中探索植物电信号和盐胁迫的之间的关系，而无需考虑物理过程。</p>
<h1 id="最主要的逻辑问题-："><a href="#最主要的逻辑问题-：" class="headerlink" title="最主要的逻辑问题 ："></a>最主要的逻辑问题 ：</h1><pre><code>训练好的seq2seq，已经发现了历史电信号中探索植物电信号和盐胁迫的之间的关系，描述就是网络结构。但是没办法进行深层次的描述。而且也可以使用。

缺乏可解释性的模型，对环境因子和电信号的关系，有啥用？？？

电信号预测：  可以知道植物刺激后的信号，可以用来分类。（刺激后的稳定波形是可以用来判定是否耐盐）
            可以知道植物和环境之间的关系模型。
            通过电信号知道植物所处的生长环境：这是分类的问题，和我写的预测不是一个问题啊。
                我可以描述环境信息来论证模型。  
                    相同环境采集到的电信号都不一样。。。
                    光梯度、盐梯度是Y
                    X是电信号（588个点）</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><pre><code>看相关文章都是怎么描述的。
    NLP：就是翻译或生成，肉眼看的见的应用。实用，
    ECG：分类可以看出有啥病，预测可以看出可能患病的概率。生成可以提高预测和分类的准确性。
    股票、交通流量、</code></pre><p>同样的问题：<br>    分类电信号的目的是区别品质—-&gt; 这样做的目的仅仅是为了分类吗？那具体的应用意义是什么呢？？？</p>
<p>那我预测电信号的目的是什么？？？？</p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/10/08/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<hr>
<p>title: 网络结构思考<br>date: 2019-10-08 11:42:34</p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags: "></a>tags: </h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">def add_layer(inputs, in_shape, out_shape, activation_function=None):</span><br><span class="line">    Weights = tf.Variable(tf.random_normal([in_shape, out_shape]))</span><br><span class="line">    bais = tf.Variable(tf.zeros([1, out_shape])+0.1)</span><br><span class="line">    y_pred = tf.matmul(inputs, Weights) + bais</span><br><span class="line">    <span class="keyword">if</span> activation_function is None:</span><br><span class="line">        outputs = y_pred</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outputs = activation_function(y_pred)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> outputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 创建数据，x y 的 shape[300,1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x_data = np.linspace(-1,1,300, dtype=np.float32)[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">noise = np.random.normal(0, 0.05, x_data.shape).astype(np.float32)</span><br><span class="line">y_data = np.square(x_data) - 0.5 + noise</span><br><span class="line"></span><br><span class="line">xs = tf.placeholder(tf.float32, [None, 1])</span><br><span class="line">ys = tf.placeholder(tf.float32, [None, 1])</span><br><span class="line"></span><br><span class="line">l1 = add_layer(xs,1,10,activation_function=tf.nn.relu)</span><br><span class="line">predict = add_layer(l1, 10, 1, activation_function=None)</span><br><span class="line">loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys-predict),</span><br><span class="line">                                    reduction_indices=[1]</span><br><span class="line">                    ))</span><br><span class="line"></span><br><span class="line">train = tf.train.GradientDescentOptimizer(0.1).minimize(loss)</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1000):</span><br><span class="line">        <span class="comment"># training</span></span><br><span class="line">        sess.run(train, feed_dict=&#123;xs: x_data, ys: y_data&#125;)</span><br><span class="line">        <span class="keyword">if</span> i % 50 == 0:</span><br><span class="line">            <span class="comment"># to see the step improvement</span></span><br><span class="line">            <span class="built_in">print</span>(sess.run(loss, feed_dict=&#123;xs: x_data, ys: y_data&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="我的数据shape"><a href="#我的数据shape" class="headerlink" title="我的数据shape"></a>我的数据shape</h3><p>x.shape = (None, 588) # 有N条样本，每条588个特征，也对有588个y。<br>y.shape = (None, 588)</p>
<h4 id="588个x对应588个y可以计算吗？"><a href="#588个x对应588个y可以计算吗？" class="headerlink" title="588个x对应588个y可以计算吗？"></a>588个x对应588个y可以计算吗？</h4><p>这样我的数据对应的不是一个Y值，换个思路说，1个x对应一个y可以计算。588个x对应一个y可以计算。588个x对应588个y可以计算吗？</p>
<h3 id="维度扩展，在第三个维度，数据都是1。这样可以计算。"><a href="#维度扩展，在第三个维度，数据都是1。这样可以计算。" class="headerlink" title="维度扩展，在第三个维度，数据都是1。这样可以计算。"></a>维度扩展，在第三个维度，数据都是1。这样可以计算。</h3>]]></content>
  </entry>
  <entry>
    <title>斯皮尔曼spearman</title>
    <url>/2019/10/06/%E6%96%AF%E7%9A%AE%E5%B0%94%E6%9B%BCspearman/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"> </span><br><span class="line"><span class="comment">#原始数据</span></span><br><span class="line">X1=pd.Series([1, 2, 3, 4, 5, 6])</span><br><span class="line">Y1=pd.Series([0.3, 0.9, 2.7, 2, 3.5, 5])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def spearman(x1, y1):</span><br><span class="line">    <span class="built_in">return</span>(x1.corr(y1,method=<span class="string">'spearman'</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(spearman(X1,Y1))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#处理数据删除Nan</span></span><br><span class="line"><span class="comment"># x1=X1.dropna()</span></span><br><span class="line"><span class="comment"># y1=Y1.dropna()</span></span><br><span class="line"><span class="comment"># n=x1.count()</span></span><br><span class="line"><span class="comment"># x1.index=np.arange(n)</span></span><br><span class="line"><span class="comment"># y1.index=np.arange(n)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># #分部计算</span></span><br><span class="line"><span class="comment"># d=(x1.sort_values().index-y1.sort_values().index)**2</span></span><br><span class="line"><span class="comment"># dd=d.to_series().sum()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># p=1-n*dd/(n*(n**2-1))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># #s.corr()函数计算</span></span><br><span class="line">r=x1.corr(y1,method=<span class="string">'spearman'</span>)</span><br><span class="line"><span class="built_in">print</span>(r) <span class="comment">#0.942857142857143 0.9428571428571428</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>seq2seq优化</title>
    <url>/2019/10/04/seq2seq%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>67条测试集</p>
<p>平均rmse = 0.185417<br>最大rmse = 0.6110<br>最小rmse = 0.0588</p>
]]></content>
  </entry>
  <entry>
    <title>AutoEncoder自编码器</title>
    <url>/2019/10/03/AutoEncoder%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/</url>
    <content><![CDATA[<p>自编码器是一种压缩特征的方法，和PCA降维类似。</p>
<p>自编码器主要用在降维和去噪。</p>
<p>def add(x, y, name=None):<br>  “””Returns x + y element-wise.<br>“””</p>
<p>def sigmoid(x, name=None):<br>  “””Computes sigmoid of <code>x</code> element-wise.</p>
<p>  Specifically, <code>y = 1 / (1 + exp(-x))</code>.
“””</p>
]]></content>
      <tags>
        <tag>MC</tag>
      </tags>
  </entry>
  <entry>
    <title>tf.layers.dense()参数</title>
    <url>/2019/10/02/tf-layers-dense-%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h3 id="units-是输出的shape"><a href="#units-是输出的shape" class="headerlink" title="units 是输出的shape"></a>units 是输出的shape</h3><p>之前一直对units的理解有出入，认为units是什么这一层神经元的个数，而且tf官方文档给的也是这个含义。但是在使用的时候并不是这个含义，但是按照单元数这个含义，也可以解释通。</p>
<p>今天在复习tf的时候发现自己写的add_layer()函数就是tf.layers.dense()</p>
<h4 id="add-layer"><a href="#add-layer" class="headerlink" title="add_layer()"></a>add_layer()</h4><p>这个其实就是一个函数，它的功能就是 outputs = activation(inputs * kernel + bias)。说的直白点就是完成矩阵运算。</p>
<p>kernel 就是常说的权重，是matrix 格式，<br>bias是偏置，是vector格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def add_layer(input_data, input_size, output_size, activation_function=None):</span><br><span class="line">	<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">	input_data, 输入的数据</span></span><br><span class="line"><span class="string">	input_size, 输入数据的shape</span></span><br><span class="line"><span class="string">	output_size, 输出数据的shape</span></span><br><span class="line"><span class="string">	activation_function=None 激活函数</span></span><br><span class="line"><span class="string">	"</span><span class="string">""</span></span><br><span class="line">    <span class="comment"># 产生input_size行output_size列的随机数</span></span><br><span class="line">    Weights = tf.Variable(tf.random_normal([input_size, output_size]))</span><br><span class="line">    <span class="comment"># 产生一行output_size列全为0.1的数</span></span><br><span class="line">    biases = tf.Variable(tf.zeros([1, output_size]) + 0.1)</span><br><span class="line">    <span class="comment"># input_data * weights + biases</span></span><br><span class="line">    Wx_plus_b = tf.matmul(input_data, Weights) + biases</span><br><span class="line">    <span class="keyword">if</span> activation_function is None:</span><br><span class="line">        output = Wx_plus_b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output = activation_function(Wx_plus_b)</span><br><span class="line">    <span class="built_in">return</span> output</span><br></pre></td></tr></table></figure>

<h4 id="tf-layers-dense"><a href="#tf-layers-dense" class="headerlink" title="tf.layers.dense()"></a>tf.layers.dense()</h4><p>这是tf.layers.dense()所需要的参数，tf忽忽略了input_size这个参数，因为和input_data.shape的数值是一样的。</p>
<p>inputs—-&gt;input_data<br>units —–&gt; output_size</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def dense(</span><br><span class="line">    inputs, units,</span><br><span class="line">    activation=None,</span><br><span class="line">    use_bias=True,</span><br><span class="line">    kernel_initializer=None,</span><br><span class="line">    bias_initializer=init_ops.zeros_initializer(),</span><br><span class="line">    kernel_regularizer=None,</span><br><span class="line">    bias_regularizer=None,</span><br><span class="line">    activity_regularizer=None,</span><br><span class="line">    kernel_constraint=None,</span><br><span class="line">    bias_constraint=None,</span><br><span class="line">    trainable=True,</span><br><span class="line">    name=None,</span><br><span class="line">    reuse=None):</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>BP神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>论文选择</title>
    <url>/2019/09/30/%E8%AE%BA%E6%96%87%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h3 id="GuardCell"><a href="#GuardCell" class="headerlink" title="GuardCell"></a>GuardCell</h3><p>保卫细胞膜上的快速阴离子通道具有钙依赖性、时间依赖性、电压依赖性，能够穿过该通道的阴离子主要是CI-。保卫细胞感应到外界刺激后，胞内Ca2+浓度的提高可以激活快速阴离子通道，引起CI-外流。</p>
<p>搜索关键词</p>
<p>“Anion channel” wheat “patch clamp”</p>
<p>还是需要读懂小飞姐找的文献</p>
<p>GCAC: guard cell anion channel </p>
<p>电压刺激下的电流数据 </p>
<h3 id="shabala的researchgate-上搜索关键词”patch-clamp”-“wheat”"><a href="#shabala的researchgate-上搜索关键词”patch-clamp”-“wheat”" class="headerlink" title="shabala的researchgate 上搜索关键词”patch clamp” “wheat”"></a>shabala的researchgate 上搜索关键词”patch clamp” “wheat”</h3>]]></content>
      <tags>
        <tag>文献查找</tag>
      </tags>
  </entry>
  <entry>
    <title>tf.matmul()函数用法</title>
    <url>/2019/09/28/tf-matmul-%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@tf_export(<span class="string">"linalg.matmul"</span>, <span class="string">"matmul"</span>)</span><br><span class="line">@dispatch.add_dispatch_support</span><br><span class="line">def matmul(a,</span><br><span class="line">           b,</span><br><span class="line">           transpose_a=False,</span><br><span class="line">           transpose_b=False,</span><br><span class="line">           adjoint_a=False,</span><br><span class="line">           adjoint_b=False,</span><br><span class="line">           a_is_sparse=False,</span><br><span class="line">           b_is_sparse=False,</span><br><span class="line">           name=None):</span><br><span class="line">  <span class="string">""</span><span class="string">"Multiplies matrix `a` by matrix `b`, producing `a` * `b`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  The inputs must, following any transpositions, be tensors of rank &gt;= 2</span></span><br><span class="line"><span class="string">  where the inner 2 dimensions specify valid matrix multiplication arguments,</span></span><br><span class="line"><span class="string">  and any further outer dimensions match.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Both matrices must be of the same type. The supported types are:</span></span><br><span class="line"><span class="string">  `float16`, `float32`, `float64`, `int32`, `complex64`, `complex128`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Either matrix can be transposed or adjointed (conjugated and transposed) on</span></span><br><span class="line"><span class="string">  the fly by setting one of the corresponding flag to `True`. These are `False`</span></span><br><span class="line"><span class="string">  by default.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  If one or both of the matrices contain a lot of zeros, a more efficient</span></span><br><span class="line"><span class="string">  multiplication algorithm can be used by setting the corresponding</span></span><br><span class="line"><span class="string">  `a_is_sparse` or `b_is_sparse` flag to `True`. These are `False` by default.</span></span><br><span class="line"><span class="string">  This optimization is only available for plain matrices (rank-2 tensors) with</span></span><br><span class="line"><span class="string">  datatypes `bfloat16` or `float32`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  For example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ```python</span></span><br><span class="line"><span class="string">  # 2-D tensor `a`</span></span><br><span class="line"><span class="string">  # [[1, 2, 3],</span></span><br><span class="line"><span class="string">  #  [4, 5, 6]]</span></span><br><span class="line"><span class="string">  a = tf.constant([1, 2, 3, 4, 5, 6], shape=[2, 3])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # 2-D tensor `b`</span></span><br><span class="line"><span class="string">  # [[ 7,  8],</span></span><br><span class="line"><span class="string">  #  [ 9, 10],</span></span><br><span class="line"><span class="string">  #  [11, 12]]</span></span><br><span class="line"><span class="string">  b = tf.constant([7, 8, 9, 10, 11, 12], shape=[3, 2])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # `a` * `b`</span></span><br><span class="line"><span class="string">  # [[ 58,  64],</span></span><br><span class="line"><span class="string">  #  [139, 154]]</span></span><br><span class="line"><span class="string">  c = tf.matmul(a, b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # 3-D tensor `a`</span></span><br><span class="line"><span class="string">  # [[[ 1,  2,  3],</span></span><br><span class="line"><span class="string">  #   [ 4,  5,  6]],</span></span><br><span class="line"><span class="string">  #  [[ 7,  8,  9],</span></span><br><span class="line"><span class="string">  #   [10, 11, 12]]]</span></span><br><span class="line"><span class="string">  a = tf.constant(np.arange(1, 13, dtype=np.int32),</span></span><br><span class="line"><span class="string">                  shape=[2, 2, 3])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # 3-D tensor `b`</span></span><br><span class="line"><span class="string">  # [[[13, 14],</span></span><br><span class="line"><span class="string">  #   [15, 16],</span></span><br><span class="line"><span class="string">  #   [17, 18]],</span></span><br><span class="line"><span class="string">  #  [[19, 20],</span></span><br><span class="line"><span class="string">  #   [21, 22],</span></span><br><span class="line"><span class="string">  #   [23, 24]]]</span></span><br><span class="line"><span class="string">  b = tf.constant(np.arange(13, 25, dtype=np.int32),</span></span><br><span class="line"><span class="string">                  shape=[2, 3, 2])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # `a` * `b`</span></span><br><span class="line"><span class="string">  # [[[ 94, 100],</span></span><br><span class="line"><span class="string">  #   [229, 244]],</span></span><br><span class="line"><span class="string">  #  [[508, 532],</span></span><br><span class="line"><span class="string">  #   [697, 730]]]</span></span><br><span class="line"><span class="string">  c = tf.matmul(a, b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # Since python &gt;= 3.5 the @ operator is supported (see PEP 465).</span></span><br><span class="line"><span class="string">  # In TensorFlow, it simply calls the `tf.matmul()` function, so the</span></span><br><span class="line"><span class="string">  # following lines are equivalent:</span></span><br><span class="line"><span class="string">  d = a @ b @ [[10.], [11.]]</span></span><br><span class="line"><span class="string">  d = tf.matmul(tf.matmul(a, b), [[10.], [11.]])</span></span><br></pre></td></tr></table></figure>

<p>  Args:<br>    a: <code>Tensor</code> of type <code>float16</code>, <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>complex64</code>,
      <code>complex128</code> and rank &gt; 1.<br>    b: <code>Tensor</code> with same type and rank as <code>a</code>.
    transpose_a: If <code>True</code>, <code>a</code> is transposed before multiplication.<br>    transpose_b: If <code>True</code>, <code>b</code> is transposed before multiplication.<br>    adjoint_a: If <code>True</code>, <code>a</code> is conjugated and transposed before<br>      multiplication.<br>    adjoint_b: If <code>True</code>, <code>b</code> is conjugated and transposed before<br>      multiplication.<br>    a_is_sparse: If <code>True</code>, <code>a</code> is treated as a sparse matrix.<br>    b_is_sparse: If <code>True</code>, <code>b</code> is treated as a sparse matrix.<br>    name: Name for the operation (optional).</p>
<p>  Returns:<br>    A <code>Tensor</code> of the same type as <code>a</code> and <code>b</code> where each inner-most matrix is<br>    the product of the corresponding matrices in <code>a</code> and <code>b</code>, e.g. if all<br>    transpose or adjoint attributes are <code>False</code>:</p>
<pre><code>`output`[..., i, j] = sum_k (`a`[..., i, k] * `b`[..., k, j]),
for all indices i, j.

Note: This is matrix product, not element-wise product.</code></pre><p>  Raises:<br>    ValueError: If transpose_a and adjoint_a, or transpose_b and adjoint_b<br>      are both set to True.<br>  “””<br>  with ops.name_scope(name, “MatMul”, [a, b]) as name:<br>    if transpose_a and adjoint_a:<br>      raise ValueError(“Only one of transpose_a and adjoint_a can be True.”)<br>    if transpose_b and adjoint_b:<br>      raise ValueError(“Only one of transpose_b and adjoint_b can be True.”)</p>
<pre><code>if context.executing_eagerly():
  if not isinstance(a, (ops.EagerTensor, _resource_variable_type)):
    a = ops.convert_to_tensor(a, name=&quot;a&quot;)
  if not isinstance(b, (ops.EagerTensor, _resource_variable_type)):
    b = ops.convert_to_tensor(b, name=&quot;b&quot;)
else:
  a = ops.convert_to_tensor(a, name=&quot;a&quot;)
  b = ops.convert_to_tensor(b, name=&quot;b&quot;)

# TODO(apassos) remove _shape_tuple here when it is not needed.
a_shape = a._shape_tuple()  # pylint: disable=protected-access
b_shape = b._shape_tuple()  # pylint: disable=protected-access

if fwd_compat.forward_compatible(2019, 4, 25):
  output_may_have_non_empty_batch_shape = (
      (a_shape is None or len(a_shape) &gt; 2) or
      (b_shape is None or len(b_shape) &gt; 2))
  batch_mat_mul_fn = gen_math_ops.batch_mat_mul_v2
else:
  output_may_have_non_empty_batch_shape = (
      (a_shape is None or len(a_shape) &gt; 2) and
      (b_shape is None or len(b_shape) &gt; 2))
  batch_mat_mul_fn = gen_math_ops.batch_mat_mul

if (not a_is_sparse and
    not b_is_sparse) and output_may_have_non_empty_batch_shape:
  # BatchMatmul does not support transpose, so we conjugate the matrix and
  # use adjoint instead. Conj() is a noop for real matrices.
  if transpose_a:
    a = conj(a)
    adjoint_a = True
  if transpose_b:
    b = conj(b)
    adjoint_b = True
  return batch_mat_mul_fn(a, b, adj_x=adjoint_a, adj_y=adjoint_b, name=name)

# Neither matmul nor sparse_matmul support adjoint, so we conjugate
# the matrix and use transpose instead. Conj() is a noop for real
# matrices.
if adjoint_a:
  a = conj(a)
  transpose_a = True
if adjoint_b:
  b = conj(b)
  transpose_b = True

use_sparse_matmul = False
if a_is_sparse or b_is_sparse:
  sparse_matmul_types = [dtypes.bfloat16, dtypes.float32]
  use_sparse_matmul = (
      a.dtype in sparse_matmul_types and b.dtype in sparse_matmul_types)
if ((a.dtype == dtypes.bfloat16 or b.dtype == dtypes.bfloat16) and
    a.dtype != b.dtype):
  # matmul currently doesn&apos;t handle mixed-precision inputs.
  use_sparse_matmul = True
if use_sparse_matmul:
  ret = sparse_matmul(
      a,
      b,
      transpose_a=transpose_a,
      transpose_b=transpose_b,
      a_is_sparse=a_is_sparse,
      b_is_sparse=b_is_sparse,
      name=name)
  # sparse_matmul always returns float32, even with
  # bfloat16 inputs. This prevents us from configuring bfloat16 training.
  # casting to bfloat16 also matches non-sparse matmul behavior better.
  if a.dtype == dtypes.bfloat16 and b.dtype == dtypes.bfloat16:
    ret = cast(ret, dtypes.bfloat16)
  return ret
else:
  return gen_math_ops.mat_mul(
      a, b, transpose_a=transpose_a, transpose_b=transpose_b, name=name)</code></pre><pre><code></code></pre>]]></content>
  </entry>
  <entry>
    <title>拟合门控概率</title>
    <url>/2019/09/28/%E6%8B%9F%E5%90%88%E9%97%A8%E6%8E%A7%E6%A6%82%E7%8E%87/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import math</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">from scipy.optimize import curve_fit</span><br><span class="line"></span><br><span class="line">path = <span class="string">'/Users/squareface/PycharmProjects/testVenv/'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = 2</span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">data = pd.read_csv(path+<span class="string">'data'</span>+str(num)+<span class="string">'.csv'</span>)</span><br><span class="line"><span class="comment"># x赋值</span></span><br><span class="line">x = np.array(data.iloc[:,0])</span><br><span class="line"></span><br><span class="line">G = 36</span><br><span class="line"><span class="comment"># 定义方程</span></span><br><span class="line">def func1(x,m,tm,h,th):</span><br><span class="line">    <span class="built_in">return</span> G*m*m*(1-np.exp(-x/tm))**2*(h-(h-1)*np.exp(-x/th))</span><br><span class="line">def func2(x,m,tm):</span><br><span class="line">    <span class="built_in">return</span> G*m*m*(1-np.exp(-x/tm))**2</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合不同电位</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,len(data.columns)):</span><br><span class="line">    y = np.array(data.iloc[:,i])</span><br><span class="line">    <span class="comment">#非线性最小二乘法拟</span></span><br><span class="line">    <span class="keyword">if</span> i&gt;2:</span><br><span class="line">        popt, pcov = curve_fit(func1, x, y,maxfev = 9999999,bounds=(0,60),method=<span class="string">'trf'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        popt, pcov = curve_fit(func2, x, y,maxfev = 9999999,bounds=(0,60),method=<span class="string">'trf'</span>)</span><br><span class="line">    <span class="comment">#获取popt里面是拟合系数</span></span><br><span class="line">    <span class="keyword">if</span> i&gt;2:</span><br><span class="line">        a = popt[0]</span><br><span class="line">        b = popt[1]</span><br><span class="line">        c = popt[2]</span><br><span class="line">        d = popt[3]</span><br><span class="line">        yvals = func1(x,a,b,c,d)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = popt[0]</span><br><span class="line">        b = popt[1]</span><br><span class="line">        c = np.nan</span><br><span class="line">        d = np.nan</span><br><span class="line">        yvals = func2(x,a,b)</span><br><span class="line">    <span class="comment"># 绘图</span></span><br><span class="line">    plt.cla()</span><br><span class="line">    plot1 = plt.plot(x, y, <span class="string">'s'</span>,label=<span class="string">'original values'</span>) <span class="comment"># 原始点</span></span><br><span class="line">    plot2 = plt.plot(x, yvals, <span class="string">'r'</span>,label=<span class="string">'polyfit values'</span>) <span class="comment"># 拟合线</span></span><br><span class="line">    plt.xlabel(<span class="string">'t'</span>) <span class="comment"># x轴标签</span></span><br><span class="line">    plt.ylabel(<span class="string">'gCIR'</span>) <span class="comment"># y轴标签</span></span><br><span class="line">    plt.legend(loc=<span class="string">'best'</span>) <span class="comment"># 图例</span></span><br><span class="line">    plt.title(<span class="string">'V='</span>+list(data.columns)[i]+<span class="string">'mV'</span>) <span class="comment"># 标题</span></span><br><span class="line">    plt.savefig(path+str(num)+<span class="string">'_'</span>+str(list(data.columns)[i])+<span class="string">'mV.png'</span>) <span class="comment"># 保存图</span></span><br><span class="line">    result.append([list(data.columns)[i],b,d,G*a*a,a,c])</span><br><span class="line"><span class="comment"># 保存数据</span></span><br><span class="line">result = pd.DataFrame(result,columns=[<span class="string">'V'</span>,<span class="string">'tm'</span>,<span class="string">'th'</span>,<span class="string">'GCIRm2'</span>,<span class="string">'m'</span>,<span class="string">'h'</span>])</span><br><span class="line">result.to_csv(path+str(num)+<span class="string">'_'</span>+<span class="string">'result.csv'</span>,index=False)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>仿真HH方程</title>
    <url>/2019/09/28/%E4%BB%BF%E7%9C%9FHH%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<p>仿真恒流刺激</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import math</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.figure(figsize=(10,10))</span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line">DT = 0.001</span><br><span class="line">t = np.linspace(0,50,int(50/DT)+1)   <span class="comment"># 仿真时间   光 1200</span></span><br><span class="line">Cm = 1   <span class="comment"># 膜电容</span></span><br><span class="line">I = 90   <span class="comment"># 刺激电流 ?????电流不能太大</span></span><br><span class="line">v = -112 <span class="comment"># 静息电位</span></span><br><span class="line">GK = 24 <span class="comment"># GK=3.5;</span></span><br><span class="line">GCl = 36 <span class="comment"># GCl=16;</span></span><br><span class="line">GCl_slow = 1</span><br><span class="line">GKin = 20</span><br><span class="line">GH = 0.28</span><br><span class="line">n2 = 0</span><br><span class="line">m2 = 0</span><br><span class="line">nn2 = 0</span><br><span class="line">s2 = 0</span><br><span class="line">h2 = 1</span><br><span class="line">k2 = 0</span><br><span class="line">v2 = v</span><br><span class="line"></span><br><span class="line">T0 = 25</span><br><span class="line">Tinitial = 18</span><br><span class="line">Tend = 4</span><br><span class="line">Iin0 = 0.005 <span class="comment"># Iin0=0.0193;</span></span><br><span class="line">Iinmax = 3 <span class="comment"># Iinmax=2.5;</span></span><br><span class="line">K1 = 1</span><br><span class="line">n_t1 = 3</span><br><span class="line">Iexmax = 1</span><br><span class="line">Km = 0.5</span><br><span class="line">n_t2 = 2</span><br><span class="line">Q = 10</span><br><span class="line">P0 = 0.005</span><br><span class="line">Kp = 0.5</span><br><span class="line">Ca0 = 0.1   <span class="comment"># 细胞质Ca离子浓度,uM</span></span><br><span class="line">Ca2 = Ca0</span><br><span class="line">KQ = math.log(Q)/10 </span><br><span class="line">T1 = Tinitial</span><br><span class="line">Rate = -0.8 <span class="comment"># 摄氏度/秒</span></span><br><span class="line">tc = 45 <span class="comment"># 秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,len(t)):</span><br><span class="line">    <span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line">    Ca1 = Ca2;</span><br><span class="line">    T2 = T1+Rate*DT*math.exp(-t[i]/tc)</span><br><span class="line">    temp = (-(Rate*math.exp(-t[i]/tc)-abs(Rate*math.exp(-t[i]/tc)))/2)**n_t1</span><br><span class="line">    dCadt = Iin0+Iinmax*temp/(K1**n_t1+temp) - Iexmax*math.exp(KQ*(T1-T0))*(Ca1**n_t2)/(Km**n2+Ca1**n_t2)</span><br><span class="line">    Ca2 = Ca1+DT*dCadt</span><br><span class="line">    dIexmax = DT*P0*np.sign(Ca1-Ca0)*Ca1/(Kp+Ca1)</span><br><span class="line">    Iexmax = Iexmax+dIexmax</span><br><span class="line">    Itemperature = -0.6823*dCadt*450  <span class="comment"># 单位没有转换 Itemperature=-0.0154*dCadt/0.00005;</span></span><br><span class="line">    T1 = T2</span><br><span class="line">    <span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line">    n1 = n2</span><br><span class="line">    m1 = m2</span><br><span class="line">    h1 = h2 </span><br><span class="line">    s1 = s2</span><br><span class="line">    k1 = k2</span><br><span class="line">    nn1 = nn2</span><br><span class="line">    v1 = v2</span><br><span class="line">    V = v1</span><br><span class="line">    Ib = 2*(V+127.5) <span class="comment">#   Ib=2*(V+130.5);</span></span><br><span class="line">    am = 10.55*(V+60)/(1-math.exp(-(V+60)/7.029))</span><br><span class="line">    bm = 44.32*math.exp(-V/98.2)</span><br><span class="line">    ah = 38.35*math.exp(-V/41.39)</span><br><span class="line">    bh = 7.249/(1+0.6061*math.exp(-V/26.58))</span><br><span class="line">    an = (0.01812*V+2.598)/(1+0.5954*math.exp(-V/10.8))</span><br><span class="line">    bn = 1.56*math.exp(-V/23.4) </span><br><span class="line">    AS = 0.02985*math.exp(V/144.6)   <span class="comment">#慢Cl</span></span><br><span class="line">    bs = 0.03542*math.exp(-V/91.67)</span><br><span class="line">    ak = 0.01414*math.exp(-0.03175*V)/(1+math.exp(0.2434*V))<span class="comment">#  内向K</span></span><br><span class="line">    bk = 974.1*math.exp(0.04129*V)/(1+math.exp(0.7851*V))</span><br><span class="line">    ann = 0.01*(V+60)/(1-math.exp(-(V+60)/2.8))</span><br><span class="line">    bnn = 0.05*math.exp(-V/80.4)</span><br><span class="line">    <span class="keyword">if</span> i==1:</span><br><span class="line">        n1 = an/(an+bn)</span><br><span class="line">        m1 = 0 </span><br><span class="line">        h1 = 1</span><br><span class="line">        s1 = AS/(AS+bs)</span><br><span class="line">        k1 = ak/(ak+bk) </span><br><span class="line">        nn1 = ann/(ann+bnn)</span><br><span class="line">  </span><br><span class="line">    N = n1</span><br><span class="line">    M = m1</span><br><span class="line">    H = h1</span><br><span class="line">    S = s1  </span><br><span class="line">    NN = nn1</span><br><span class="line">    gK = GK*N*N</span><br><span class="line">    gCl = GCl*M*M*H</span><br><span class="line">    gCl_slow = GCl_slow*S; </span><br><span class="line">    <span class="comment"># gKN=GK*NN*NN;% 复极化电导</span></span><br><span class="line">    gKN=40*NN*NN <span class="comment"># 最大电导40可调整，调大后，在较大的刺激下也可出现正常的波形</span></span><br><span class="line">    gH = GH/(1+math.exp((65.53+V)/112.2))</span><br><span class="line">    IH = gH*(V+231.8)</span><br><span class="line"></span><br><span class="line">    Ik = gK*(V+53)</span><br><span class="line">    ICl = gCl*(V-13.6)  <span class="comment"># ICl=gCl*(V+23.6);</span></span><br><span class="line">    ICl_slow = gCl_slow*(V-37.8)</span><br><span class="line">    IKN = gKN*(V+115) <span class="comment">#  IKN=gKN*(V+118);</span></span><br><span class="line">    K = k1  <span class="comment"># 内向K电流</span></span><br><span class="line">    gKin =GKin*K </span><br><span class="line">    Ikin = gKin*(V+75) </span><br><span class="line">    kdot = (ak*(1-K)-bk*K)*DT</span><br><span class="line">    k2=k1+kdot</span><br><span class="line">    </span><br><span class="line">    ndot = (an*(1-N)-bn*N)*DT</span><br><span class="line">    nndot = (ann*(1-NN)-bnn*NN)*DT</span><br><span class="line">    <span class="comment"># IT=Ik+ICl+ICl_slow+Ikin+Ib+IH;</span></span><br><span class="line">    IT=Ik+ICl+ICl_slow+IKN+Ikin+Ib+IH</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">#     if t[i]&lt;800          %光刺激</span></span><br><span class="line"><span class="comment">#         Ilight=71*(1-math.exp(-t[i]/82))^3;</span></span><br><span class="line"><span class="comment">#     else</span></span><br><span class="line"><span class="comment">#         Ilight=71*math.exp(-(t[i]-800)/56);</span></span><br><span class="line"><span class="comment">#         #if rem(t[i],20)==0</span></span><br><span class="line"><span class="comment">#             #v1</span></span><br><span class="line"><span class="comment">#         #end</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment">#     vdot=((Ilight-IT)/Cm)*DT;</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> t[i]&lt;100:    <span class="comment">#温度、恒流电刺激</span></span><br><span class="line">        vdot = ((I-IT)/Cm)*DT</span><br><span class="line">    <span class="comment">#    vdot=(-(Itemperature+IT)/Cm)*DT;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        vdot = (-IT/Cm)*DT</span><br><span class="line">    </span><br><span class="line">       </span><br><span class="line">    v2 = v1+vdot</span><br><span class="line">    mdot = (am*(1-M)-bm*M)*DT</span><br><span class="line">    n2 = n1+ndot</span><br><span class="line">    m2 = m1+mdot</span><br><span class="line">    sdot =(AS*(1-S)-bs*S)*DT</span><br><span class="line">    s2 = s1+sdot</span><br><span class="line">    nn2 = nn1+nndot</span><br><span class="line">    <span class="keyword">if</span> V&lt;-20:</span><br><span class="line">        h2=1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hdot = (ah*(1-H)-bh*H)*DT</span><br><span class="line">        h2=h1+hdot </span><br><span class="line">    </span><br><span class="line">    <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">    if t[i]%0.01==0:</span></span><br><span class="line"><span class="string">        result.append([t[i],v1])</span></span><br><span class="line"><span class="string">    '</span><span class="string">''</span>    </span><br><span class="line">    </span><br><span class="line">    result.append([t[i],v1])    </span><br><span class="line">result = np.array(result)</span><br><span class="line">plt.plot(result[:,0],result[:,1],c=<span class="string">'b'</span>)</span><br><span class="line"><span class="comment">#plt.plot(result[:,0],result[:,2],'r-');  #仿真Ca离子浓度随时间的变化关系</span></span><br><span class="line">plt.xlabel(<span class="string">'时间(s)'</span>,fontproperties=<span class="string">'SimHei'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'膜电位(mV)'</span>,fontproperties=<span class="string">'SimHei'</span>)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>seq2seq优化思路</title>
    <url>/2019/09/25/seq2seq%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>问题：<br>    1. 程序添加测试集对模型进行离线验证，加上评价指标rmse<br>        上次写的测试部分，数据来自训练集。<br>    2. 添加网格搜索和交叉验证</p>
<h3 id="RMSE函数"><a href="#RMSE函数" class="headerlink" title="RMSE函数"></a>RMSE函数</h3><p>‘’’<br>from sklearn.metrics import mean_squared_error<br>import numpy as np<br>import sklearn.metrics as sm</p>
<p>def rmse(y_true, y_pred):<br>    return np.sqrt(mean_squared_error(y_true, y_pred))</p>
<p>‘’’</p>
<h3 id="需要搜索的参数："><a href="#需要搜索的参数：" class="headerlink" title="需要搜索的参数："></a>需要搜索的参数：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">batch_size = 5  # Low value used for live demo purposes - 100 and 1000 would be possible too, crank that up!</span><br><span class="line">hidden_dim = 12  # Count of hidden neurons in the recurrent units.</span><br><span class="line">layers_stacked_count = 2  # Number of stacked recurrent cells, on the neural depth axis.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">learning_rate = 0.007  # Small lr helps not to diverge during training.</span><br><span class="line">nb_iters = 300  # How many times we perform a training step (therefore how many times we show a batch).</span><br><span class="line">lr_decay = 0.92  # default: 0.9 . Simulated annealing.</span><br><span class="line">momentum = 0.5  # default: 0.0 . Momentum technique in weights update</span><br><span class="line">lambda_l2_reg = 0.003  # L2 regularization of weights - avoids overfitting</span><br></pre></td></tr></table></figure>

<h3 id="交叉验证资料"><a href="#交叉验证资料" class="headerlink" title="交叉验证资料"></a>交叉验证资料</h3><h4 id="k可不可以放到网格搜索里面呢？"><a href="#k可不可以放到网格搜索里面呢？" class="headerlink" title="k可不可以放到网格搜索里面呢？"></a>k可不可以放到网格搜索里面呢？</h4><p><a href="https://zhuanlan.zhihu.com/p/24825503" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24825503</a></p>
]]></content>
  </entry>
  <entry>
    <title>m_tm_h_th计算</title>
    <url>/2019/09/22/m-tm-h-th%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>需要数据</p>
<p>电压(mv)   -56            -36            -16            4            24            44            64<br>时间(ms) 电导（nS）         电导（nS）       电导（nS）    电导（nS）    电导（nS）    电导（nS）    电导（nS）<br>0.92  0.641966251    0.90082361    1.509488212    4.654255319    16.16202946    15.537514    22.62749071<br>2.5   2.29273661    6.391557996    15.09488212    24.60106383    26.59574468    27.4356103    28.70651807<br>5     4.524333578    12.05387783    22.21104083    26.59574468    26.39116203    28.62541993    28.49544073<br>7.5   6.572511617    15.87165408    23.00172513    25.48758865    24.75450082    27.4356103    27.86220871<br>10    8.192712155    18.44543583    22.28292122    23.93617021    24.34533552    26.59574468    27.44005404<br>15    10.60772805    20.63315031    20.91719379    21.05496454    22.50409165    25.05599104    26.63796015<br>20    12.71704573    21.01921757    19.91086832    17.95212766    20.45826514    23.65621501    26.17359<br>30    14.67351431    21.01921757    18.68890167    15.95744681    18.20785597    21.90649496    25.32928065<br>40    16.20200538    21.44818119    17.53881541    15.29255319    16.16202946    20.99664054    24.8649105<br>50    17.02739056    21.44818119    18.25761932    15.29255319    15.54828151    20.64669653    24.48497129<br>60    17.11910002    21.44818119    18.25761932    15.29255319    15.34369885    20.29675252    24.10503208</p>
]]></content>
  </entry>
  <entry>
    <title>Hodgkin-Huxley-2</title>
    <url>/2019/09/18/Hodgkin-Huxley-2/</url>
    <content><![CDATA[<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><pre><code>该技术是由电压钳（voltageclamp）发展而来的，电压钳技术由Cole和Marment设计，后经Hodgkin和Huxley改进并成功地应用于神经纤维动作电位的研究 
 。其设计原理是根据离子作跨膜移动时形成了跨膜离子电流（I），而通透性即离子通过膜的难易程度，其膜电阻（R）的倒数，也就是膜电导（G）。因此，膜对某种离子通透性增大时，实际上时膜电阻变小，即膜对该离子的电导加大。根据欧姆定律U=IR，即I=U/R=UG，

问题：膜电导是膜电阻的倒数？</code></pre>]]></content>
  </entry>
  <entry>
    <title>Flask</title>
    <url>/2019/09/07/flask/</url>
    <content><![CDATA[<p>现在是对固定的文件完成分类，可以返回分类结果。</p>
<p>但是无法自定义输入进行分类，</p>
<p>前端读取数据<br>发送到flask接口</p>
<p>现在问题是对flask框架不熟悉</p>
]]></content>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>数学模型构建</title>
    <url>/2019/09/07/flask%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="保卫细胞电信号数学模型的构建"><a href="#保卫细胞电信号数学模型的构建" class="headerlink" title="保卫细胞电信号数学模型的构建"></a>保卫细胞电信号数学模型的构建</h3><p>根据保卫细胞膜电路模型</p>
<p>Hodgkin-Huxley 和Goldman-Hodgkin-Katz 两个方程，都是Nernst方程的推广</p>
<h2 id="电流是电荷对时间的导数"><a href="#电流是电荷对时间的导数" class="headerlink" title="电流是电荷对时间的导数"></a>电流是电荷对时间的导数</h2>]]></content>
      <tags>
        <tag>神经科学</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask</title>
    <url>/2019/09/07/nginx%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>我要对输入的序列进行</p>
<pre><code>--- 维度扩展 
    x_test_1 = np.expand_dims(x_test[12], axis=0)


--- PCA降维
    pca = PCA(n_components=5,copy=True) 
    newX = pca.fit_transform(x)</code></pre><p>报错提示：在post给的内容没有在excle中找到</p>
<p>是程序逻辑的问题，需要在看下flask</p>
<p>src文件夹内的文件结构如下：</p>
<p>├── App.vue<br>├── assets<br>│   └── logo.png<br>├── components<br>│   └── HelloWorld.vue<br>├── main.js<br>├── router.js<br>└── views<br>    ├── About.vue<br>    └── Home.vue<br>详解：</p>
<p>main.js app入口点，它与根组件一起加载和初始化Vue。<br>app.vue 根组件，它是开始渲染所有其他组件时的起点。<br>‘components’ 存储UI组件<br>router.js 定义URL并将URL映射到对应的组件<br>‘views’ 存储绑定到路由器的UI组件<br>‘asset’ 存储静态资源，如图像和字体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">from flask import Flask, jsonify</span><br><span class="line">from flask_cors import CORS</span><br><span class="line">import pandas as pd</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.naive_bayes import GaussianNB</span><br><span class="line">from sklearn.decomposition import PCA</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># configuration</span></span><br><span class="line">DEBUG = True</span><br><span class="line"></span><br><span class="line"><span class="comment"># instantiate the app</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.from_object(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable CORS</span></span><br><span class="line">CORS(app, resources=&#123;r<span class="string">'/*'</span>: &#123;<span class="string">'origins'</span>: <span class="string">'*'</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># sanity check route</span></span><br><span class="line">@app.route(<span class="string">'/ping'</span>, methods=[<span class="string">'GET'</span>])</span><br><span class="line">def ping_pong():</span><br><span class="line">    <span class="built_in">return</span> jsonify(<span class="string">'pong!,hhh'</span>)</span><br><span class="line"></span><br><span class="line">def Bayes():</span><br><span class="line">    df = pd.read_excel(<span class="string">'./Data.xls'</span>)</span><br><span class="line">    df_T=df.T</span><br><span class="line">    x=df_T.iloc[:,0:1764]</span><br><span class="line">    y1 = df_T.iloc[0:26,1764:1765]     <span class="comment">#1 类的类别</span></span><br><span class="line">    y2 = df_T.iloc[26:59,1764:1765]   <span class="comment">#2 类的类别</span></span><br><span class="line">    pca = PCA(n_components=5,copy=True)</span><br><span class="line">    newX = pca.fit_transform(x)</span><br><span class="line">    <span class="comment">#  拆分</span></span><br><span class="line">    newX1 = newX[0:26,:]</span><br><span class="line">    newX2 = newX[26:59,:]</span><br><span class="line">    x_train1,x_test1,y_train1,y_test1 = train_test_split(newX1,y1,test_size=0.2,random_state=5)</span><br><span class="line">    x_train2,x_test2,y_train2,y_test2 = train_test_split(newX2,y2,test_size=0.2,random_state=5)</span><br><span class="line">    x_train = np.vstack((x_train1 , x_train2))</span><br><span class="line">    x_test = np.vstack((x_test1 , x_test2))</span><br><span class="line">    y_train = np.vstack((y_train1 , y_train2))</span><br><span class="line">    y_test = np.vstack((y_test1 , y_test2))</span><br><span class="line">    <span class="built_in">print</span>(x_test[1])</span><br><span class="line">    gnb = GaussianNB()</span><br><span class="line">    gnb = gnb.fit(x_train,y_train)</span><br><span class="line">    <span class="built_in">return</span> gnb</span><br><span class="line"></span><br><span class="line">def pretreatment(list1):</span><br><span class="line">    array = np.array(list1)</span><br><span class="line">    <span class="built_in">return</span> np.expand_dims(array, axis=0)</span><br><span class="line"></span><br><span class="line">@app.route(<span class="string">'/predict'</span>, methods=[<span class="string">'GET'</span>])</span><br><span class="line">def main():</span><br><span class="line">    gnb = Bayes()</span><br><span class="line">    predict = gnb.predict(pretreatment([2187.82169246, 153.58047602, -124.83874381, -339.65293843, -5.28906774]))</span><br><span class="line">    value = int(predict[0])</span><br><span class="line">    <span class="built_in">return</span> jsonify(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>docker创建MySQl容器</title>
    <url>/2019/08/29/Docker+MySQL/</url>
    <content><![CDATA[<p>1、使用Docker 创建Mysql。用idea在运行 Springboot+VUE的项目</p>
<p>MySql使用的配置文件：</p>
<pre><code class="bash"></code></pre>
<p>简单的使用Docker-compose.yaml 文件配置容器。</p>
<p>2、后端的Get Post方法 </p>
<p>Vue是如何发送请求的</p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker创建MySQl容器</title>
    <url>/2019/08/29/MyPlant%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>启动mysql的dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  hk-mysql:</span><br><span class="line">   container_name: hk-mysql</span><br><span class="line">   image: mysql/mysql-server:5.7</span><br><span class="line">   environment:</span><br><span class="line">    MYSQL_DATABASE: testdb</span><br><span class="line">    MYSQL_ROOT_PASSWORD: hellokoding</span><br><span class="line">    MYSQL_ROOT_HOST: <span class="string">'%'</span></span><br><span class="line">   ports:</span><br><span class="line">   - <span class="string">"3306:3306"</span></span><br><span class="line">   restart: always</span><br></pre></td></tr></table></figure>

<p>启动hbase</p>
<p>docker run -d -h myhbase -p 2181:2181 -p 8080:8080 -p 8085:8085 -p 9090:9090 -p 9095:9095 -p 16000:16000 -p 16010:16010 -p 16201:16201 -p 16301:16301 –name hbase1.3 harisekhon/hbase –net=host</p>
<p>参考 <a href="https://github.com/tanwenliang/spring-boot-hbase-example" target="_blank" rel="noopener">https://github.com/tanwenliang/spring-boot-hbase-example</a></p>
<p>这样启动的话没有nginx，每个单独的容器是相互分离的。</p>
<h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><h4 id="这一块的问题属于运维的，无需太关心这个问题。"><a href="#这一块的问题属于运维的，无需太关心这个问题。" class="headerlink" title="这一块的问题属于运维的，无需太关心这个问题。"></a>这一块的问题属于运维的，无需太关心这个问题。</h4><p>hbase容器启动后，ip地址无法ping通<br>导致springboot无法连接 hbase，控制台提示错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">: Opening socket connection to server localhost/127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)</span><br><span class="line">2019-09-04 13:32:37.240  INFO 57045 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Socket connection established to localhost/127.0.0.1:2181, initiating session</span><br><span class="line">2019-09-04 13:32:37.254  INFO 57045 --- [localhost:2181)] org.apache.zookeeper.ClientCnxn          : Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x16cfab6764d0007, negotiated timeout = 90000</span><br><span class="line">2019-09-04 13:32:38.099  INFO 57045 --- [  restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Ma</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2019-09-04 13:42:32.376  INFO 57045 --- [ared--pool2-t10] o.a.h.hbase.client.RpcRetryingCaller     : Call exception, tries=10, retries=35, started=38320 ms ago, cancelled=<span class="literal">false</span>, msg=Connection refused row <span class="string">'h_file,1000000000000000,99999999999999'</span> on table <span class="string">'hbase:meta'</span> at region=hbase:meta,,1.1588230740, hostname=myhbase,16020,1567574361014, seqNum=0</span><br><span class="line">2019-09-04 13:42:42.388  INFO 57045 --- [ared--pool2-t10] o.a.h.hbase.client.RpcRetryingCaller     : Call exception, tries=11, retries=35, started=48332 ms ago, cancelled=<span class="literal">false</span>, msg=Connection refused row <span class="string">'h_file,1000000000000000,99999999999999'</span> on table <span class="string">'hbase:meta'</span> at region=hbase:meta,,1.1588230740, hostname=myhbase,16020,1567574361014, seqNum=0</span><br><span class="line">2019-09-04 13:43:30.859  INFO 57045 --- [ared--pool2-t11] o.a.h.hbase.client.RpcRetryingCaller     : Call exception, tries=10, retries=35, started=38399 ms ago, cancelled=<span class="literal">false</span>, msg=Connection refused row <span class="string">'h_file,1000000000000000,99999999999999'</span> on table <span class="string">'hbase:meta'</span> at region=hbase:meta,,1.1588230740, hostname=myhbase,16020,1567574361014, seqNum=0</span><br><span class="line">2019-09-04 13:43:40.930  INFO 57045 --- [ared--pool2-t11] o.a.h.hbase.client.RpcRetryingCaller     : Call exception, tries=11, retries=35, started=48470 ms ago, cancelled=<span class="literal">false</span>, msg=Connection refused row <span class="string">'h_file,1000000000000000,99999999999999'</span> on table <span class="string">'hbase:meta'</span> at region=hbase:meta,,1.1588230740, hostname=myhbase,16020,1567574361014, seqNum=0</span><br><span class="line">2019-09-04 13:44:29.359  INFO 57045 --- [ared--pool2-t12] o.a.h.hbase.client.RpcRetryingCaller     : Call exception, tries=10, retries=35, started=38405 ms ago, cancelled=<span class="literal">false</span>, msg=Connection refused row <span class="string">'h_file,1000000000000000,99999999999999'</span> on table <span class="string">'hbase:meta'</span> at region=hbase:meta,,1.1588230740, hostname=myhbase,16020,1567574361014, seqNum=0</span><br><span class="line">2019-09-04 13:44:39.461  INFO 57045 --- [ared--pool2-t12] o.a.h.hbase.client.RpcRetryingCaller     : Call exception, tries=11, retries=35, started=48507 ms ago, cancelled=<span class="literal">false</span>, msg=Connection refused row <span class="string">'h_file,1000000000000000,99999999999999'</span> on table <span class="string">'hbase:meta'</span> at region=hbase:meta,,1.1588230740, hostname=myhbase,16020,1567574361014, seqNum=0</span><br><span class="line">2019-09-04 13:45:38.022  INFO 57045 --- [ared--pool2-t13] o.a.h.hbase.client.RpcRetryingCaller     : Call exception, tries=10, retries=35, started=38380 ms ago, cancelled=<span class="literal">false</span>, msg=Connection refused row <span class="string">'h_file,1000000000000000,99999999999999'</span> on table <span class="string">'hbase:meta'</span> at region=hbase:meta,,1.1588230740, hostname=myhbase,16020,1567574361014, seqNum=0</span><br></pre></td></tr></table></figure>

<p>正确的hbase配置</p>
<p>package com.example.config;</p>
<p>import org.apache.hadoop.conf.Configuration;<br>import org.apache.hadoop.hbase.<em>;
import org.apache.hadoop.hbase.client.</em>;
import org.apache.hadoop.hbase.filter.*;<br>import org.apache.hadoop.hbase.util.Bytes;<br>import org.springframework.context.annotation.Bean;</p>
<p>import java.io.IOException;</p>
<p>/**</p>
<ul>
<li><p>@author allen</p>
</li>
<li><p>/
@org.springframework.context.annotation.Configuration<br>public class Hbase {<br>  @Bean<br>  public Connection getHbaseConnect() throws IOException {</p>
<pre><code>Configuration conf = HBaseConfiguration.create();
conf.set(&quot;hbase.zookeeper.quorum&quot;, &quot;myhbase&quot;);
conf.set(&quot;hbase.zookeeper.property.clientPort&quot;, &quot;2181&quot;);
conf.set(&quot;log4j.logger.org.apache.hadoop.hbase&quot;, &quot;WARN&quot;);
Connection connection = ConnectionFactory.createConnection(conf);
return connection;</code></pre><p>  }</p>
<p>  @Bean<br>  public Admin getHbaseAdmin(Connection connection) throws IOException{</p>
<pre><code>Admin admin = connection.getAdmin();
return admin;</code></pre><p>  }</p>
</li>
</ul>
<p>}</p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记</title>
    <url>/2019/08/29/Vue%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>.js ES6 webpack Npm</p>
<p>v-for=”item in list” # 遍历list里面的数据，放到item</p>
<p>绑定事件 v-on:click=””</p>
<p>v-model 数据的双向绑定<br>v-on 监听事件<br>v-bind的简写是 ：</p>
<p>通过input框里的内容，放到页面里面显示。</p>
<p>MVVM格式。</p>
<p>mpv模式</p>
<p>model 数据<br>presenter 呈现层<br>view 视图层</p>
<p>Vue.component(“”) 创建一个全局组件</p>
<p>子组件 向副组件 传值</p>
<h3 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h3><p>Vue 生命周期<br>生命周期函数就是vue实例在某一个时间点会自动执行的函数</p>
<p>####模版语法<br>   v-text  v-html</p>
<p>js表达式</p>
<p>####计算属性，方法和监听</p>
<p>计算属性：<br>    computed:{<br>        fullname:function(){</p>
<pre><code>        }
}</code></pre>]]></content>
      <tags>
        <tag>Vue2.5</tag>
      </tags>
  </entry>
  <entry>
    <title>docker搭建Hbase</title>
    <url>/2019/08/28/docker%E6%90%AD%E5%BB%BAHbase/</url>
    <content><![CDATA[<h2 id="单机配置Hbase"><a href="#单机配置Hbase" class="headerlink" title="单机配置Hbase"></a>单机配置Hbase</h2><p>###下载并运行镜像###<br>我已经备好集成了HBase单机版的镜像，可以执行以下命令下载到本地：</p>
<p>docker pull bolingcavalry/centos7-hbase126-standalone:0.0.1</p>
<p>###运行容器###</p>
<p>执行以下命令可以用刚刚下载的镜像创建一个容器，容器名称hbase001，60010端口映射到本机：</p>
<p>docker run –name=hbase001 -p 60010:60010 -idt bolingcavalry/centos7-hbase126-standalone:0.0.1</p>
<p>###进入容器###<br>执行以下命令，可以进入hbase001容器：</p>
<p>docker exec -it hbase001 /bin/bash</p>
<p>###启动HBase服务###<br>进入hbase001容器后，输入以下命令就能启动hbase服务：</p>
<p>/usr/local/work/hbase/bin/start-hbase.sh</p>
<p>###进入HBase命令行###<br>执行以下命令，可以进入HBase的命令行模式：</p>
<p>hbase shell</p>
<h1 id="记录今天的操作"><a href="#记录今天的操作" class="headerlink" title="记录今天的操作"></a>记录今天的操作</h1><h2 id="docker启动springboot-Docker-NGINX-MySQL"><a href="#docker启动springboot-Docker-NGINX-MySQL" class="headerlink" title="docker启动springboot+Docker+NGINX+MySQL"></a>docker启动springboot+Docker+NGINX+MySQL</h2><p>启动的目录<br>/Users/squareface/IdeaProjects/dockercompose-springboot-mysql-nginx</p>
<p>docker-compose.yaml 文件内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  hk-nginx:</span><br><span class="line">   container_name: hk-nginx</span><br><span class="line">   image: nginx:1.13</span><br><span class="line">   restart: always</span><br><span class="line">   ports:</span><br><span class="line">   - 80:80</span><br><span class="line">   - 443:443</span><br><span class="line">   volumes:</span><br><span class="line">   - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">   depends_on:</span><br><span class="line">   - app</span><br><span class="line"> </span><br><span class="line">  hk-mysql:</span><br><span class="line">   container_name: hk-mysql</span><br><span class="line">   image: mysql/mysql-server:5.7</span><br><span class="line">   environment:</span><br><span class="line">    MYSQL_DATABASE: <span class="built_in">test</span></span><br><span class="line">    MYSQL_ROOT_PASSWORD: hellokoding</span><br><span class="line">    MYSQL_ROOT_HOST: <span class="string">'%'</span></span><br><span class="line">   ports:</span><br><span class="line">   - <span class="string">"3306:3306"</span></span><br><span class="line">   restart: always</span><br><span class="line">  </span><br><span class="line">  app:</span><br><span class="line">    restart: always</span><br><span class="line">    build: ./app</span><br><span class="line">    working_dir: /app</span><br><span class="line">    volumes:</span><br><span class="line">      - ./app:/app</span><br><span class="line">      - ~/.m2:/root/.m2</span><br><span class="line">    expose:</span><br><span class="line">      - <span class="string">"8080"</span></span><br><span class="line">    <span class="built_in">command</span>: mvn clean spring-boot:run</span><br><span class="line">    depends_on:</span><br><span class="line">      - hk-mysql</span><br></pre></td></tr></table></figure>

<p>执行docker-compose up 指令，自动启动项目。就多出4个images<br>mysql<br>maven<br>nginx<br>dockercompose-springboot-mysql-nginx_app</p>
<h3 id="SpringBoot和NGINX的配置在项目的哪里有写？"><a href="#SpringBoot和NGINX的配置在项目的哪里有写？" class="headerlink" title="SpringBoot和NGINX的配置在项目的哪里有写？"></a>SpringBoot和NGINX的配置在项目的哪里有写？</h3><p>NGINX 反向代理 监听一个端口，进行转发。</p>
<h2 id="docker-搭建Hbase完全分布式"><a href="#docker-搭建Hbase完全分布式" class="headerlink" title="docker 搭建Hbase完全分布式"></a>docker 搭建Hbase完全分布式</h2><p>使用的images： bolingcavalry/centos6.7-jdk1.8-ssh:0.0.1</p>
<p>1、 运行下列docker-compose.yaml文件，会创建三个容器。名字分别为master、slave1、slave2、</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">'2'</span></span><br><span class="line">services:</span><br><span class="line">  master: </span><br><span class="line">    image: bolingcavalry/centos6.7-jdk1.8-ssh:0.0.1</span><br><span class="line">    container_name: master</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"19010:22"</span></span><br><span class="line">      - <span class="string">"50070:50070"</span></span><br><span class="line">      - <span class="string">"8088:8088"</span></span><br><span class="line">      - <span class="string">"16010:16010"</span></span><br><span class="line">    restart: always</span><br><span class="line">  slave1: </span><br><span class="line">    image: bolingcavalry/centos6.7-jdk1.8-ssh:0.0.1</span><br><span class="line">    container_name: slave1</span><br><span class="line">    depends_on:</span><br><span class="line">      - master</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"19011:22"</span></span><br><span class="line">    restart: always</span><br><span class="line">  slave2: </span><br><span class="line">    image: bolingcavalry/centos6.7-jdk1.8-ssh:0.0.1</span><br><span class="line">    container_name: slave2</span><br><span class="line">    depends_on:</span><br><span class="line">      - slave1</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"19012:22"</span></span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>

<p>查询容器的ip地址：<br>master 172.19.0.2<br>slave1 172.19.0.3<br>slave2 172.19.0.4</p>
<p>CONTAINER ID        IMAGE                                      COMMAND                  CREATED             STATUS              PORTS                                                                                               NAMES<br>32481e89f8f8        bolingcavalry/centos6.7-jdk1.8-ssh:0.0.1   “/bin/sh -c ‘service…”   12 minutes ago      Up 12 minutes       8088/tcp, 16010/tcp, 50070/tcp, 0.0.0.0:19012-&gt;22/tcp                                               slave2<br>2c3c9dd989ad        bolingcavalry/centos6.7-jdk1.8-ssh:0.0.1   “/bin/sh -c ‘service…”   12 minutes ago      Up 12 minutes       8088/tcp, 16010/tcp, 50070/tcp, 0.0.0.0:19011-&gt;22/tcp                                               slave1<br>bcd27e44e3d6        bolingcavalry/centos6.7-jdk1.8-ssh:0.0.1   “/bin/sh -c ‘service…”   12 minutes ago      Up 12 minutes       0.0.0.0:8088-&gt;8088/tcp, 0.0.0.0:16010-&gt;16010/tcp, 0.0.0.0:50070-&gt;50070/tcp, 0.0.0.0:19010-&gt;22/tcp   master</p>
<p>2、###配置hostname和hosts###</p>
<p>修改master的/etc/sysconfig/network文件，将原有的HOSTNAME=localhost.localdomain改成HOSTNAME=master，对slave1和slave2也做修改，将HOSTNAME分别改成slave1和slave2；<br>分别修改master、slave1、slave2的/etc/hosts文件，都添加相同的内容如下：<br>172.19.0.2 master<br>172.19.0.3 slave1<br>172.19.0.4 slave2</p>
<p>3 ###master、slave1、slave2之间配置相互免密码登录###</p>
<p>– 分别修改master、slave1、slave2的/etc/ssh/sshd_config文件，找到下列内容，删除每行的注释符号”#”：<br>RSAAuthentication yes<br>PubkeyAuthentication yes</p>
<p>– 分别在master、slave1、slave2上执行命令ssh-keygen -t rsa，一路回车下去，最终会在/root/.ssh目录下生成rsa文件</p>
<p>– 在master上执行如下三行命令，执行完毕后，三个容器的rsa公钥都存在/root/.ssh/authorized_keys文件中了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub&gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">ssh root@slave1 cat ~/.ssh/id_rsa.pub&gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">ssh root@slave2 cat ~/.ssh/id_rsa.pub&gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>第一行命令将master的公钥写入authorized_keys，第二、第三行分别ssh登录slave1、slave2，将他们的公钥写入到master的authorized_keys文件中，由于是ssh登录，需要输入密码，这里是”password”</p>
<p>– 分别在slave1、slave2上执行以下命令，将master上的authorized_keys文件复制过来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@master cat ~/.ssh/authorized_keys&gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>由于master的authorized_keys中包含了slave1、slave2的rsa公钥，所以在slave1和slave2上执行以上命令的时候是不需要登录的；</p>
<p>现在三个容器的公钥都已经放在每一个容器上了，它们相互之间可以免密码登录了，例如在slave1上执行ssh root@slave2即可登录到slave2而不用输入密码</p>
<p>4 ######在容器上创建所需目录###<br>分别在master、slave1、slave2上创建以下目录：</p>
<p>/usr/local/work<br>/opt/hbase</p>
<p>###安装zookeeper-3.4.6集群###</p>
<p>去zookeeper官网下载zookeeper-3.4.6.tar.gz，然后解压到当前电脑；<br>在zookeeper-3.4.6/conf/目录下创建zoo.cfg文件，内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/work/zkdata</span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to "0" to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"></span><br><span class="line">server.1=master:2887:3887  </span><br><span class="line">server.2=slave1:2888:3888 </span><br><span class="line">server.3=slave2:2889:3889</span><br></pre></td></tr></table></figure>

<p>其实也就是修改了dataDir的值，还有最后三行是新增的，其他内容都是从zoo_sample.cfg复制过来的；</p>
<ol start="3">
<li>在当前电脑上，用ssh工具执行以下三行命令，将前面解压的并且已经修改了zoo.cfg文件的zookeeper-3.4.6目录复制到master、slave1、slave2上去：</li>
</ol>
<p>scp -P 19010 -r ./zookeeper-3.4.6 root@localhost:/usr/local/work<br>scp -P 19011 -r ./zookeeper-3.4.6 root@localhost:/usr/local/work<br>scp -P 19012 -r ./zookeeper-3.4.6 root@localhost:/usr/local/work</p>
<p>执行每行命令都要输入密码”password”</p>
<ol start="4">
<li>在master、slave1、slave2上创建目录/usr/local/work/zkdata，在该目录下创建文件myid，文件内容分别是是”1”、“2”、“3”；</li>
<li>在master、slave1、slave2上依次执行启动zookeeper的命令/usr/local/work/zookeeper-3.4.6/bin/zkServer.sh start；</li>
<li>在每个容器上分别执行以下命令可以检查zookeeper的集群状态：</li>
</ol>
<p>###启动zookeeper。error<br>出现好多奇奇怪怪的问题！！！</p>
<p>删掉 /usr/local/work   /opt/hbase  重新来一遍</p>
]]></content>
      <tags>
        <tag>Docker Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot(3)</title>
    <url>/2019/08/27/SpringBoot-3/</url>
    <content><![CDATA[<p>application.yml 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081  <span class="comment"># 修改SpringBoot启动的端口</span></span><br><span class="line">  context-path: /girl <span class="comment">#修改启动路径</span></span><br></pre></td></tr></table></figure>

<p>2、 把配置文件注入到controller里面变量。</p>
<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p>控制器的使用，主要是用来接收客户端的请求<br>@Controller 处理http请求，不添加这个注解，浏览器无法访问到<br>@Restcontroller  原来返回json需要@ResponseBody配合@Controller<br>@RequsetMapping 配置url映射<br>@PathVariable 获取url中的数据<br>@RequestParam 获取请求参数的值<br>@GetMapping 组合注解</p>
<p>后端提供result接口和返回json格式给前端。</p>
<h3 id="Spring-Data-Jpa"><a href="#Spring-Data-Jpa" class="headerlink" title="Spring-Data-Jpa"></a>Spring-Data-Jpa</h3><p>JPA(Java Persistence API)定义了一系列对象持久化的标准，目前实现这一规范的产品有Hibernate, TopLink</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: create  <span class="comment"># 运行时候自动创建表,create会清空表内之前的内容，update会保留表内原有的数据</span></span><br><span class="line">    show-sql: <span class="literal">true</span> <span class="comment"># 控制台看到sql语句</span></span><br></pre></td></tr></table></figure>

<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>首先定义一个interface 继承 JpaRepository。<br>在创建一个controller类，在controller里面 实现api</p>
<h4 id="更新数据库："><a href="#更新数据库：" class="headerlink" title="更新数据库："></a>更新数据库：</h4><p>有两种方法<br>    1、 new一个对象出来，重新赋值<br>    2、 通过id find这个条目，在重新赋值。</p>
<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>数据库操作<br>作为单个逻辑工作单元执行的一系列操作，要么完全执行，要么完全不执行</p>
<p>只有在查询的时候不需要添加事务管理，添加一个注解 ：@Transactional</p>
<h3 id="Spring-Boot-Web-进阶"><a href="#Spring-Boot-Web-进阶" class="headerlink" title="Spring Boot Web 进阶"></a>Spring Boot Web 进阶</h3><p>@Valid 表单验证</p>
<p>AOP<br>记录每次请求</p>
<p>统一异常处理</p>
<p>test</p>
<h3 id="添加一条数据的时候进行筛选"><a href="#添加一条数据的时候进行筛选" class="headerlink" title="添加一条数据的时候进行筛选"></a>添加一条数据的时候进行筛选</h3><p>1 需要在girl 类 里 添加条件。<br>2 controller</p>
<p>AOP 处理统一处理请求日志<br>编程范式 设计思想 和语言无关</p>
<p>使用日志可以记录程序的具体参数，</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot笔记(2)</title>
    <url>/2019/08/25/springboot%E7%AC%94%E8%AE%B0(2)/</url>
    <content><![CDATA[<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>1 在DAO层<br> 创建数据表映射过来的class的时候，可以添加一个构造方法，这样在做测试的时候可以不需要new一个实例再去进行赋值。</p>
<p>2 在 pol.xml中引入jpa和mysql依赖，可以实现对数据库的操作<br>注：把maven的下载源，替换成阿里云。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">	 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	 &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">3 PlantES的数据存储在Hbase和MySQL里，MySQL里存放 用户的信息和展示的数据的。原始的数据放在Hbase里，最后聚合在一起会放在mysql里。</span><br></pre></td></tr></table></figure>

<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>v-on：绑定一个事件 @ 缩写<br>    通过buttun，设定一个click事件，这个事件会触发一个方法。</p>
<p>计算属性</p>
<p>侦听属性</p>
<p>条件渲染<br>    V-if<br>    V-for</p>
<p>列表渲染</p>
<p>Class与Style绑定</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>网站部署</title>
    <url>/2019/08/24/web%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="人人网开源的网站"><a href="#人人网开源的网站" class="headerlink" title="人人网开源的网站"></a>人人网开源的网站</h2><p>项目部署到集群，可以实现三高：<br>高性能<br>高负载<br>高可用</p>
<p>这的就需要Docker虚拟机来部署，同一服务会同时运行在多个容器里。</p>
<p>这是一个企业级部署的实战，可以学习一下。</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot笔记</title>
    <url>/2019/08/23/SpringBoot%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Java 1.8.0<br>mvn 3.3.9</p>
<p>通过一个项目对SpringBoot和VUE进行复习。。。</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>train_step()</title>
    <url>/2019/08/21/tf-compat-v2-expand-dims/</url>
    <content><![CDATA[<p>理论好理解，实践起来，里面有很多的知识点需要理解。</p>
<p>train_step()方法的理解</p>
<p>训练的方法其实就是使用定义好的方法，和之前做测试的时候方法类似。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@tf.function</span><br><span class="line">def train_step(inp, targ, encoding_hidden):</span><br><span class="line">    loss = 0</span><br><span class="line">    with tf.GradientTape() as tape:</span><br><span class="line">        encoding_outputs, encoding_hidden = encoder(inp, encoding_hidden)</span><br><span class="line">        decoding_hidden = encoding_hidden</span><br><span class="line"><span class="comment">#         print("-----------------------计算Encoder-------------------------------------------------")</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(0, targ.shape[1] - 1):</span><br><span class="line">            decoding_input = tf.expand_dims(targ[:, t], 1)</span><br><span class="line">            predictions, decoding_hidden, _ = decoder(decoding_input, decoder_hidden, encoding_outputs)</span><br><span class="line">            </span><br><span class="line">            loss += loss_function(targ[:, t+1], predictions) <span class="comment"># targ[:, t+1], 是每一步的预测值。</span></span><br><span class="line"><span class="comment">#             print("-----------------------计算loss-------------------------------------------------")</span></span><br><span class="line">    batch_loss = loss / int(targ.shape[0])</span><br><span class="line">    variables = encoder.trainable_variables + decoder.trainable_variables</span><br><span class="line">    gradients = tape.gradient(loss, variables)</span><br><span class="line">    optimizer.apply_gradients(zip(gradients, variables))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> batch_loss</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mc</tag>
      </tags>
  </entry>
  <entry>
    <title>tf.compat.v2.expand_dims</title>
    <url>/2019/08/20/train_step/</url>
    <content><![CDATA[<p>tf.compat.v2.expand_dims()<br>可以对tensor进行维度扩展。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tf.expand_dims(</span><br><span class="line">    input,</span><br><span class="line">    axis,</span><br><span class="line">    name=None</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我应该在第一个维度进行扩展。<br>原来的维度 (2,588). —-&gt;(1,2,588)</p>
<h3 id="tf-框架需要的数据类型是float32"><a href="#tf-框架需要的数据类型是float32" class="headerlink" title="tf 框架需要的数据类型是float32"></a>tf 框架需要的数据类型是float32</h3><p>调试以后。搭建的模型在测试的时候，可以正常的通过。之前主要是输入的shape不一样。</p>
<h3 id="现在没有办法训练。经过调试以后程序在训练时一直处于decoder。肯定是这的问题。重新理解一下Decoder函数"><a href="#现在没有办法训练。经过调试以后程序在训练时一直处于decoder。肯定是这的问题。重新理解一下Decoder函数" class="headerlink" title="现在没有办法训练。经过调试以后程序在训练时一直处于decoder。肯定是这的问题。重新理解一下Decoder函数"></a>现在没有办法训练。经过调试以后程序在训练时一直处于decoder。肯定是这的问题。重新理解一下Decoder函数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Decoder(keras.Model):<span class="comment">#使用子类API实现</span></span><br><span class="line">    def __init__(self, vocab_size, embedding_units, decoding_units, batch_size):</span><br><span class="line">        super(Decoder, self).__init__()</span><br><span class="line">        self.batch_size = batch_size</span><br><span class="line">        self.decoding_units = decoding_units</span><br><span class="line">        self.embedding = keras.layers.Embedding(vocab_size, embedding_units) <span class="comment"># 每一个单词转换成固定的向量，输出是三维的。</span></span><br><span class="line">        self.gru = keras.layers.GRU(self.decoding_units, return_sequences=True, return_state=True, recurrent_initializer=<span class="string">'glorot_uniform'</span>)</span><br><span class="line">        self.fc = keras.layers.Dense(vocab_size)</span><br><span class="line">        self.attention = BahdanauAttention(self.decoding_units)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    def call(self, x, hidden, encoding_outputs): <span class="comment">#x是decoder中当前步的输入，hidden decoder中当前步的上一步的输出，encoding_outputs encoder中当前步的输出</span></span><br><span class="line">	    <span class="comment"># call 函数可以理解为对构造函数进行初始化。</span></span><br><span class="line">		<span class="comment"># 先计算hidden encoding_outputs 的attention</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># contex_vector.shape=(batch_size, units)</span></span><br><span class="line">        </span><br><span class="line">        context_vector, attention_weights = self.attention(hidden, encoding_outputs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"正在计算Decoder-------------------------------------------------"</span>)</span><br><span class="line">        <span class="built_in">print</span>(tf.shape(x))</span><br><span class="line">        x = self.embedding(x) <span class="comment"># x 需要先进入embedding层， 目的是为了编码。会增加维度。在电信号上是不需要的。我使用的是expand_dim()进行维度的扩展。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把context_vector和x 相加，这样就会携带每一步的输入，</span></span><br><span class="line">        combined_x = tf.concat([tf.expand_dims(context_vector,1),x], axis=-1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这一步就是decoder的返回值，和encode类似，就是outout和hidden</span></span><br><span class="line"><span class="comment">#         output.shape = [batcha_size, 1 , decode_units]</span></span><br><span class="line"><span class="comment">#         state.shape = [batch_size, decode_units ]</span></span><br><span class="line">        output, state = self.gru(combined_x)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里对output进行reshape       </span></span><br><span class="line">        <span class="comment"># reshape后 output.shape=[batch_size, decoder_units]</span></span><br><span class="line">        output = tf.reshape(output, (-1, output.shape[2]))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 输入到全链接层，输出为[batch_size,vocab_sie]</span></span><br><span class="line">        output = self.fc(output)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> output, state, attention_weights</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">decoder = Decoder(output_vocab_size, embedding_units, units, batch_size)</span><br><span class="line"></span><br><span class="line">outputs = decoder(tf.random.uniform((batch_size,1)), sample_hidden, sample_output)</span><br><span class="line"></span><br><span class="line">decoder_output, decoder_hidden, decoder_aw = outputs</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decoder_output.shape, decoder_hidden.shape, decoder_aw.shape)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mc</tag>
      </tags>
  </entry>
  <entry>
    <title>embedding记录</title>
    <url>/2019/08/19/embedding%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="问题：在embedding层，会报错。报错内容"><a href="#问题：在embedding层，会报错。报错内容" class="headerlink" title="问题：在embedding层，会报错。报错内容"></a>问题：在embedding层，会报错。报错内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">indices[0,0] = -13 is not <span class="keyword">in</span> [0, 600) [Op:ResourceGather] name: encoder_3/embedding_2/embedding_lookup</span><br></pre></td></tr></table></figure>

<p>意思就是 -13这个数值不在 这里数组里面</p>
<p>查看keras.layers.Embedding()的底层代码，发现这一层是专门用在自然语言处理的方向的。。。</p>
<p>需要把1维的数据—》3 维</p>
<p>这应该怎么弄呢？？？</p>
]]></content>
      <tags>
        <tag>mc</tag>
      </tags>
  </entry>
  <entry>
    <title>evaluate(input_sentence)</title>
    <url>/2019/08/18/08-18/</url>
    <content><![CDATA[<p>embedding_units = 256 # 每个word转换成embedding是多少。<br>第一次掉用这个参数是在，构建Encoder模型中，keras.layers.Embedding(vocab_size, embedding_units)这个函数中使用。<br>keras.layers.Embedding(input_dim, output_dim,)<br>将正整数（索引值）转换为固定尺寸的稠密向量。 例如： [[4], [20]] -&gt; [[0.25, 0.1], [0.6, -0.2]]<br>该层只能用作模型中的第一层<br>input_dim: int &gt; 0。词汇表大小， 即，最大整数 index + 1。<br>output_dim: int &gt;= 0。词向量的维度。</p>
<p>-输入尺寸</p>
<p>尺寸为 (batch_size, sequence_length) 的 2D 张量。</p>
<p>-输出尺寸</p>
<p>尺寸为 (batch_size, sequence_length, output_dim) 的 3D 张量。</p>
<p>max_length_input 这个参数是输入的每个序列长度，即文档里面的sequence_length。</p>
<h3 id="Encoder-模型有两层，第一层是embedding-是用来预处理的，有点像归一化。进入embedding后数据的shape会发生变化，如上所说的输出尺寸。"><a href="#Encoder-模型有两层，第一层是embedding-是用来预处理的，有点像归一化。进入embedding后数据的shape会发生变化，如上所说的输出尺寸。" class="headerlink" title="Encoder 模型有两层，第一层是embedding 是用来预处理的，有点像归一化。进入embedding后数据的shape会发生变化，如上所说的输出尺寸。"></a>Encoder 模型有两层，第一层是embedding 是用来预处理的，有点像归一化。进入embedding后数据的shape会发生变化，如上所说的输出尺寸。</h3><pre><code>        # 第二层是GRU层。
使用encoder函数，会有两个输出，一个是output(就是上面出的输出尺寸) 一个是hidden。hidden.shape=(batch_size, units)</code></pre><h4 id="units-1024-这个代表的是中间使用RNN的个数"><a href="#units-1024-这个代表的是中间使用RNN的个数" class="headerlink" title="units=1024, 这个代表的是中间使用RNN的个数"></a>units=1024, 这个代表的是中间使用RNN的个数</h4><p>这是在构造函数里面的GRU()初始化设置。</p>
<p>self.gru = keras.layers.GRU(self.encoding_units,return_sequences=True,return_state=True, recurrent_initializer=’glorot_uniform’)</p>
<p>encoding_units 是GRU的输出尺寸，recurrent_regularizer: 运用到 recurrent_kernel 权值矩阵的正则化函数</p>
<p>####call方法<br>call方法 可以理解为使用构造函数，在实例化这个方法的时候可以直接调用。<br>output, state = self.gru(x, initial_state=hidden)<br>您可以通过使用关键字参数 initial_state 调用它们来符号化地指定 RNN 层的初始状态。 initial_state 的值应该是表示 RNN 层初始状态的张量或张量列表。</p>
<h2 id="检查了一下-input-tokenizer-index-word里面的数值，存在问题。再检查一下"><a href="#检查了一下-input-tokenizer-index-word里面的数值，存在问题。再检查一下" class="headerlink" title="检查了一下 input_tokenizer.index_word里面的数值，存在问题。再检查一下"></a>检查了一下 input_tokenizer.index_word里面的数值，存在问题。再检查一下</h2>]]></content>
      <tags>
        <tag>mc</tag>
      </tags>
  </entry>
  <entry>
    <title>C51 Flash 读写操作</title>
    <url>/2019/08/17/c51_flash%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h2 id="C51-Flash-读写操作"><a href="#C51-Flash-读写操作" class="headerlink" title="C51 Flash 读写操作"></a>C51 Flash 读写操作</h2><p>###问题：下位机返回的数据，不是传感器的数据，有没有连接传感器，返回的数值也都一样。刚开始认为是标定的问题，把标定的函数搞明白，知道怎么去标定数据。但是标定完成后，数据还是不正确。</p>
<p>###思路：检查一下读取的Flash的驱动是不是有问题。写一个简单的函数，通过调用原来的读写函数，对flash里面的数值进行操作，每次下位机开断电，都会通过串口发送flash内部的数值，并每次把flash里的数据加一，然后再放到flash。简单的验证一下可以往flash内部进行数据的读写。</p>
<h3 id="结果：每次返回的数值-不会发生变化。"><a href="#结果：每次返回的数值-不会发生变化。" class="headerlink" title="结果：每次返回的数值 不会发生变化。"></a>结果：每次返回的数值 不会发生变化。</h3><h4 id="最后可以试一试外部的存储芯片模块。。。。24C08"><a href="#最后可以试一试外部的存储芯片模块。。。。24C08" class="headerlink" title="最后可以试一试外部的存储芯片模块。。。。24C08"></a>最后可以试一试外部的存储芯片模块。。。。24C08</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">unsigned char xdata hc[3]=&#123;0,0,0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-----------------存储标定的k、b值--------------</span><br><span class="line">void Save_flash(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i,j;</span><br><span class="line">    EA=0;              //禁止中断</span><br><span class="line">    FLSCL=0x89;        //FLASH 写/擦除定时(Fosc=18.432MHz) 允许FLASH写</span><br><span class="line">    PSCTL=0x07;        //临时FLASH 允许FLASH 写/擦除 </span><br><span class="line">    FLASH_ADDR[0]=0;   //向待擦除扇区内的任何一个地址写入一个数据字节？擦除 临时FLASH</span><br><span class="line">    <span class="keyword">for</span>(i=0;i&lt;2;i++)  //写入数据FLASH</span><br><span class="line">    &#123;</span><br><span class="line">        PSCTL=0x00;    //程序数据FLASH 禁止FLASH 写/擦除 </span><br><span class="line">	    j=hc[i];     //读FLASH存储器 与PSWE无关</span><br><span class="line">        PSCTL=0x05;    //临时FLASH 禁止擦除 允许写 </span><br><span class="line">	    FLASH_ADDR[i]=j;</span><br><span class="line">    &#125;                 </span><br><span class="line">    FLSCL=0x4f;        //禁止FLASH 写/擦除</span><br><span class="line">    PSCTL=0x00;        //程序数据FLASH 禁止FLASH 写/擦除 </span><br><span class="line">    EA=1;</span><br><span class="line">&#125;</span><br><span class="line">//-------------从MCU中读取出标定的k、b值------------------------</span><br><span class="line">void Read_flash(void)        </span><br><span class="line">&#123;</span><br><span class="line">    uint8 i,j;</span><br><span class="line">	uint8 code *FLASH_READ;   //code定义的数据在flash中</span><br><span class="line">	FLASH_READ=0x0000;</span><br><span class="line">	<span class="keyword">for</span>(i=0;i&lt;2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    PSCTL=0x04;           //选择数据FLASH扇区 禁止FLASH 写/擦除</span><br><span class="line">		j=FLASH_READ[i];      //读取数据flash 0x0000区</span><br><span class="line">	    PSCTL=0x00;           //选择程序Flash 禁止写/擦除</span><br><span class="line">		hc[i]=j;            //读程序flash</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">	WDTCN = 0xde;                       // Disable watchdog timer  关闭看门狗</span><br><span class="line">   	WDTCN = 0xad; </span><br><span class="line"> 	SYSCLK_Init();</span><br><span class="line"> 	PORT_Init();</span><br><span class="line">	ADC0_Init();	</span><br><span class="line">	UART0_Init();</span><br><span class="line">	</span><br><span class="line">	Read_All();</span><br><span class="line">	Para[0]++;</span><br><span class="line">	Save_Para();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	P2 = 0x00;</span><br><span class="line">	EA = 1;                             // Enable global interrupts</span><br><span class="line">	</span><br><span class="line">	Send_Buf0[0] = Para[0];    //发送帧头</span><br><span class="line">	Send_Buf0[1] = 0x00; </span><br><span class="line">	Send_Max = 2;</span><br><span class="line">	Send_p = 0;</span><br><span class="line">	SCON0 &amp;= 0xef; //REN0 = 0 禁止开始接收</span><br><span class="line">	SBUF0  = 0x41; //启动回答数据事件</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(1)											 </span><br><span class="line">	&#123;		</span><br><span class="line"> 	WDTCN = 0xa5;	  //使能并复位看门狗定时器</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始对flash保存的代码，这里的Para变量是这么define的 uint8   xdata Para[112];</p>
]]></content>
      <tags>
        <tag>C8051f020</tag>
      </tags>
  </entry>
  <entry>
    <title>plot_attention</title>
    <url>/2019/08/16/plot-attention/</url>
    <content><![CDATA[<p>def plot_attention(attention_matrix, input_sentence, predicted_sentence):<br>    fig = plt.figure(figsize=(10,10))<br>    ax = fig.add_subplot(1, 1, 1)</p>
<pre><code>ax.matshow(attention_matrix, cmap=&apos;viridis&apos;) # cmap 定义的是配色

font_dict = {&apos;fontsize&apos;: 14}

ax.set_xticklabels([&apos;&apos;] + input_sentence, fontdict = font_dict, rotation = 90) # roation 让字体反转90度
ax.set_yticklabels([&apos;&apos;] + predicted_sentence,fontdict = font_dict)
plt.show()</code></pre>]]></content>
      <tags>
        <tag>mc</tag>
      </tags>
  </entry>
  <entry>
    <title>evaluate(input_sentence)</title>
    <url>/2019/08/15/evaluate-input-sentence/</url>
    <content><![CDATA[<p>详细的记录 evaluate函数的实现。<br>解决报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-44-2ec1176683f0&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 translate(u<span class="string">'Estoy trabajando.'</span>)</span><br><span class="line"></span><br><span class="line">&lt;ipython-input-43-4364cc5c7981&gt; <span class="keyword">in</span> translate(input_sentence)</span><br><span class="line">     49 </span><br><span class="line">     50 def translate(input_sentence):</span><br><span class="line">---&gt; 51     results, input_sentence, attention_matrix = evaluate(input_sentence)</span><br><span class="line">     52 </span><br><span class="line">     53     <span class="built_in">print</span>(<span class="string">"Input: %s"</span> % (input_sentence))</span><br><span class="line"></span><br><span class="line">&lt;ipython-input-43-4364cc5c7981&gt; <span class="keyword">in</span> evaluate(input_sentence)</span><br><span class="line">     20     decoding_input = tf.expand_dims([out_tokenizer.word_index[<span class="string">'&lt;start&gt;'</span>]], 0)</span><br><span class="line">     21     <span class="keyword">for</span> t <span class="keyword">in</span> range(max_length_output):</span><br><span class="line">---&gt; 22         predictions. decoding_hidden, attention_weights = decoder(decoding_input, decoding_hidden, encoding_outputs)</span><br><span class="line">     23         attention_weights = tf.reshape(attention_weights, (-1,))</span><br><span class="line">     24         attention_matrix[t] = attention_weights.numpy()</span><br><span class="line"></span><br><span class="line">ValueError: too many values to unpack (expected 2)</span><br></pre></td></tr></table></figure>

<h3 id="注意看predictions-后面的标点符号"><a href="#注意看predictions-后面的标点符号" class="headerlink" title="注意看predictions 后面的标点符号"></a>注意看predictions 后面的标点符号</h3><p>接收的是一个文本的输入，首先就要转换成适合模型的数据类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def evaluate(input_sentence):</span><br><span class="line">    attention_matrix = np.zeros((max_length_output, max_length_input)) <span class="comment"># 定义attention_matrix 保存权重。shape:()</span></span><br><span class="line">    input_sentence = preprocess_sentence(input_sentence) <span class="comment"># 输入的句子进行预处理。就是分割标点符号/</span></span><br><span class="line"></span><br><span class="line">    inputs = [input_tokenizer.word_index[token] <span class="keyword">for</span> token <span class="keyword">in</span> input_sentence.split(<span class="string">' '</span>)] <span class="comment"># text---&gt;id 把句子转换成id</span></span><br><span class="line">    inputs = keras.preprocessing.sequence.pad_sequences([inputs], maxlen = max_length_input, padding= <span class="string">'post'</span>) <span class="comment"># 把转换成id的向量，进行padding</span></span><br><span class="line">    inputs = tf.convert_to_tensor(inputs) <span class="comment">#把向量转换为tensor</span></span><br><span class="line"></span><br><span class="line">    results = <span class="string">''</span> <span class="comment"># 定义str, 保存translate的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     encoding_hidden = encoder.initialize_hidden_state()</span></span><br><span class="line"></span><br><span class="line">    encoding_hidden = tf.zeros((1, units)) <span class="comment">#初始化encoding_hidden层</span></span><br><span class="line"></span><br><span class="line">    encoding_outputs, encoding_hidden = encoder(inputs, encoding_hidden) <span class="comment"># 这一步得到的encoding_hidden就是decoding_hidden 的第一个值</span></span><br><span class="line">    decoding_hidden = encoding_hidden</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    decoding_input = tf.expand_dims([out_tokenizer.word_index[<span class="string">'&lt;start&gt;'</span>]], 0) <span class="comment"># 找到开始的第一个输入的id</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(max_length_output):</span><br><span class="line">        predictions, decoding_hidden, attention_weights = decoder(decoding_input, decoding_hidden, encoding_outputs)</span><br><span class="line">        attention_weights = tf.reshape(attention_weights, (-1,))</span><br><span class="line">        attention_matrix[t] = attention_weights.numpy()</span><br><span class="line"></span><br><span class="line">        predicted_id = tf.argmax(predictions[0]).numpy()</span><br><span class="line"></span><br><span class="line">        results += out_tokenizer.index_word[predicted_id] + <span class="string">' '</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> out_tokenizer.index_word[predicted_id] == <span class="string">'&lt;end&gt;'</span>:</span><br><span class="line">            <span class="built_in">return</span> results, input_sentence, attention_matrix</span><br><span class="line"></span><br><span class="line">        decoding_input = tf.expand_dims([predicted_id], 0)</span><br><span class="line">    <span class="built_in">return</span> results, input_sentence, attention_matrix</span><br><span class="line"></span><br><span class="line">def plot_attention(attention_matrix, input_sentence, predicted_sentence):</span><br><span class="line">    fig = plt.figure(figsize=(10,10))</span><br><span class="line">    ax = fig.add_subplot(1, 1, 1)</span><br><span class="line"></span><br><span class="line">    ax.matshow(attention_matrix, cmap=<span class="string">'viridis'</span>)</span><br><span class="line"></span><br><span class="line">    font_dict = &#123;<span class="string">'fontsize'</span>: 14&#125;</span><br><span class="line"></span><br><span class="line">    ax.set_xticklabels([<span class="string">''</span>] + input_sentence,</span><br><span class="line">                              fontdict = font_dict, rotation = 90)</span><br><span class="line">    ax.sey_yticklables([<span class="string">''</span>] + predicted_sentence,</span><br><span class="line">                              fontdict = font_dict,)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">def translate(input_sentence):</span><br><span class="line">    results, input_sentence, attention_matrix = evaluate(input_sentence)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Input: %s"</span> % (input_sentence))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Predicted translation: %s"</span> % (results))</span><br><span class="line"></span><br><span class="line">    attention_matrix = attention_matrix[:len(results.split(<span class="string">' '</span>)),</span><br><span class="line">                                                       :len(input_sentence.split(<span class="string">' '</span>))]</span><br><span class="line">    plot_attention(attention_matrix, input_sentence.split(<span class="string">' '</span>), results.split(<span class="string">' '</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mc</tag>
      </tags>
  </entry>
  <entry>
    <title>BahdanauAttention</title>
    <url>/2019/08/14/BahdanauAttention/</url>
    <content><![CDATA[<p>2015年提出的BahdanauAttention原文：<br><a href="https://arxiv.org/pdf/1409.0473.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1409.0473.pdf</a></p>
<h3 id="0814-记录"><a href="#0814-记录" class="headerlink" title="0814 记录"></a>0814 记录</h3><h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p>Encoder会通过RNN将最后一个step的隐藏状态向量c作为输出，Deocder利用向量c进行翻译。这样做有一个缺点，翻译时过分依赖于这个将整个sentence压缩成固定输入的向量。输入的sentence有可能包含上百个单词，这么做不可避免会造成信息的丢失，翻译结果也无法准确了</p>
<p>注意力机制的引入就是为了解决此问题，注意力机制使得机器翻译中利用原始的sentence信息，减少信息损失。</p>
<p>损失函数<br>预测哪个单词是正确的，是一个分类问题。</p>
]]></content>
  </entry>
  <entry>
    <title>model搭建</title>
    <url>/2019/08/13/model%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="python-构造函数"><a href="#python-构造函数" class="headerlink" title="python 构造函数"></a>python 构造函数</h2><h2 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h2><p>super()是为了调用父类函数</p>
<p><a href="https://www.runoob.com/python3/python3-class.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-class.html</a></p>
<h2 id="encoder构建"><a href="#encoder构建" class="headerlink" title="encoder构建"></a>encoder构建</h2><p>定义超参的概念<br>embedding_units = 256   每个word转成embedding是多少<br>units = 1024 循环神经网络的个数 encode 和decode的units数量是一样的<br>encoding_units 在 encode中lstm 的size是多大</p>
<p>hidden 是初始化的隐藏层状态</p>
<p>keras.layers.GRU(units, activation=’tanh’, recurrent_activation=’hard_sigmoid’, use_bias=True, kernel_initializer=’glorot_uniform’, recurrent_initializer=’orthogonal’, bias_initializer=’zeros’, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0, implementation=1, return_sequences=False, return_state=False, go_backwards=False, stateful=False, unroll=False, reset_after=False)</p>
<h4 id="units-正整数，输出空间的维度。"><a href="#units-正整数，输出空间的维度。" class="headerlink" title="units: 正整数，输出空间的维度。"></a>units: 正整数，输出空间的维度。</h4><h4 id="recurrent-initializer-recurrent-kernel-权值矩阵-的初始化器，用于循环层状态的线性转换-详见-initializers-。"><a href="#recurrent-initializer-recurrent-kernel-权值矩阵-的初始化器，用于循环层状态的线性转换-详见-initializers-。" class="headerlink" title="recurrent_initializer: recurrent_kernel 权值矩阵 的初始化器，用于循环层状态的线性转换 (详见 initializers)。"></a>recurrent_initializer: recurrent_kernel 权值矩阵 的初始化器，用于循环层状态的线性转换 (详见 initializers)。</h4><h4 id="return-sequences-布尔值。是返回输出序列中的最后一个输出，还是全部序列。"><a href="#return-sequences-布尔值。是返回输出序列中的最后一个输出，还是全部序列。" class="headerlink" title="return_sequences: 布尔值。是返回输出序列中的最后一个输出，还是全部序列。"></a>return_sequences: 布尔值。是返回输出序列中的最后一个输出，还是全部序列。</h4><h4 id="return-state-布尔值。除了输出之外是否返回最后一个状态。"><a href="#return-state-布尔值。除了输出之外是否返回最后一个状态。" class="headerlink" title="return_state: 布尔值。除了输出之外是否返回最后一个状态。"></a>return_state: 布尔值。除了输出之外是否返回最后一个状态。</h4><p><a href="https://keras.io/zh/layers/recurrent/" target="_blank" rel="noopener">https://keras.io/zh/layers/recurrent/</a></p>
<h3 id="Writing-your-own-Keras-layers"><a href="#Writing-your-own-Keras-layers" class="headerlink" title="Writing your own Keras layers"></a>Writing your own Keras layers</h3><p><a href="https://keras.io/layers/writing-your-own-keras-layers/" target="_blank" rel="noopener">https://keras.io/layers/writing-your-own-keras-layers/</a></p>
<h2 id="glorot-uniform"><a href="#glorot-uniform" class="headerlink" title="glorot_uniform"></a>glorot_uniform</h2><p><a href="https://keras.io/zh/initializers/" target="_blank" rel="noopener">https://keras.io/zh/initializers/</a></p>
<p>keras.initializers.glorot_uniform(seed=None)<br>Glorot 均匀分布初始化器，也称为 Xavier 均匀分布初始化器。</p>
<p>它从 [-limit，limit] 中的均匀分布中抽取样本， 其中 limit 是 sqrt(6 / (fan_in + fan_out))， fan_in 是权值张量中的输入单位的数量， fan_out 是权值张量中的输出单位的数量。</p>
<p>参数<br>seed: 一个 Python 整数。作为随机发生器的种子。</p>
<p>返回<br>一个初始化器。</p>
<p>参考文献：<a href="http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf" target="_blank" rel="noopener">http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Encoder (keras.Model):</span><br><span class="line">    def __init__(self, vocab_size, embedding_units, encoding_units, batch_size):</span><br><span class="line">        super(Encoder, self).__init__()</span><br><span class="line">        self.batch_size = batch_size</span><br><span class="line">        self.encoding_units = encoding_units</span><br><span class="line">        self.embedding = keras.layers.Embedding(vocab_size,embedding_units)</span><br><span class="line">        self.gru = keras.layers.GRU(self.encoding_units,return_sequences=True,return_state=True, </span><br><span class="line">                                recurrent_initializer=<span class="string">'glorot_uniform'</span>)</span><br><span class="line">    def call(self, x, hidden):</span><br><span class="line">        x = self.embedding(x)</span><br><span class="line">        output, state = self.gru(x, initial_state=hidden) <span class="comment">## 这里的self.gru() 传递的两个参数是什么意思呢？在构造函数里面并没有使用这两个参数， 但是在api里 可以找到这个参数。</span></span><br><span class="line">        <span class="built_in">return</span> output, state</span><br><span class="line">    def initialize_hidden_state(self):</span><br><span class="line">        <span class="built_in">return</span> tf.zeros((self.batch_size,self.encoding_units))</span><br><span class="line"></span><br><span class="line">encode = Encoder(input_vocab_size, embedding_units, units, batch_size)</span><br><span class="line"></span><br><span class="line">sample_hidden = encoder.initialize_hidden_state()</span><br><span class="line"></span><br><span class="line">sample_output, sample_hidden = encoder(x, sample_hidden)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 输入模型的数据特征</span></span><br><span class="line">[<span class="keyword">in</span>]</span><br><span class="line"><span class="keyword">for</span> array <span class="keyword">in</span> (input_train, input_eval, output_train, output_eval):</span><br><span class="line">    <span class="built_in">print</span>( <span class="built_in">type</span>(array), array.shape)</span><br><span class="line">[out]</span><br><span class="line">    &lt;class <span class="string">'numpy.ndarray'</span>&gt; (24, 9)</span><br><span class="line">    &lt;class <span class="string">'numpy.ndarray'</span>&gt; (7, 9)</span><br><span class="line">    &lt;class <span class="string">'numpy.ndarray'</span>&gt; (24, 14)</span><br><span class="line">    &lt;class <span class="string">'numpy.ndarray'</span>&gt; (7, 14)</span><br><span class="line"></span><br><span class="line">可以这样理解，对于 input_train 来说，有24个样本，每个样本有9个特征。对于这个9。就是每个句子的单词数，但是有的句子单词不够9个，这在预处理数据的时候进行了padding操作。样本数是24，在train_test_split(test_size=0.2)分配的数据量。</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>python链表推导式</title>
    <url>/2019/08/12/python%E9%93%BE%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>链表推导式在很多代码里都出现过，但是语法规则不太了解，今天做个记录。</p>
<p>#我感觉链表推导式就是让代码看上去更清爽。。。</p>
<p>a,b for c, d in </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[In]</span><br><span class="line">a = [(1,2),(3,4),(5,6)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(len(a))</span><br><span class="line">[out]</span><br><span class="line">&lt;class <span class="string">'list'</span>&gt;</span><br><span class="line">3</span><br><span class="line">[In]</span><br><span class="line">def a(a):</span><br><span class="line">    <span class="built_in">return</span>(<span class="built_in">print</span>(a))</span><br><span class="line">def b(a):</span><br><span class="line">    <span class="built_in">return</span>(<span class="built_in">print</span>(a))</span><br><span class="line"></span><br><span class="line">a(c),b(d) <span class="keyword">for</span> c,d <span class="keyword">in</span> a</span><br></pre></td></tr></table></figure>

<h3 id="Python-中形如-xx-for-xx-in-yy-的链表推导式"><a href="#Python-中形如-xx-for-xx-in-yy-的链表推导式" class="headerlink" title="Python 中形如 xx for xx in yy 的链表推导式"></a>Python 中形如 xx for xx in yy 的链表推导式</h3><h1 id="以-a-0-1-2-3-4-5-为例"><a href="#以-a-0-1-2-3-4-5-为例" class="headerlink" title="以 a = [0,1,2,3,4,5] 为例"></a>以 a = [0,1,2,3,4,5] 为例</h1><h2 id="1-最简单的情况，使用链表推导式时不需要任何判断，即处理的对象内没有任何特殊值需要特别处理的时候"><a href="#1-最简单的情况，使用链表推导式时不需要任何判断，即处理的对象内没有任何特殊值需要特别处理的时候" class="headerlink" title="1. 最简单的情况，使用链表推导式时不需要任何判断，即处理的对象内没有任何特殊值需要特别处理的时候"></a>1. 最简单的情况，使用链表推导式时不需要任何判断，即处理的对象内没有任何特殊值需要特别处理的时候</h2><p> 比如：求 a 内每个元素的平方，我们直接写</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = [ x**2 for x in a]<br>b
[0, 1, 4, 9, 16, 25]</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="2-当增加限制条件时，就需要进行判断，然后处理，就需要在链表推导式内添加判断条件"><a href="#2-当增加限制条件时，就需要进行判断，然后处理，就需要在链表推导式内添加判断条件" class="headerlink" title="2. 当增加限制条件时，就需要进行判断，然后处理，就需要在链表推导式内添加判断条件"></a>2. 当增加限制条件时，就需要进行判断，然后处理，就需要在链表推导式内添加判断条件</h2><p> 比如：取出 a 内 &gt; 0 的元素</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = [ x for x in a if x &gt; 0 ]<br>c
[1, 2, 3, 4, 5]</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="3-链表推导式处理处理内容，还有一个作用是定位，这样可以满足我们先定位再处理的需求"><a href="#3-链表推导式处理处理内容，还有一个作用是定位，这样可以满足我们先定位再处理的需求" class="headerlink" title="3. 链表推导式处理处理内容，还有一个作用是定位，这样可以满足我们先定位再处理的需求"></a>3. 链表推导式处理处理内容，还有一个作用是定位，这样可以满足我们先定位再处理的需求</h2><p> 比如：我们要知道 a 内偶数元素的位置</p>
<blockquote>
<blockquote>
<blockquote>
<p>a_even_id = [ i for i,x in enumerate(a) if x%2 == 0 ]<br>a_even_id<br>[0, 2, 4]</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="4-下面进行难度提升，当处理的对象不是纯数字，即不是我们所需要的数据格式或对象时"><a href="#4-下面进行难度提升，当处理的对象不是纯数字，即不是我们所需要的数据格式或对象时" class="headerlink" title="4. 下面进行难度提升，当处理的对象不是纯数字，即不是我们所需要的数据格式或对象时"></a>4. 下面进行难度提升，当处理的对象不是纯数字，即不是我们所需要的数据格式或对象时</h2><p>A0 = [ 0,’ ‘,1,2,4,5,’ ‘,’3’,2]<br> A是由整数（int)和空格’ ‘, 以及字符串’3’组成的<br> 我们要将空格替换为 0 ，将’3’ 替换为 整形 3<br> (1).判断是否是整形： type(x) == int<br> (2).不是整形，则判断是否是空格：x == ‘ ‘，是则替换为 0，<br> (3).判断是否是数字构成的字符串：x.isdigit(),(isdigit()是字符串方法），是则转化为整形数<br> (4). 如果是其他，则均替换为 0 ,(这一步必须有，以为要穷尽多有可能，否则会因为条件没有覆盖到而导致无法执行）</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = [ x if type(x)==int else 0 if x == ‘ ‘ else int(x) if x.isdigit() else 0 for x in A0 ]<br>A
[0, 0, 1, 2, 4, 5, 0, 3, 2]</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="5-如果只需要处理-A0-内的整形数据，而舍弃其他的数据，那么我们不必像4中描述的那么复杂，只需要："><a href="#5-如果只需要处理-A0-内的整形数据，而舍弃其他的数据，那么我们不必像4中描述的那么复杂，只需要：" class="headerlink" title="5. 如果只需要处理 A0 内的整形数据，而舍弃其他的数据，那么我们不必像4中描述的那么复杂，只需要："></a>5. 如果只需要处理 A0 内的整形数据，而舍弃其他的数据，那么我们不必像4中描述的那么复杂，只需要：</h3><blockquote>
<blockquote>
<blockquote>
<p>A_int = [x for x in A0 if type(x)==int ]<br>A_int<br>[0, 1, 2, 4, 5, 2]</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
      <tags>
        <tag>mc</tag>
      </tags>
  </entry>
  <entry>
    <title>Generate_x_y_data_v1()函数理解</title>
    <url>/2019/08/11/Generate-x-y-data-v1-%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def generate_x_y_data_v1(isTrain, batch_size):</span><br><span class="line"><span class="comment">#     """</span></span><br><span class="line"><span class="comment"># 练习数据1。</span></span><br><span class="line"><span class="comment">#      返回：元组（X，Y）</span></span><br><span class="line"><span class="comment">#          X是从0.0 * pi到1.5 * pi的正弦和余弦</span></span><br><span class="line"><span class="comment">#          Y是从1.5 * pi到3.0 * pi的正弦和余弦</span></span><br><span class="line"><span class="comment">#      因此，Y跟随X.还有一个通常应用于X和Y的随机偏移。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#      返回的数组具有以下形状：（seq_length，batch_size，output_dim）</span></span><br><span class="line"><span class="comment">#         因此：（10，batch_size，2）</span></span><br><span class="line"><span class="comment">#      对于本练习，让我们忽略“isTrain”</span></span><br><span class="line"><span class="comment">#      论证和测试相同的数据。</span></span><br><span class="line"><span class="comment">#     """</span></span><br><span class="line">seq_length = 3</span><br><span class="line">batch_size = 3</span><br><span class="line"></span><br><span class="line">batch_x = []</span><br><span class="line">batch_y = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(batch_size):</span><br><span class="line">    rand = random.random() * 2 * math.pi</span><br><span class="line"></span><br><span class="line">    sig1 = np.sin(np.linspace(0.0 * math.pi + rand,</span><br><span class="line">                              3.0 * math.pi + rand, seq_length * 2))</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line">    <span class="built_in">print</span>(sig1)</span><br><span class="line">    sig2 = np.cos(np.linspace(0.0 * math.pi + rand,</span><br><span class="line">                              3.0 * math.pi + rand, seq_length * 2))</span><br><span class="line">    x1 = sig1[:seq_length]</span><br><span class="line">    y1 = sig1[seq_length:]</span><br><span class="line">    x2 = sig2[:seq_length]</span><br><span class="line">    y2 = sig2[seq_length:]</span><br><span class="line"></span><br><span class="line">    x_ = np.array([x1, x2])</span><br><span class="line">    y_ = np.array([y1, y2])</span><br><span class="line">    x_, y_ = x_.T, y_.T</span><br><span class="line"></span><br><span class="line">    batch_x.append(x_)</span><br><span class="line">    batch_y.append(y_)</span><br><span class="line"></span><br><span class="line">batch_x = np.array(batch_x)</span><br><span class="line">batch_y = np.array(batch_y)</span><br><span class="line"><span class="comment"># shape: (batch_size, seq_length, output_dim)</span></span><br><span class="line"></span><br><span class="line">batch_x = np.array(batch_x).transpose((1, 0, 2))</span><br><span class="line">batch_y = np.array(batch_y).transpose((1, 0, 2))</span><br><span class="line"><span class="comment"># shape: (seq_length, batch_size, output_dim)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> batch_x, batch_y</span><br></pre></td></tr></table></figure>

<p>sig1 是ndarray类型，长度为seq_length*2 , 主要np.linspace()函数。</p>
<p>numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)</p>
<p>sig2 和sig1 一样的思路<br>x1 y1 是对sig1的截取，分别取前半段和后半段<br>x2 y2 是对sig2的截取，分别取前半段和后半段</p>
<p>batch_x 就是x1 x2 形成的矩阵。<br>batch_y 就是y1 y2 形成的矩阵。</p>
<p>batch_x.shape = (seq_length, batch_size,2)</p>
<p>有seq_length个样本，每个样本的维度 (batch_size,2)</p>
<h3 id="span-english"><a href="#span-english" class="headerlink" title="span-english"></a>span-english</h3><ol>
<li>preprocessing data</li>
<li>build model</li>
<li>1 encoder</li>
<li>2 Attention</li>
<li>3 decoder</li>
<li>evaluation</li>
<li>1 given sentence, return translated results</li>
<li>2 visualize results(attention)</li>
</ol>
]]></content>
      <tags>
        <tag>MC</tag>
      </tags>
  </entry>
  <entry>
    <title>0810调试</title>
    <url>/2019/08/10/0810%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="在进行一次标定。"><a href="#在进行一次标定。" class="headerlink" title="在进行一次标定。"></a>在进行一次标定。</h2><p>C8051 允许编程修改寄存器的值。<br>把8个通道都进行标定。。。然后观察返回值。。。</p>
<p>标定前<br>43 14 1 0 0 0 0 15 44<br>    41 14 80 FF 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 6B 42 </p>
<p>43 14 8 2 2 1 1 1c 44<br>    41 14 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 05 26 05 26 05 26 05 26 05 26 05 26 14 42<br> <a id="more"></a><br>标定第0个<br>标定第1个<br>标定第2个通道<br>标定第3个通道<br>标定第4个通道<br>标定第5个通道<br>标定第6个通道</p>
<p>标定前和标定给 返回值没有区别。。</p>
<h3 id="8051的数据存储空间"><a href="#8051的数据存储空间" class="headerlink" title="8051的数据存储空间"></a>8051的数据存储空间</h3><p>片内：<br>    片内RAM和特殊功能寄存器(SFR).<br>    片内RAM分为 工作寄存器区 (00H<del>1FH)<br>                位寻址区(20</del>2F)<br>                数据缓冲区(30H~7FH)<br>片外</p>
<h3 id="这是标定的函数，我觉得应该没问题，我也没动。。。。标定完的k、b值应该是存放在flash里面，会不会是和程序占用的flash有冲突呢？？"><a href="#这是标定的函数，我觉得应该没问题，我也没动。。。。标定完的k、b值应该是存放在flash里面，会不会是和程序占用的flash有冲突呢？？" class="headerlink" title="这是标定的函数，我觉得应该没问题，我也没动。。。。标定完的k、b值应该是存放在flash里面，会不会是和程序占用的flash有冲突呢？？"></a>这是标定的函数，我觉得应该没问题，我也没动。。。。标定完的k、b值应该是存放在flash里面，会不会是和程序占用的flash有冲突呢？？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Save_Para(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i,j;</span><br><span class="line">    EA=0;              //????</span><br><span class="line">    FLSCL=0x89;        //FLASH ?/????(Fosc=18.432MHz) ??FLASH?</span><br><span class="line">    PSCTL=0x07;        //??FLASH ??FLASH ?/?? </span><br><span class="line">    FLASH_ADDR[0]=0;   //????????????????????????? ??FLASH</span><br><span class="line">    <span class="keyword">for</span>(i=0;i&lt;112;i++)  //????FLASH</span><br><span class="line">    &#123;</span><br><span class="line">        PSCTL=0x00;    //????FLASH ??FLASH ?/?? </span><br><span class="line">	    j=Para[i];     //?FLASH??? ?PSWE??</span><br><span class="line">        PSCTL=0x05;    //??FLASH ???? ??? </span><br><span class="line">	    FLASH_ADDR[i]=j;</span><br><span class="line">    &#125;                 </span><br><span class="line">    FLSCL=0x4f;        //??FLASH ?/??</span><br><span class="line">    PSCTL=0x00;        //????FLASH ??FLASH ?/?? </span><br><span class="line">    EA=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是计算的问题还是通信的问题"><a href="#是计算的问题还是通信的问题" class="headerlink" title="是计算的问题还是通信的问题"></a>是计算的问题还是通信的问题</h3><p>1 我把上行命令里的帧头修改为0x43，但是接受到的帧头还是0x41<br>    可能原因是: keil 激活不正确 我激活是的MDK51<br>    应该激活的是 c51</p>
]]></content>
      <tags>
        <tag>C8051F020</tag>
      </tags>
  </entry>
  <entry>
    <title>0809调试</title>
    <url>/2019/08/09/0809%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h3 id="0809-调试记录"><a href="#0809-调试记录" class="headerlink" title="0809 调试记录"></a>0809 调试记录</h3><p>现在返回的32个字节是乱码的，可能是因为没有标定。现在需要看一下标定是怎么操作的。</p>
<h4 id="分析Rece-Buf0-1-0x00-0xFF-分别执行什么操作"><a href="#分析Rece-Buf0-1-0x00-0xFF-分别执行什么操作" class="headerlink" title="分析Rece_Buf0[1] == 0x00 - 0xFF 分别执行什么操作"></a>分析Rece_Buf0[1] == 0x00 - 0xFF 分别执行什么操作</h4><h5 id="当-Rece-Buf0-1-0x00-执行下列语句，-Read-All-Set-All"><a href="#当-Rece-Buf0-1-0x00-执行下列语句，-Read-All-Set-All" class="headerlink" title="当  Rece_Buf0[1] == 0x00 执行下列语句，   Read_All();        Set_All();"></a>当  Rece_Buf0[1] == 0x00 执行下列语句，   Read_All();        Set_All();</h5> <a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 0:         //召唤采集多通道数据，下位机回答        </span><br><span class="line">    Read_All();</span><br><span class="line">    Set_All();</span><br><span class="line">    <span class="keyword">for</span>(i=2; i&lt;30; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Send_Buf0[i]=0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">//-------------从MCU中读取出标定的k、b值------------------------</span><br><span class="line">void Read_All(void)        </span><br><span class="line">&#123;</span><br><span class="line">    uint8 i,j; //value:0-255</span><br><span class="line">    uint8 code *FLASH_READ;   //code定义的数据在flash中</span><br><span class="line">    FLASH_READ=0x0000;</span><br><span class="line">    <span class="keyword">for</span>(i=0;i&lt;112;i++)   // Para[112]</span><br><span class="line">    &#123;</span><br><span class="line">        PSCTL=0x04;           //选择数据FLASH扇区 禁止FLASH 写/擦除</span><br><span class="line">        j=FLASH_READ[i];      //读取数据flash 0x0000区</span><br><span class="line">        PSCTL=0x00;           //选择程序Flash 禁止写/擦除</span><br><span class="line">        Para[i]=j;            //读程序flash</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//-----------------------------------</span><br><span class="line">void Set_All(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i;</span><br><span class="line">    <span class="keyword">for</span>(i=0;i&lt;14;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cons.data_B.byte1=Para[i*8];</span><br><span class="line">        cons.data_B.byte2=Para[i*8+1];</span><br><span class="line">        cons.data_B.byte3=Para[i*8+2];</span><br><span class="line">        cons.data_B.byte4=Para[i*8+3];</span><br><span class="line">        kk[i]=cons.data_F;</span><br><span class="line">        cons.data_B.byte1=Para[i*8+4];</span><br><span class="line">        cons.data_B.byte2=Para[i*8+5];</span><br><span class="line">        cons.data_B.byte3=Para[i*8+6];</span><br><span class="line">        cons.data_B.byte4=Para[i*8+7];</span><br><span class="line">        bb[i]=cons.data_F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="当-Rece-Buf0-1-0x01-执行下列语句，-在命令表-里面的意思是-标定电位第1点"><a href="#当-Rece-Buf0-1-0x01-执行下列语句，-在命令表-里面的意思是-标定电位第1点" class="headerlink" title="当  Rece_Buf0[1] == 0x01 执行下列语句，  在命令表 里面的意思是 标定电位第1点"></a>当  Rece_Buf0[1] == 0x01 执行下列语句，  在命令表 里面的意思是 标定电位第1点</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unsigned char bdata CHSWITCH=0x00;</span><br><span class="line">sbit CHA=CHSWITCH^5;</span><br><span class="line">sbit CHB=CHSWITCH^4;</span><br><span class="line">sbit CHC=CHSWITCH^3;</span><br><span class="line">sbit CHD=CHSWITCH^2;</span><br><span class="line">sbit CHX=CHSWITCH^1;</span><br><span class="line">sbit CHZ=CHSWITCH^0;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> xdata para_temp[16];  //临时参数</span><br><span class="line">uint16 xdata ad_buf[16];  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 1://标定第一点	</span><br><span class="line">    CHSWITCH =CHSWITCH&amp;0xc3;					  </span><br><span class="line">    channel = Rece_Buf0[5]; //Rece_Buf[5] 电位通道选择0~7							</span><br><span class="line">    ad_val(channel);  //返回i一个值 result_temp  取16次数据,排序之后去掉最大的6个数据和最小的6个数据取中间4个数据然后取平均，获得一个无符号整形数据									</span><br><span class="line">    para_temp[0]=Rece_Buf0[3];</span><br><span class="line">    para_temp[0]*=256;</span><br><span class="line">    para_temp[0]+=Rece_Buf0[4];</span><br><span class="line">    para_temp[0]/=10;</span><br><span class="line">    <span class="keyword">if</span>(Rece_Buf0[2]==1)</span><br><span class="line">    &#123;</span><br><span class="line">        para_temp[0]*=-1;</span><br><span class="line">    &#125;</span><br><span class="line">    ad_buf[0]=result_temp;								</span><br><span class="line"><span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>

<p>case语句 判断的就是Rece_Buf0[1]的值，就是命令表里的操作。<br>执行完对应的case语句，会给para_temp列表赋值<br>uint16 xdata ad_buf[16];<br>每次执行完case语句，会往 ad_buf[16]添加一个数，和往para_temp[16]添加的操作是一样的。</p>
]]></content>
      <tags>
        <tag>C8051F020</tag>
      </tags>
  </entry>
  <entry>
    <title>调试记录</title>
    <url>/2019/08/08/%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="0808-调试记录"><a href="#0808-调试记录" class="headerlink" title="0808 调试记录"></a>0808 调试记录</h3><p>Rece_Buf0</p>
<p>标定点位第1点，Rece_Buf0[9] =0x43,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x44<br>标定点位第2点，Rece_Buf0[9] =0x43,0x02,0x00,0x00,0x00,0x00,0x00,0x02,0x44<br>标定点位第3点，Rece_Buf0[9] =0x43,0x03,0x00,0x00,0x00,0x00,0x00,0x03,0x44<br>标定点位第4点，Rece_Buf0[9] =0x43,0x04,0x00,0x00,0x00,0x00,0x00,0x04,0x44<br>标定点位第5点，Rece_Buf0[9] =0x43,0x05,0x00,0x00,0x00,0x00,0x00,0x05,0x44<br>标定点位第6点，Rece_Buf0[9] =0x43,0x06,0x00,0x00,0x00,0x00,0x00,0x06,0x44<br>标定点位第7点，Rece_Buf0[9] =0x43,0x07,0x00,0x00,0x00,0x00,0x00,0x07,0x44<br>计算电位的K b，Rece_Buf0[9] =0x43,0x08,0x00,0x00,0x00,0x00,0x00,0x08,0x44   </p>
<p>标定第0通道 输入数据  </p>
<p>[In] 标定点位第1点，Rece_Buf0[9] =43,01,00,00,00,00,00,01,44</p>
<p>[out] 41 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 42</p>
<p>[In] 标定点位第2点，Rece_Buf0[9] =43,02,00,00,00,00,00,02,44</p>
<p>41 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 42</p>
<p>[In] 标定点位第3点，Rece_Buf0[9] =43,03,00,00,00,00,00,03,44</p>
<p>41 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03 42</p>
<p>[In] 标定点位第4点，Rece_Buf0[9] =43,04,00,00,00,00,00,04,44  </p>
<p>41 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 42</p>
<p>[In] 标定点位第5点，Rece_Buf0[9] =43,05,00,00,00,00,00,05,44 </p>
<p>41 05 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 05 42</p>
<p>[In] 标定点位第6点，Rece_Buf0[9] =43,06,00,00,00,00,00,06,44 </p>
<p>41 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 42</p>
<p>[In] 标定点位第7点，Rece_Buf0[9] =43,07,00,00,00,00,00,07,44 </p>
<p>41 07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 07 42</p>
<p>[In] 计算电位的K b，Rece_Buf0[9] =43,08,00,00,00,00,00,08,44</p>
<p>41 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 42</p>
<p>标定完成采集第0个通道的信息<br>放大器短接 真是电压0<br>[In] 43,14,1,0,0,0,0,15,44<br>41 14 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 14 42</p>
<p>41 14 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 14 42 </p>
<h4 id="标定第1通道"><a href="#标定第1通道" class="headerlink" title="标定第1通道"></a>标定第1通道</h4><p>标定点位第1点，Rece_Buf0[9] = 0x43,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x44<br>标定点位第2点，Rece_Buf0[9] = 0x43,0x02,0x00,0x00,0x00,0x01,0x00,0x02,0x44<br>标定点位第3点，Rece_Buf0[9] = 0x43,0x03,0x00,0x00,0x00,0x01,0x00,0x03,0x44<br>标定点位第4点，Rece_Buf0[9] = 0x43,0x04,0x00,0x00,0x00,0x01,0x00,0x04,0x44<br>标定点位第5点，Rece_Buf0[9] = 0x43,0x05,0x00,0x00,0x00,0x01,0x00,0x05,0x44<br>标定点位第6点，Rece_Buf0[9] = 0x43,0x06,0x00,0x00,0x00,0x01,0x00,0x06,0x44<br>标定点位第7点，Rece_Buf0[9] = 0x43,0x07,0x00,0x00,0x00,0x01,0x00,0x07,0x44<br>计算电位的K b，Rece_Buf0[9] = 0x43,0x08,0x00,0x00,0x00,0x01,0x00,0x08,0x44 </p>
<p>标定点位第1点，Rece_Buf0[9] = 43,01,00,00,00,01,00,01,44<br>标定点位第2点，Rece_Buf0[9] = 43,02,00,00,00,01,00,02,44<br>标定点位第3点，Rece_Buf0[9] = 43,03,00,00,00,01,00,03,44<br>标定点位第4点，Rece_Buf0[9] = 43,04,00,00,00,01,00,04,44<br>标定点位第5点，Rece_Buf0[9] = 43,05,00,00,00,01,00,05,44<br>标定点位第6点，Rece_Buf0[9] = 43,06,00,00,00,01,00,06,44<br>标定点位第7点，Rece_Buf0[9] = 43,07,00,00,00,01,00,07,44<br>计算电位的K b，Rece_Buf0[9] = 43,08,00,00,00,01,00,08,44</p>
<h4 id="第0通道标定前-修改后的。"><a href="#第0通道标定前-修改后的。" class="headerlink" title="第0通道标定前 修改后的。"></a>第0通道标定前 修改后的。</h4><p>采集信号: 43,14,1,0,0,0,0,15,44<br>41 14 80 FF 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 6B 42 </p>
<h4 id="第0通道标定后-修改后的"><a href="#第0通道标定后-修改后的" class="headerlink" title="第0通道标定后 修改后的"></a>第0通道标定后 修改后的</h4><p>41 14 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 14 42 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void counter_ad_R(uint8 nn)		  //nn 为通道 （0~7）</span><br><span class="line">&#123;</span><br><span class="line">    uint8 i;</span><br><span class="line">	<span class="built_in">float</span> xdata x;</span><br><span class="line">	<span class="built_in">float</span> xdata y;</span><br><span class="line">    <span class="built_in">float</span> xdata EX;  //x的平均值</span><br><span class="line">    <span class="built_in">float</span> xdata EY;  //y的平均值</span><br><span class="line">    <span class="built_in">float</span> xdata EXY; //xi*yi 乘积和</span><br><span class="line">    <span class="built_in">float</span> xdata EXX; //xi平方和</span><br><span class="line"></span><br><span class="line">	EX=0;</span><br><span class="line">	EY=0;</span><br><span class="line">	EXY=0;</span><br><span class="line">	EXX=0;</span><br><span class="line">	<span class="keyword">for</span>(i=0;i&lt;7;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    x=ad_buf[i];</span><br><span class="line">		EX+=x;</span><br><span class="line">		y=para_temp[i];</span><br><span class="line">		EY+=y;</span><br><span class="line">		EXX+=(x*x);</span><br><span class="line">		EXY+=(x*y);</span><br><span class="line">	&#125;</span><br><span class="line">	EX/=7;</span><br><span class="line">	EY/=7;</span><br><span class="line">	kk[nn]=(EXY-EX*EY*7)/(EXX-EX*EX*7);</span><br><span class="line">	bb[nn]=EY-kk[nn]*EX; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下行命令:<br>    43,14,08,02,02,01,01,1c,44</p>
<p>上行数据：<br>    41 14 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 01 C5 01 C5 01 C5 01 C5 01 C5 01 C5 14 42<br>    41 14 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 03 7F 03 7F 03 7F 03 7F 03 7F 03 7F 14 42</p>
<p>上行数据很乱是因为没有标定。</p>
<h2 id="docer-容器上传数据"><a href="#docer-容器上传数据" class="headerlink" title="docer 容器上传数据"></a>docer 容器上传数据</h2><p>登录容器<br> docker exec -it 2c3bd1d2b1a0 /bin/sh</p>
<p>上传文件夹<br>docker cp /root/LSTM-Human-Activity-Recognition-master/ 2c3bd1d2b1a0:/tf</p>
]]></content>
      <tags>
        <tag>C8051F020</tag>
      </tags>
  </entry>
  <entry>
    <title>调试下位机2</title>
    <url>/2019/08/06/%E8%B0%83%E8%AF%95%E4%B8%8B%E4%BD%8D%E6%9C%BA2/</url>
    <content><![CDATA[<h3 id="5芯航空插头"><a href="#5芯航空插头" class="headerlink" title="5芯航空插头"></a>5芯航空插头</h3><p>5芯航空插头 只用了4个接头 2跟接正负16V的电源，2跟接输出信号。电源来自板子的电源插头。</p>
<h4 id="0806-调试记录"><a href="#0806-调试记录" class="headerlink" title="0806 调试记录"></a>0806 调试记录</h4><pre><code>43,14,08,02,02,01,01,1c,44

41 14 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 01 C5 01 C5 01 C5 01 C5 01 C5 01 C5 14 42 
41 14 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 03 7F 03 7F 03 7F 03 7F 03 7F 03 7F 14 42</code></pre><p>那28个数据是1-8电位  2光子  2Rt  t  H<br>是按顺序排列的  但是每种数据采几个是由上位机决定的<br>每个数据时16位 两字节 高位在前低位在后 应该都是float型<br> <a id="more"></a></p>
<p>至于数据为什么这么奇怪我分析应该是数据没有标定  标定的数据时存在flash里的  每次输出的时候需要将这个数据跟flash里的数据进行运算 而flash里默认为ff 在计算的时候数据溢出 就会出现前8个数据都一样 后边的数据乱七八糟<br>前8个数据的计算方法是一样的</p>
<p>放大器传回来的数据是 unsigned int 类型的。需要转换float类型。而且需要乘上一个系数，这个系数就是标定的值。</p>
]]></content>
  </entry>
  <entry>
    <title>调试下位机</title>
    <url>/2019/08/05/%E8%B0%83%E8%AF%95%E4%B8%8B%E4%BD%8D%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="接收缓冲数组"><a href="#接收缓冲数组" class="headerlink" title="接收缓冲数组"></a>接收缓冲数组</h3><p>uint8  idata Rece_Buf0[9];  //接收缓冲数组</p>
<p>Rece_Buf0[9] = [0,1,2,3,4,5,6,7,8]</p>
<h4 id="Rece-Buf0-0-0x43-是帧头的信息，必须等于0x43"><a href="#Rece-Buf0-0-0x43-是帧头的信息，必须等于0x43" class="headerlink" title="Rece_Buf0[0] = 0x43 是帧头的信息，必须等于0x43"></a>Rece_Buf0[0] = 0x43 是帧头的信息，必须等于0x43</h4><h4 id="Rece-Buf0-1-0x14-是下位机执行的命令，通过switch，case语句来判断Rece-Buf0-1-的值，对应值在命令表里面。关键语句："><a href="#Rece-Buf0-1-0x14-是下位机执行的命令，通过switch，case语句来判断Rece-Buf0-1-的值，对应值在命令表里面。关键语句：" class="headerlink" title="Rece_Buf0[1] = 0x14 是下位机执行的命令，通过switch，case语句来判断Rece_Buf0[1]的值，对应值在命令表里面。关键语句："></a>Rece_Buf0[1] = 0x14 是下位机执行的命令，通过switch，case语句来判断Rece_Buf0[1]的值，对应值在命令表里面。关键语句：</h4><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  switch(Rece_Buf0[1])    </span><br><span class="line">  <span class="keyword">case</span> 0x14:</span><br><span class="line">Work_Flag=1;  //采集标志位</span><br></pre></td></tr></table></figure></code></pre><a id="more"></a>

<h4 id="Rece-Buf0-2-7-8-2-2-1-1-的值先给他设定为返回全部通道的数值"><a href="#Rece-Buf0-2-7-8-2-2-1-1-的值先给他设定为返回全部通道的数值" class="headerlink" title="Rece_Buf0[2:7] = [8,2,2,1,1] 的值先给他设定为返回全部通道的数值"></a>Rece_Buf0[2:7] = [8,2,2,1,1] 的值先给他设定为返回全部通道的数值</h4><!--more-->

<pre><code>Rece_Buf0[2,3,4,5,6]里面放的是下行数据，5个字节。

当 Rece_Buf0[2]==1||Rece_Buf0[2]==2||Rece_Buf0[2]==3||Rece_Buf0[2]==4 会返回对应通道的电信号。

Rece_Buf0[2]==5，Rece_Buf0[2]==6，Rece_Buf0[2]==7， Rece_Buf0[2]==8 分别返回5 6 7 8 路电位

Rece_Buf0[3]==1 Rece_Buf0[3]==2  分别返回 1 2 路光量子

Rece_Buf0[4]==1 Rece_Buf0[4]==2  返回Rt 

Rece_Buf0[5]==1 返回  t

Rece_Buf0[6]==1  返回 H</code></pre><p>根据接受来的Rece_Buf0[2,3,4,5,6]值，来执行对应的发送数据请求。根据下面的函数可以看出来返回的数值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Work_Flag==1)	   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Rece_Buf0[2]==1||Rece_Buf0[2]==2||Rece_Buf0[2]==3||Rece_Buf0[2]==4)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=0;i&lt;Rece_Buf0[2];i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ad_val(i);								</span><br><span class="line">                Ech_val(i);</span><br><span class="line">            &#125;							</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Rece_Buf0[2]==5)  //5路电位</span><br><span class="line">        &#123;</span><br><span class="line">            CHA=0; </span><br><span class="line">            Delay_ms(5); </span><br><span class="line">            <span class="keyword">for</span>(i=0;i&lt;5;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                    ad_val(i);</span><br><span class="line">                    Ech_val(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Rece_Buf0[2]==6)//6路电位</span><br><span class="line">        &#123;</span><br><span class="line">            CHA = 0;</span><br><span class="line">            CHB = 0;</span><br><span class="line">            Delay_ms(5);</span><br><span class="line">            <span class="keyword">for</span>(i=0;i&lt;6;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ad_val(i);</span><br><span class="line">                Ech_val(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Rece_Buf0[2]==7) //7路电位</span><br><span class="line">        &#123;</span><br><span class="line">            CHA = 0;</span><br><span class="line">            CHB = 0;</span><br><span class="line">            CHC = 0;</span><br><span class="line">            Delay_ms(5);</span><br><span class="line">            <span class="keyword">for</span>(i=0;i&lt;7;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ad_val(i);</span><br><span class="line">                Ech_val(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Rece_Buf0[2]==8)//8路电位</span><br><span class="line">        &#123;</span><br><span class="line">            CHA = 0;</span><br><span class="line">            CHB = 0;</span><br><span class="line">            CHC = 0;</span><br><span class="line">            CHD = 0;</span><br><span class="line">            Delay_ms(5);</span><br><span class="line">            <span class="keyword">for</span>(i=0;i&lt;8;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ad_val(i);</span><br><span class="line">                Ech_val(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Rece_Buf0[3]==1) //1路光量子</span><br><span class="line">        &#123;</span><br><span class="line">            CHA = 1;</span><br><span class="line">            Delay_ms(5);</span><br><span class="line">            ad_val(4);</span><br><span class="line">            Lch_val(8);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Rece_Buf0[3]==2)</span><br><span class="line">        &#123;</span><br><span class="line">            CHA = 1;</span><br><span class="line">            CHB = 1;</span><br><span class="line">            Delay_ms(5);</span><br><span class="line">            ad_val(4);</span><br><span class="line">            Lch_val(8);</span><br><span class="line">            ad_val(5);</span><br><span class="line">            Lch_val(9);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Rece_Buf0[4]==1) //Rt</span><br><span class="line">        &#123;</span><br><span class="line">            CHC = 1;</span><br><span class="line">            CHZ = 0;</span><br><span class="line">            Delay_ms(5);</span><br><span class="line">            Delay_ms(5);</span><br><span class="line">            ad_val(6);</span><br><span class="line">            Tch_val(10);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Rece_Buf0[4]==2)</span><br><span class="line">        &#123;</span><br><span class="line">            CHC = 1;</span><br><span class="line">            CHZ = 0;</span><br><span class="line">            CHD = 1;</span><br><span class="line">            CHX = 0;</span><br><span class="line">            Delay_ms(5);</span><br><span class="line">            ad_val(6);</span><br><span class="line">            Tch_val(10);</span><br><span class="line">            ad_val(7);</span><br><span class="line">            Tch_val(11);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Rece_Buf0[5]==1)		//t</span><br><span class="line">        &#123;</span><br><span class="line">            CHC = 1;</span><br><span class="line">            CHZ = 1;					  </span><br><span class="line">            Delay_ms(5);</span><br><span class="line">            ad_val(6);</span><br><span class="line">            THch_val(12);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Rece_Buf0[6]==1)			//H</span><br><span class="line">        &#123;</span><br><span class="line">            CHD = 1;</span><br><span class="line">            CHX = 1; </span><br><span class="line">            Delay_ms(5);</span><br><span class="line">            ad_val(7);</span><br><span class="line">            THch_val(13);</span><br><span class="line">        &#125;						 								</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Rece-Buf0-7-XOR-数组第1位到第6位，6个数值的异或和"><a href="#Rece-Buf0-7-XOR-数组第1位到第6位，6个数值的异或和" class="headerlink" title="Rece_Buf0[7] = XOR  数组第1位到第6位，6个数值的异或和"></a>Rece_Buf0[7] = XOR  数组第1位到第6位，6个数值的异或和</h4><h4 id="Rece-Buf0-8-0x44-帧尾"><a href="#Rece-Buf0-8-0x44-帧尾" class="headerlink" title="Rece_Buf0[8] = 0x44 帧尾"></a>Rece_Buf0[8] = 0x44 帧尾</h4><p>然后创建Send_Buf0[36]数组进行数据发送</p>
<h3 id="串口助手返回的值"><a href="#串口助手返回的值" class="headerlink" title="串口助手返回的值"></a>串口助手返回的值</h3><p>注意：在计算6个数的XOR的时候，原始数据是16进制的，要转换为10进制在计算。<br>input: 43,14,8,2,2,1,1,1c,44<br>output:<br>    [1] : 41 14 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 00 00 00 00 00 FF 00 FF 00 FF 00 FF 14 42<br>    [2] : 41 14 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 04 30 04 30 04 30 04 30 04 30 04 30 14 42 </p>
<p>tip：<br>    我重启串口助手 再点击发送数据<br>    返回 给我的数据不一样。</p>
<pre><code>41 14 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 05 99 05 99 05 99 05 99 05 99 05 99 14 42

41 14 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 80 FF 05 40 05 40 05 40 05 40 05 40 05 40 14 42</code></pre><h4 id="航空插头"><a href="#航空插头" class="headerlink" title="航空插头"></a>航空插头</h4><p>5芯航空插头 是不是需要给前置放大传感器 供电？？</p>
<p>之前测量前置放大器的时候，记得是有电压的。。。</p>
<p>原来系统里前置放大器的电压是拿来的？希望不是班子给供电。。。</p>
]]></content>
      <tags>
        <tag>C8051F020</tag>
      </tags>
  </entry>
  <entry>
    <title>文献阅读</title>
    <url>/2019/08/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h2><p>对于很多任务，我们很难知道应该提取哪些特征，例如，假如我们想编写一个程序来检测照片中的车，但是我们很难根据像素值来给车轮定义。解决这个问题的途径之一就是使用机器学习来发掘表示本身，而不仅仅把表示映射到输出，这种方法称为表示学习。</p>
<h3 id="自编码器"><a href="#自编码器" class="headerlink" title="自编码器"></a>自编码器</h3><p>表示学习的典型例子就是自编码器（autoencoder）。自编码器由一个编码器(encoder)函数和一个解码器(decoder)函数组成。编码器函数将输入数据转换为一种不同的表示，而解码器函数则将这个新的表示转换回原来的形式。我们希望当输入数据经过编码器和解码器之后尽可能多地保留原有信息，同时希望新的表示有更好的特征，这也是自编码器的训练目标。</p>
<p>P 480 </p>
<p><a href="https://zhuanlan.zhihu.com/p/39140472" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39140472</a></p>
]]></content>
  </entry>
  <entry>
    <title>tensorflow_docker</title>
    <url>/2019/08/01/tensorflow-docker/</url>
    <content><![CDATA[<p>因为需要要安装tensorflow1.13，但是anaconda的虚拟环境不好用。所以使用Docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull tensorflow/tensorflow</span><br></pre></td></tr></table></figure>

<p>Docker Pull Command</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -rm -v $(realpath ~/notebooks):/tf/notebooks -p 8999:8888 tensorflow/tensrflow:latest-py3-jupyter</span><br></pre></td></tr></table></figure>

<p>Run a jupyter notebook server with your own notebook directory (assumed here to be ~/notebooks).<br>To use it, navigate to localhost:8888 in you browers</p>
]]></content>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title>seq_2_seq</title>
    <url>/2019/07/29/seq-2-seq/</url>
    <content><![CDATA[<p>学习seq to seq 的模型，先学会使用模型，把电信号数据修改成相匹配的格式，喂进模型去。</p>
<p>这是一个汉译英的demo。原始数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> inputs    targets</span><br><span class="line">0     Hi.     \t嗨。\n</span><br><span class="line">1     Hi.    \t你好。\n</span><br><span class="line">2    Run.  \t你用跑的。\n</span><br><span class="line">3   Wait!    \t等等！\n</span><br><span class="line">4  Hello!    \t你好。\n</span><br></pre></td></tr></table></figure>

<h2 id="demo-定义的变量所代表的含义。"><a href="#demo-定义的变量所代表的含义。" class="headerlink" title="demo 定义的变量所代表的含义。"></a>demo 定义的变量所代表的含义。</h2><p>input_text len: 1000 type: list  print(input_texts[1:5])<br>            [‘Hi.’, ‘Run.’, ‘Wait!’, ‘Hello!’]</p>
<p>output_text len: 1000 type: list print(target_texts[1:5])<br>        [‘\t你好。\n’, ‘\t你用跑的。\n’, ‘\t等等！\n’, ‘\t你好。\n’]</p>
<p>NUM_SAMPLES = 1000 样本的数量</p>
<p>input_characters 英文的总字符, list类型<br>target_characters 汉语的总字符, list类型<br>INUPT_LENGTH 30，最长的英语句子，1000个样本中，int类型<br>OUTPUT_LENGTH 22，最长的中文句子，1000个样本中，int类型<br>INPUT_FEATURE_LENGTH  73，英文的总字符数，int类型<br>OUTPUT_FEATURE_LENGTH 2623， 中文的总字符数，int类型</p>
]]></content>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title>电池连线</title>
    <url>/2019/07/28/%E7%94%B5%E6%B1%A0%E8%BF%9E%E7%BA%BF/</url>
    <content><![CDATA[<p>买了两块8.4V 电池。<br>用杜邦线串联起来。<br>电池还需要边冲边用。</p>
<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>用杜邦线的时候用完表测一下线通不通。</p>
]]></content>
  </entry>
  <entry>
    <title>采集周期出现问题</title>
    <url>/2019/07/27/%E9%87%87%E9%9B%86%E5%91%A8%E6%9C%9F%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在仪器上设置的采集周期无论是多少ms，最后保存的csv文件一分钟都是300个点。<br>检查了一下下位机的代码，发现可能是因为保存数据的数组在case语句里面，每次发送数据的时候没有全部更新。</p>
<p>采集植物电需要的频率：5HZ 或 10HZ</p>
<p>需要调试下位机。</p>
<h3 id="MCGS-存储量有限"><a href="#MCGS-存储量有限" class="headerlink" title="MCGS 存储量有限"></a>MCGS 存储量有限</h3><p>在交接文档里明确说明只能存储30000行数据，因此无法满足4个小时的数据采集。<br>所以需要写PC端的上位机</p>
]]></content>
  </entry>
  <entry>
    <title>multi-channel system Debug</title>
    <url>/2019/07/25/multi-channel-system-Debug/</url>
    <content><![CDATA[<p>1 min —&gt; 60 s<br>2s –&gt; 1一个点<br>1min —&gt; 30个点<br>20min —&gt; 600</p>
<p>现在采集到的数据一个周期5880个点<br>设置的是2000ms采集一个点。</p>
]]></content>
      <tags>
        <tag>multi-channel system</tag>
      </tags>
  </entry>
  <entry>
    <title>LSTM params</title>
    <url>/2019/07/23/LSTM-params/</url>
    <content><![CDATA[<p>重新理解LSTM结构</p>
<p>把lstm里面的四个激活单元，当作是全连接网络。</p>
]]></content>
      <tags>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>california_housing</title>
    <url>/2019/07/21/california-housing/</url>
    <content><![CDATA[<h2 id="california-dataset"><a href="#california-dataset" class="headerlink" title="california dataset"></a>california dataset</h2><p>x.shape   (20640,8)<br>y.shape   (20640,)</p>
<p>model.add(keras.layers.Dense(layer_size, activation=’relu’,<br>input_shape=(8,)))</p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><pre><code>-MedInc        median income in block
- HouseAge      median house age in block
- AveRooms      average number of rooms
- AveBedrms     average number of bedrooms
- Population    block population
- AveOccup      average house occupancy
- Latitude      house block latitude
- Longitude</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|MedInc|HouseAge|AveRooms|AveBedrms|Population|AveOccup|Latitude|Longitude</span><br><span class="line">	0	1	2	3	4	5	6	7</span><br><span class="line">0	7.0671	11	7.64354067	0.980861244	1774	4.244019139	37.34	-121.78</span><br><span class="line">1	2.3267	12	5.016483516	1.267857143	1677	2.303571429	33.14	-117.19</span><br><span class="line">2	1.9893	19	4.083499006	1.0944334	2971	2.953280318	32.79	-116.97</span><br><span class="line">3	4.1026	25	3.549682875	0.993657505	1314	2.778012685	33.65	-117.92</span><br><span class="line">4	3.8333	48	5.234200743	1.096654275	891	3.312267658	37.76	-122.5</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mc</tag>
      </tags>
  </entry>
  <entry>
    <title>ReadMulCsvToOneDataFrame</title>
    <url>/2019/07/17/ReadMulCsvToOneDataFrame/</url>
    <content><![CDATA[<p>读取一个csv文件的数据，放在列表里面。<br>并把这个列表的数据放到一个DataFrame里，这是一个多列的矩阵。可以参考</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#creating and plotting the data</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#creating some data - we will create a sinus and a sinus * sinus function</span></span><br><span class="line"><span class="built_in">shift</span> = 7</span><br><span class="line">trainLength = 800</span><br><span class="line">totalLength = 1200</span><br><span class="line"></span><br><span class="line">data = np.empty((1,totalLength,2)) <span class="comment">#0 to 1199</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#x for the first sinus</span></span><br><span class="line">base1 = np.array(range(totalLength))*(30*math.pi/totalLength) <span class="comment">#30*pi means 15 complete oscilations</span></span><br><span class="line"><span class="comment">#the first sinus</span></span><br><span class="line">data[0,:,0] = np.sin(base1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#x for the second sinus - this reflects in a sinus with a different frequency</span></span><br><span class="line">base2 = 0.8*base1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#the first * the second sinus </span></span><br><span class="line">data[0,:,1] = (np.sin(base1)+np.sin(base2))/2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'data: '</span>, data.shape)</span><br></pre></td></tr></table></figure>

<p>这样做的目的可以把原始的csv数据，放到一个csv里面，这样方便观察数据。</p>
<p>其实手动放置现有的数据是很方便的，可以不用浪费时间研究这个函数。。。</p>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>“TypeError: unhashable type: ‘numpy.ndarray’”</p>
<p>再利用for循环读取一个文件夹里的csv的时候，报的错误。</p>
<p>原因：csv文件名有中文。。。。。。<br>注：报的错误真的好坑啊。。。</p>
]]></content>
  </entry>
  <entry>
    <title>LSTM文献阅读</title>
    <url>/2019/07/09/LSTM%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="LSTM分析EEG"><a href="#LSTM分析EEG" class="headerlink" title="LSTM分析EEG"></a>LSTM分析EEG</h2><p>然而，脑电序列通常较长，直接用来训练LSTM模型所需的计算资源非常大且学习到的信息类型单一，而且忽略了许多对情绪识别非常重要的信息，如频域信息和非线性动力学信息。为此提出一种新的基于LSTM的情绪识别模型。脑电信号被分成多个非重叠的信号段，并从每段信号中提取多种时域，频域和非线性动力学特征，这些特征沿时间连接成特征序列并用来训练LSTM分类模型。在DEAP数据集上验证了该模型在愉悦度，唤醒度和喜欢度上的二分类准确率，其中每个情绪维度分为低和高两类。实验结果表明，该模型在愉悦度和喜欢度上的分类准确率均优于已有方法，在唤醒度上的分类准确率仅次于最先进的成果。</p>
<h2 id="一些大数据比赛"><a href="#一些大数据比赛" class="headerlink" title="一些大数据比赛"></a>一些大数据比赛</h2><p><img src="http://i1.fuimg.com/692414/5c04347e49ae9a86.png" alt="Markdown"><br>看论文：<br><a href="https://doi.org/10.1007/978-3-030-20521-8_12" target="_blank" rel="noopener">https://doi.org/10.1007/978-3-030-20521-8_12</a></p>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>windows配置tensorflow完结</title>
    <url>/2019/07/08/windows%E9%85%8D%E7%BD%AEtensorflow%E5%AE%8C%E7%BB%93/</url>
    <content><![CDATA[<h2 id="cuda1-10"><a href="#cuda1-10" class="headerlink" title="cuda1.10"></a>cuda1.10</h2><p>今天尝试安装cuda1.10版本。为什么会安装这个版本的cuda，是因为在执行下列语句后会提示缺少cuda ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install tensorflow</span><br><span class="line">import tensorflow</span><br></pre></td></tr></table></figure>

<p>提示安装cuda1.10<br>于是按照tf2和tf1最新版都是同一时刻发布的，于是尝试下cuda10可否支持tf2。经过验证是可行的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>cuda的版本很重要</p>
]]></content>
      <categories>
        <category>install</category>
      </categories>
      <tags>
        <tag>install tf</tag>
      </tags>
  </entry>
  <entry>
    <title>和仪器的作者交流</title>
    <url>/2019/07/07/%E5%89%8D%E7%BD%AE%E6%94%BE%E5%A4%A7%E5%99%A8/</url>
    <content><![CDATA[<p>今天把李婷师姐请到实验室，具体问了一下关于仪器详细的使用情况，因为这台仪器是李婷师姐的本科毕业设计。</p>
<h2 id="课程设计"><a href="#课程设计" class="headerlink" title="课程设计"></a>课程设计</h2><p>因为需要带本科生的课程设计，今天自己把软件重新安装上，熟悉以下课程设计内容。</p>
]]></content>
  </entry>
  <entry>
    <title>8通道数据采集</title>
    <url>/2019/07/06/8%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/</url>
    <content><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>现在一次实验可以采集4株小麦，一天最多测12株小麦。一个月360株。数据量有点小，训练的模型容易过拟合。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><a id="more"></a>
<p>和黄老师沟通后可以采用李婷师姐本科毕设的项目，8通道植物电信号采集仪，一个月可以测720株。</p>
<h3 id="仪器的前置放大器"><a href="#仪器的前置放大器" class="headerlink" title="仪器的前置放大器"></a>仪器的前置放大器</h3><p>仪器现在无法采集数据，也无法校准为0。<br>子洋师兄过来教我怎么使用仪器，并确定前置放大器有问题，需要找王老师修。<br>请王老师看了下前置放大器，老师测量前置放大器的电压不够，判定是电源的电压不够8.4V，实际测量后验证了老师的想法。接下来我找电源，电源是8.4V后，前置放大器还是不可以正常校准为0，并且电压也正常。</p>
<h2 id="学习焊元器件"><a href="#学习焊元器件" class="headerlink" title="学习焊元器件"></a>学习焊元器件</h2><p>范师兄演示更换前置放大器的两个电源芯片：78L06、79L06<br><img src="http://i2.tiimg.com/692414/a96232f575863507.jpg" alt="Markdown"></p>
<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>在范师兄的指导下，自己独立换了电位器。<br>拔的时候掉了一个焊环，是因为焊锡少。<br>用了快30分钟，比计算机配置环境还费时间。</p>
<h4 id="电路板不会报错误信息，调试费劲！！！！！！"><a href="#电路板不会报错误信息，调试费劲！！！！！！" class="headerlink" title="电路板不会报错误信息，调试费劲！！！！！！"></a>电路板不会报错误信息，调试费劲！！！！！！</h4>]]></content>
      <categories>
        <category>PCB</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>安装tensorflow-gpu</title>
    <url>/2019/07/04/%E5%AE%89%E8%A3%85tensorflow-gpu/</url>
    <content><![CDATA[<h2 id="vs2015-cuda-tensorflow-编译的方法安装cuda"><a href="#vs2015-cuda-tensorflow-编译的方法安装cuda" class="headerlink" title="vs2015+cuda+tensorflow 编译的方法安装cuda"></a>vs2015+cuda+tensorflow 编译的方法安装cuda</h2><p>windows查找对应的cuda版本<br>今天在网上查到：</p>
<p>在NVIDAI显卡驱动里可以找到相对应的cuda版本为：10.1.131。但是官方没有这个版本的cuda，先测试高版本的<a href="https://developer.nvidia.com/cuda-downloads?target_os=Windows&target_arch=x86_64&target_version=10&target_type=exelocal" target="_blank" rel="noopener">cuda_cuda_10.1.168</a>。</p>
<p>并下载对应的vs版本,尝试使用编译的方法安装，安装过程出现意外的BUG，解决BUG后继续安装。</p>
]]></content>
      <categories>
        <category>install</category>
      </categories>
      <tags>
        <tag>install tf</tag>
      </tags>
  </entry>
  <entry>
    <title>install tensorflow-2.0-gpu</title>
    <url>/2019/07/03/install-tensorflow-2-0-gpu/</url>
    <content><![CDATA[<p>How to install tensoflow-gpu on windows10</p>
<p>Use conda to create a TF2 virtual environment, python version is 3.6, use pip to install tensorflow, and in the import tensorflow according to the error prompt, install the corresponding cuda version.</p>
<p>The following are the instructions used.</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create tf2.0</span><br><span class="line">pip install tensorflow-gpu==2.0.0-alpha0</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>安装完tensorflow2.0 在import tensorflow报错不会提示需要cuda的版本。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>这个BUG网上找不到，于是换个思路：<br>安装不上2.0，安装1.0版本也可以。<br>执行下列代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create tf1.0</span><br><span class="line">pip install tensorflow</span><br></pre></td></tr></table></figure>

<p>进入python后，执行import tensorflow，报错需要安装cuda8.0版本。<br>安装好cuda8.0后。import tensorflow继续报同样的错误。。。。。。。。</p>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>1、可能是conda的原因，因为之前在Linux装软件的时候，用conda就会遇到奇怪的问题。<br>2、cuda没有成功</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>先验证第二个原因，在网上找到如何验证成功安装cuda，发现成功安装cuda。接下来把conda卸载，自己手动安装python。</p>
]]></content>
  </entry>
  <entry>
    <title>刺激后的信号比较像</title>
    <url>/2019/07/02/%E5%88%BA%E6%BF%80%E5%90%8E%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%AF%94%E8%BE%83%E5%83%8F/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天突然想到可以把整理的刺激前和刺激后的数据画出来，看一下。发现DK小麦在刺激后的电位都在一个范围内，感觉波形比较固定。但是刺激前的波形变化很大，每一株DK小麦的电信号都不太像<br>&lt;!more&gt;</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>阅读薛琳师姐和王老师的大论文。</p>
<a id="more"></a>
<h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><p>王老师的博士论文就是做电信号采集，数据分析，用到BP神经网络找环境因子和电信号之间关系权重。我感觉就是用tensorflow写一个一个全连接层就可以完成。<br>黄老师做的是红外光谱检测脑氧，用到蒙特卡洛仿真。我不太能看懂，在网上搜了下蒙特卡洛仿真的代码，看上去好简单，感觉搜索的不对，下次有能力和老师请教下这个问题。另外。黄老师也说蒙特卡洛仿真需要一个月的时间，范师兄和三师兄都用到蒙特卡罗。</p>
]]></content>
  </entry>
  <entry>
    <title>Long short-term memory</title>
    <url>/2019/07/01/Long-short-term-memory/</url>
    <content><![CDATA[<p>今天阅读了1997年提出的lstm，重新理解了网络结构，但是没有什么新的发现。</p>
]]></content>
      <categories>
        <category>machine learing</category>
      </categories>
      <tags>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>是否使用LSTM</title>
    <url>/2019/06/30/%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86-7/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我要做的是用红框里的一个周期数据（刺激前）预测绿框里的一个周期数据（刺激后），一个周期是588个点。<br>参考LSTM预测股票、污染，发现一个结论：<br>刺激前的数据和刺激后的数据不在同一个时刻上，如果单纯的在数据上做一一对应，我认为没有可解释性。因为这两个数据本身是有一个先后顺序的。<br><img src="http://i2.tiimg.com/692414/c864ab7be8ba9931.jpg" alt="Markdown"><br> <a id="more"></a></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p> 黄老师说话，仔细思考下。<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lstm 长-短时记忆，是可以用于预测一定时间内的时间序列变化。</span><br><span class="line">你看看颜小飞的硕士论文，就知道为这些网络们可以用在各类电信号的预测上了</span><br><span class="line">反而是现在用这些网络预测什么股票、污染解释性更差些</span><br><span class="line">各类电信号的预测上了</span><br><span class="line">各类电信号:动物电信号，植物电信号</span><br><span class="line">神经元、细胞（通道门的的激活）--人工神经元---激活函数</span><br><span class="line">细胞的连接---人工神经元的连接</span><br><span class="line">细胞的连接的强弱---人工神经元的连接（权重）</span><br><span class="line">细胞输入（各种刺激）----人工神经元（各种特征或者各时刻的特征）</span><br></pre></td></tr></table></figure></p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p> 看颜小飞的硕士论文，针对性的了解lstm内部结构，找到lstm提出者的文章，打印出来。</p>
<h2 id="多通道采集电信号"><a href="#多通道采集电信号" class="headerlink" title="多通道采集电信号"></a>多通道采集电信号</h2><p>现在的设备只能4通道采集电信号，效率低。<br>我可以在子洋师兄和李婷师姐做的板子的基础上参考。</p>
<p>今天安装了18版本AD软件，发现做PCB有点复杂，子洋师兄的电路图看不懂。</p>
<h4 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h4><p>1、学习基础：<br>        熟悉软件的基本使用，跟着教程做一些简单的例子。<br>2、请教子洋师兄，搞懂每一个模块的作用。<br>………</p>
]]></content>
      <categories>
        <category>machine learing</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>制作数据集(6)</title>
    <url>/2019/06/29/%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86-6/</url>
    <content><![CDATA[<p>今天复习了LSTM预测北京机场的污染预测，有新的收获。<br>预测PM2.5 是一个多因素的问题，就是有8个x —&gt; y<br>很长的代码是在处理数据，即把原始的数据变成<br>x1(t-1),x2(t-1),x3(t-1)…x8(t-1) y(t)<br>k
其中x1(t-1) = y(t-1)</p>
<p>trainx = x1(t-1),x2(t-1),x3(t-1)…x8(t-1)<br>trainy = y</p>
<p>在model.add(LSTM)，inputshape=(8,1)<br>只有一层LSTM<br> <a id="more"></a></p>
<h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><p>在我制作的数据集中：<br>x代表a波，是一个(n<em>588，1)的矩阵<br>y代表c波，是一个(n</em>588，1)的矩阵</p>
<p>x(t-1) –&gt;y</p>
<p>我是不是输出的时候把y转换成(588,1)</p>
]]></content>
      <categories>
        <category>machine learing</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>制作数据集(5)</title>
    <url>/2019/06/28/%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86-5/</url>
    <content><![CDATA[<p>今天把之前写的代码组合成为一个函数，可以直接调用，代码更清爽。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">def read_csv(inputdir):</span><br><span class="line">    df = pd.read_csv(inputdir, header=None, usecols=[1])</span><br><span class="line">    df = df.drop(index=[0, 1])</span><br><span class="line">    df = df.astype(<span class="built_in">float</span>)</span><br><span class="line">    <span class="built_in">return</span> df</span><br><span class="line"></span><br><span class="line">def x_split_one_csv(df, befor_start, cycle):</span><br><span class="line">    befor_end = befor_start + (cycle * 588)</span><br><span class="line">    x = df[befor_start:befor_end]</span><br><span class="line">    x = x.astype(<span class="built_in">float</span>)</span><br><span class="line">    <span class="built_in">return</span> x</span><br><span class="line"></span><br><span class="line">def y_split_one_csv(df, after_start, cycle):</span><br><span class="line">    after_end = after_start + (cycle * 588)</span><br><span class="line">    y = df[after_start:after_end]</span><br><span class="line">    y = y.astype(<span class="built_in">float</span>)</span><br><span class="line">    <span class="built_in">return</span> df_after</span><br><span class="line"></span><br><span class="line">def plt_wave(df):</span><br><span class="line">    pd.DataFrame(df).plot(figsize=(8,5))</span><br><span class="line">    plt.grid(True)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">def merge(stress_befor, stress_after):</span><br><span class="line">    outfile = stress_befor.append(stress_after)</span><br><span class="line">    outfile = outfile.astype(<span class="built_in">float</span>)</span><br><span class="line">    <span class="built_in">return</span> outfile</span><br></pre></td></tr></table></figure>

<p>x代表a波，是一个(588,1)的时间序列<br>y代表c波，是一个(588,1)的时间序列</p>
]]></content>
      <categories>
        <category>machine learing</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>制作数据集(4)</title>
    <url>/2019/06/27/%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86-4/</url>
    <content><![CDATA[<h2 id="readcsv-split-trainX-trainY"><a href="#readcsv-split-trainX-trainY" class="headerlink" title="readcsv_split_trainX_trainY"></a>readcsv_split_trainX_trainY</h2><p>今天把区分X和Y的函数写出来，并且可以达到需要的功能。<br>通过往列表插入数据的方式实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">from os import walk</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">def readcsv_split_trainX_trainY(path, cycle):</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string"># path： 文件所在目录</span></span><br><span class="line"><span class="string"># cycle：第几个周期区分X和Y</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"><span class="comment"># 读取文件夹数据</span></span><br><span class="line">    <span class="keyword">for</span> root, <span class="built_in">dirs</span>, files <span class="keyword">in</span> walk(path, topdown=False):</span><br><span class="line">        <span class="built_in">print</span>(files)</span><br><span class="line">    num = len(files)</span><br><span class="line">    <span class="comment"># 创建列表，用于存储x y</span></span><br><span class="line">    x, y = list(), list()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        newdata = pd.read_csv(path + <span class="string">'/%s'</span> % files[i], header=None, usecols=[1])</span><br><span class="line">        newdata = newdata.drop(index=[0])</span><br><span class="line">        newdata = newdata.values</span><br><span class="line">        x_new = newdata[0:cycle*588, 0]</span><br><span class="line">        x_new = x_new.tolist()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(x_new)):</span><br><span class="line">            x.append(x_new[j])</span><br><span class="line">        y_new = newdata[cycle*588:, 0]</span><br><span class="line">        y_new = y_new.tolist()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(y_new)):</span><br><span class="line">            y.append(y_new[j])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> x, y</span><br><span class="line"></span><br><span class="line">x, y = readcsv_split_trainX_trainY(path=<span class="string">'/Users/squareface/Downloads/salt_5880'</span>,cycle=5)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(len(x))</span><br><span class="line"><span class="built_in">print</span>(len(y))</span><br></pre></td></tr></table></figure>

<p>函数输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="string">'DK_6_5880.csv'</span>, <span class="string">'DK_7_5880.csv'</span>, <span class="string">'DK_1_5880.csv'</span>, </span><br><span class="line"><span class="string">'DK_5_5880.csv'</span>, <span class="string">'DK_4_5880.csv'</span>, <span class="string">'DK_2_5880.csv'</span>, <span class="string">'DK_3_5880.csv'</span>]</span><br><span class="line">20580</span><br><span class="line">20580</span><br></pre></td></tr></table></figure>

<h2 id="LIRB波形"><a href="#LIRB波形" class="headerlink" title="LIRB波形"></a>LIRB波形</h2><p>盐刺激前的波形和盐刺激后的波形是有关系的，刺激后的波形是在刺激前的波形基础上变换的。刺激前后的波形好像是有一个方程对应的。</p>
<p>今天老师有说到“参考波”这个名词，a波即参考波。子洋师兄大论文中写到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">本研究提取了 3 个具有代表性的周期波形进行特征提取，</span><br><span class="line">分别是盐胁迫前最后一组完整周期，称为 a 波;</span><br><span class="line">盐胁迫时的第一周期波形，称为 b 波;</span><br><span class="line">盐胁迫 2 小时后的第一组完 整周期，称为 c 波。</span><br><span class="line">一般情况下:</span><br><span class="line">        a 波作为该小麦的参考波，</span><br><span class="line">        b 波是盐胁迫后的第一个波，作为反映小麦响应短期盐胁迫的波，</span><br><span class="line">        c 波作为小麦响应长期盐胁迫的波</span><br><span class="line">因此本文中不同类型小麦 LIRB 在 a 波和 b 波之间跳变差异，均是由盐胁迫导致细胞极化程度变化导致</span><br></pre></td></tr></table></figure>

<p>需要理解一下这个公式，可能有帮助：</p>
<h4 id="E-E-1-E-2-E-0-frac-RT-nF-log-alpha-1-E-0-frac-RT-nF-log-alpha-2"><a href="#E-E-1-E-2-E-0-frac-RT-nF-log-alpha-1-E-0-frac-RT-nF-log-alpha-2" class="headerlink" title="\(  E = E_1 - E_2 = E_0 - \frac{RT}{nF} \log\alpha_1 - (E_0 - \frac{RT}{nF} \log{\alpha_2}) \)"></a>\(  E = E_1 - E_2 = E_0 - \frac{RT}{nF} \log\alpha_1 - (E_0 - \frac{RT}{nF} \log{\alpha_2}) \)</h4><p>式中，\(R\)为气体常数，\(T\)为绝对温度，\(n\)为反应中的电子数，\(F\) 为法拉第常数。<br>\(E1，E2\) 为换盖子前后的接触电势，\(E0\) 为基础电势，\(\alpha_1，\alpha_2\) 为换盖子前后的氯离子活度<br>离子活度计算公式如下所示，</p>
<h4 id="alpha-i-c-i-times-gamma-i"><a href="#alpha-i-c-i-times-gamma-i" class="headerlink" title="\(\alpha_i = c_i \times \gamma_i\)"></a>\(\alpha_i = c_i \times \gamma_i\)</h4><p>计算中使用的活度因子为:<br>10mM KCl: \(\gamma_{CI} \approx 0.9\)  </p>
<p>300mM NaCl: \(\gamma_{CI} \approx 0.7^{[255]}\)</p>
]]></content>
      <categories>
        <category>machine learing</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>制作数据集(3)</title>
    <url>/2019/06/26/%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86-3/</url>
    <content><![CDATA[<h2 id="人工处理数据"><a href="#人工处理数据" class="headerlink" title="人工处理数据"></a>人工处理数据</h2><p>今天把植物电信号原始数据人工处理，<br>一个周期588个数据<br>人工找出一个周期的起始点，用代码辅助工作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read csv</span></span><br><span class="line">df = pd.read_csv(inputdir, header=None, usecols=[1])</span><br><span class="line">df = df.drop(index=[0,1])</span><br><span class="line"><span class="comment"># split salt stimulation befor</span></span><br><span class="line">n=3</span><br><span class="line">befor_start = 932</span><br><span class="line">befor_end = befor_start+(n*588)</span><br><span class="line">df_befor = df[befor_start:befor_end]</span><br><span class="line">df_befor = df_befor.astype(<span class="built_in">float</span>)</span><br><span class="line">df_befor.plot()</span><br><span class="line">df_befor.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># split salt stimulation after</span></span><br><span class="line">n=5</span><br><span class="line">after_start = 3276</span><br><span class="line">after_end = after_start+(n*588)</span><br><span class="line">df_after = df[after_start:after_end]</span><br><span class="line">df_after = df_after.astype(<span class="built_in">float</span>)</span><br><span class="line">df_after.plot()</span><br><span class="line">df_after.shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge data </span></span><br><span class="line"></span><br><span class="line">DK_1 = df_befor.append(df_after)</span><br><span class="line">DK_1 = DK_1.astype(<span class="built_in">float</span>)</span><br><span class="line">a = len(DK_1) / 588</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"all data cycle : "</span>, a)</span><br><span class="line"><span class="built_in">print</span>(DK_1.values)</span><br><span class="line">DK_1.plot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(df_befor.values)</span></span><br></pre></td></tr></table></figure>

<p>在处理数据的时候发现，发现变成把问题变成一个拟合问题，有点想预测房价。</p>
<p>x1 —-&gt; y1<br>x2 —-&gt; y2<br>x3 —-&gt; y3<br>x4 —-&gt; y4<br>x5 —-&gt; y5<br>   …..<br>xn —-&gt; yn<br>利用这些数据集建立拟合一个神经网络。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>刺激前的信号和刺激后的信号有无关系。</p>
]]></content>
      <categories>
        <category>machine learing</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>制作数据集(2)</title>
    <url>/2019/06/25/%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86-2/</url>
    <content><![CDATA[<h2 id="调试成功一个函数，可以把ndarray格式数组保存为csv"><a href="#调试成功一个函数，可以把ndarray格式数组保存为csv" class="headerlink" title="调试成功一个函数，可以把ndarray格式数组保存为csv"></a>调试成功一个函数，可以把ndarray格式数组保存为csv</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def save_to_csv(output_dir, data, name_prefix,</span><br><span class="line">                header=None, n_parts=10):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    numpy.ndarray ----&gt; save to csv</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    path_format = os.path.join(output_dir, <span class="string">"&#123;&#125;_&#123;:02d&#125;.csv"</span>)</span><br><span class="line">    filenames = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> file_idx, row_indices <span class="keyword">in</span> enumerate(</span><br><span class="line">        np.array_split(np.arange(len(data)), n_parts)):</span><br><span class="line">        part_csv = path_format.format(name_prefix, file_idx)</span><br><span class="line">        filenames.append(part_csv)</span><br><span class="line">        with open(part_csv, <span class="string">"wt"</span>, encoding=<span class="string">"utf-8"</span>) as f:</span><br><span class="line">            <span class="keyword">if</span> header is not None:</span><br><span class="line">                f.write(header + <span class="string">"\n"</span>)</span><br><span class="line">            <span class="keyword">for</span> row_index <span class="keyword">in</span> row_indices:</span><br><span class="line">                f.write(<span class="string">","</span>.join(</span><br><span class="line">                    [repr(col) <span class="keyword">for</span> col <span class="keyword">in</span> data[row_index]]))</span><br><span class="line">                f.write(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="built_in">return</span> filenames</span><br></pre></td></tr></table></figure>

<p>调用函数，使用fetch_california_housing数据集进行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output_dir = <span class="string">"/Users/squareface/code/generate_csv"</span></span><br><span class="line"><span class="keyword">if</span> not os.path.exists(output_dir):</span><br><span class="line">    os.mkdir(output_dir)</span><br><span class="line"></span><br><span class="line">train_data = np.c_[x_train_scaled, y_train]</span><br><span class="line">valid_data = np.c_[x_valid_scaled, y_valid]</span><br><span class="line">test_data = np.c_[x_test_scaled, y_test]</span><br><span class="line"></span><br><span class="line">header_cols = housing.feature_names + [<span class="string">"MidianHouseValue"</span>]</span><br><span class="line">head_str = <span class="string">","</span>.join(header_cols)</span><br><span class="line"></span><br><span class="line">train_filenames = save_to_csv(output_dir, train_data, <span class="string">"train"</span>, </span><br><span class="line">                                          head_str, n_parts=20)</span><br><span class="line">valid_filenames = save_to_csv(output_dir, valid_data, <span class="string">"valid"</span>, </span><br><span class="line">                                          head_str, n_parts=10)</span><br><span class="line">test_filenames = save_to_csv(output_dir, test_data, <span class="string">"test"</span>, </span><br><span class="line">                                          head_str, n_parts=10)</span><br></pre></td></tr></table></figure>

<h2 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h2><p>阅读大牛的code，tf.dataAPI在读取csv文件比较便捷，去翻看下Tensorflow2.0的API文档。</p>
<p>tf读取一个文件夹里所有的csv文件方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># first step: filename ----&gt; filenames</span></span><br><span class="line"><span class="comment"># second step: read file ----&gt; dataset ----&gt; datasets ----&gt; merge</span></span><br><span class="line"><span class="comment"># third step: parse csv</span></span><br><span class="line">def parse_csv_line(line, n_fields = 9):</span><br><span class="line">    defs = [tf.constant(np.nan)] * n_fields</span><br><span class="line">    parsed_fields = tf.io.decode_csv(line, record_defaults=defs)</span><br><span class="line">    x = tf.stack(parsed_fields[0:-1])</span><br><span class="line">    y = tf.stack(parsed_fields[-1:])</span><br><span class="line">    <span class="built_in">return</span> x, y</span><br><span class="line"></span><br><span class="line"><span class="comment"># parse_csv_line(b'-0.9868720801669367,0.832863080552588,-0.18684708416901633,-0.14888949288707784,-0.4532302419670616,-0.11504995754593579,1.6730974284189664,-0.7465496877362412,1.138',</span></span><br><span class="line"><span class="comment">#                n_fields=9)</span></span><br><span class="line"></span><br><span class="line">def csv_reader_dataset(filenames, n_readers=5,</span><br><span class="line">                       batch_size=32, n_parse_threads=5,</span><br><span class="line">                       shuffle_buffer_size=10000):</span><br><span class="line">    dataset = tf.data.Dataset.list_files(filenames)</span><br><span class="line">    dataset = dataset.repeat()</span><br><span class="line">    dataset = dataset.interleave(</span><br><span class="line">        lambda filename: tf.data.TextLineDataset(filename).skip(1),</span><br><span class="line">        cycle_length = n_readers</span><br><span class="line">    )</span><br><span class="line">    dataset.shuffle(shuffle_buffer_size)</span><br><span class="line">    dataset = dataset.map(parse_csv_line,</span><br><span class="line">                          num_parallel_calls=n_parse_threads)</span><br><span class="line">    dataset = dataset.batch(batch_size)</span><br><span class="line">    <span class="built_in">return</span> dataset</span><br><span class="line"></span><br><span class="line">train_set = csv_reader_dataset(train_filenames, batch_size=3)</span><br><span class="line"><span class="keyword">for</span> x_batch, y_batch <span class="keyword">in</span> train_set.take(2):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x:"</span>)</span><br><span class="line">    pprint.pprint(x_batch)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"y:"</span>)</span><br><span class="line">    pprint.pprint(y_batch)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>machine learing</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>制作数据集</title>
    <url>/2019/06/24/%E5%88%B6%E4%BD%9C%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<h2 id="批量处理信号"><a href="#批量处理信号" class="headerlink" title="批量处理信号"></a>批量处理信号</h2><h3 id="把trainX放到一个CSV、trainY放到一个CSV"><a href="#把trainX放到一个CSV、trainY放到一个CSV" class="headerlink" title="把trainX放到一个CSV、trainY放到一个CSV"></a>把trainX放到一个CSV、trainY放到一个CSV</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def read_salt_data(path,name):</span><br><span class="line">    </span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    this function reads csv in batch</span></span><br><span class="line"><span class="string">    path is the folder where the files are located</span></span><br><span class="line"><span class="string">        name is the files name</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    file=glob.glob(os.path.join(path, name))</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> file:  </span><br><span class="line">        dl=pd.read_excel(f,header=None,usecols=[1])</span><br><span class="line">        dl=dl.drop(index=[0,1])</span><br><span class="line">        <span class="built_in">print</span>(dl.values)        </span><br><span class="line"><span class="comment">#         dl_befor = dl[:1550]</span></span><br><span class="line"><span class="comment">#         dl_after = dl[1551:]</span></span><br><span class="line"><span class="comment">#         print(dl_befor.shape)</span></span><br><span class="line"><span class="comment">#         dl_befor.plot()</span></span><br><span class="line"><span class="comment"># #         plt.xlabel("time")</span></span><br><span class="line"><span class="comment"># #         plt.ylabel("value")</span></span><br><span class="line"><span class="comment"># #         plt.grid(True)</span></span><br><span class="line"><span class="comment"># #         dl.plot()</span></span><br><span class="line"></span><br><span class="line">path=<span class="string">'/Users/squareface/Downloads/salt_data'</span></span><br><span class="line">name=<span class="string">"*.xlsx"</span></span><br><span class="line">df = read_salt_data(path,name)</span><br></pre></td></tr></table></figure>

<h2 id="遇到问题："><a href="#遇到问题：" class="headerlink" title="遇到问题："></a>遇到问题：</h2><p>现在可以把一个文件夹里的csv都存储到dl里面，可以把刺激前和刺激后的数据划分，但是无法对在for循环里保存每次读取到的文件</p>
<h2 id="学习代码："><a href="#学习代码：" class="headerlink" title="学习代码："></a>学习代码：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list_l = [[1, 3, 3, 5, 4], [11, 7, 15, 13, 9], [4, 2, 7, 9, 3], [15, 11, 12, 6, 11]]</span><br><span class="line">date_range = pd.date_range(start=<span class="string">"20180701"</span>, periods=4)</span><br><span class="line">df = pd.DataFrame(list_l, index=date_range,</span><br><span class="line">                  columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">out:</span><br><span class="line">                        a   b   c   d   e</span><br><span class="line">            2018-07-01   1   3   3   5   4</span><br><span class="line">            2018-07-02  11   7  15  13   9</span><br><span class="line">            2018-07-03   4   2   7   9   3</span><br><span class="line">            2018-07-04  15  11  12   6  11</span><br></pre></td></tr></table></figure>

<p>这段代码可以把字典保存为CSV文件，并且可以弹出一个可视化界面选择文件保存路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">from tkinter import filedialog</span><br><span class="line">from pandas import DataFrame</span><br><span class="line"><span class="comment"># 制作字典数据</span></span><br><span class="line">Cars = &#123;<span class="string">'Brand'</span>: [<span class="string">'Honda Civic'</span>,<span class="string">'Toyota Corolla'</span>,<span class="string">'Ford Focus'</span>,<span class="string">'Audi A4'</span>],</span><br><span class="line">        <span class="string">'Price'</span>: [22000,25000,27000,35000]</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment"># 字典存为DataFrame格式</span></span><br><span class="line">df = DataFrame(Cars, columns= [<span class="string">'Brand'</span>, <span class="string">'Price'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root= tk.Tk()</span><br><span class="line">canvas1 = tk.Canvas(root, </span><br><span class="line">                    width = 300, </span><br><span class="line">                    height = 300, </span><br><span class="line">                    <span class="built_in">bg</span> = <span class="string">'lightsteelblue2'</span>, </span><br><span class="line">                    relief = <span class="string">'raised'</span>)</span><br><span class="line">canvas1.pack()</span><br><span class="line"></span><br><span class="line">def exportCSV ():</span><br><span class="line">    global df</span><br><span class="line">    export_file_path = filedialog.asksaveasfilename(defaultextension=<span class="string">'.csv'</span>)</span><br><span class="line">    df.to_csv (export_file_path, index = None, header=True)</span><br><span class="line"></span><br><span class="line">saveAsButton_CSV = tk.Button(text=<span class="string">'Export CSV'</span>, </span><br><span class="line">                            <span class="built_in">command</span>=exportCSV, </span><br><span class="line">                            <span class="built_in">bg</span>=<span class="string">'green'</span>, </span><br><span class="line">                            <span class="built_in">fg</span>=<span class="string">'white'</span>, </span><br><span class="line">                            font=(<span class="string">'helvetica'</span>, 12, <span class="string">'bold'</span>))</span><br><span class="line"></span><br><span class="line">canvas1.create_window(150, 150, window=saveAsButton_CSV)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>machine learing</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>LSTM预测盐刺激下植物电信号</title>
    <url>/2019/06/23/LSTM%E9%A2%84%E6%B5%8B%E7%9B%90%E5%88%BA%E6%BF%80%E4%B8%8B%E6%A4%8D%E7%89%A9%E7%94%B5%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="LSTM预测盐刺激下植物电信号"><a href="#LSTM预测盐刺激下植物电信号" class="headerlink" title="LSTM预测盐刺激下植物电信号"></a>LSTM预测盐刺激下植物电信号</h2><h3 id="数据处理出现问题"><a href="#数据处理出现问题" class="headerlink" title="数据处理出现问题"></a>数据处理出现问题</h3><p>创建的模型预测盐刺激后的电信号拟合程度很好。<br>使用的模型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=30, input_shape=(4, 1),return_sequences=True))</span><br><span class="line">model.add(Dropout(0.3))</span><br><span class="line">model.add(Activation(<span class="string">'relu'</span>))</span><br><span class="line">model.add(LSTM(units=30))</span><br><span class="line">model.add(Dropout(0.3))</span><br><span class="line">model.add(Activation(<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(units=4))</span><br><span class="line">model.compile(optimizer=Adam(0.01), loss=<span class="string">'mse'</span>)</span><br></pre></td></tr></table></figure>

<p>但是在检查代码的时候发现数据划分的时候出现问题：trainX和trainY都是盐刺激后的数据。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>把电信号分为两个部分：      </p>
<p>X：刺激前\((x_1,x_2,x_3,…,x_n)\)    </p>
<p>Y：刺激后\((y_1,y_2,y_3,…,y_n)\)    </p>
<h4 id="一个思路："><a href="#一个思路：" class="headerlink" title="一个思路："></a>一个思路：</h4><p>X和Y都选取稳定状态下一个周期的波形。每一个样本总共选择6个周期，即X3个、Y3个。</p>
<p>1、 在软件中手动截取DK小麦稳定状态下的波形，刺激前3个周期，刺激后3个周期，保存为DK-*.xlsx<br>2、 创建数据集，今日思考：X和Y应该如何对应呢？<br>            同一品种的小麦，在稳定状态下的电信号不一样，那x和y应该如何对应起来？</p>
<h5 id="存在问题："><a href="#存在问题：" class="headerlink" title="存在问题："></a>存在问题：</h5><p>同一品种的小麦采集到的稳定状态下的波形不像，原因未知。后续把数据弄好，先看看训练效果。</p>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
]]></content>
      <tags>
        <tag>Machine Learing</tag>
      </tags>
  </entry>
  <entry>
    <title>First Blog</title>
    <url>/2019/06/22/First-Blog/</url>
    <content><![CDATA[<p>测试第一篇博客，以后在这里记录自己解决问题的思路，以及踩到的坑。</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
